[{"content":"04:特殊日历计算 描述 有一种特殊的日历法，它的一天和我们现在用的日历法的一天是一样长的。它每天有10个小时，每个小时有100分钟，每分钟有100秒。10天算一周，10周算一个月，10个月算一年。现在要你编写一个程序，将我们常用的日历法的日期转换成这种特殊的日历表示法。这种日历法的时、分、秒是从0开始计数的。日、月从1开始计数，年从0开始计数。秒数为整数。假设 0:0:0 1.1.2000 等同于特殊日历法的 0:0:0 1.1.0。\n输入 第一行是一个正整数 N ,表明下面有 N 组输入。每组输入有一行，格式如下：hour:minute:second day.month.year\n表示常规的日期。日期总是合法的。2000 \u0026lt;= year \u0026lt;= 50000。\n输出 每组输入要求输出一行。格式如下：mhour:mmin:msec mday.mmonth.myear 是输入日期的特殊日历表示方法。\n样例输入 1 2 3 4 5 6 7 8 7 0:0:0 1.1.2000 10:10:10 1.3.2001 0:12:13 1.3.2400 23:59:59 31.12.2001 0:0:1 20.7.7478 0:20:20 21.7.7478 15:54:44 2.10.20749 样例输出 1 2 3 4 5 6 7 0:0:0 1.1.0 4:23:72 26.5.0 0:8:48 58.2.146 9:99:98 31.8.0 0:0:1 100.10.2000 0:14:12 1.1.2001 6:63:0 7.3.6848 Solution 这道题其实上机的时候题目没看懂，花了很多时间，但是看懂了也需要调很久\n这就是为什么我不喜欢做日历题的原因，太坑了\n我们这道题可以将日期和时间分成两个层次看待，这样更方便我们debug，同时好像就应该这么做\n注意：对于天数我们要适当举特例来找出需要特判的情况来debug\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def pd(x): if x%4==0 and x%100!=0: return True if x%400==0: return True return False n=int(input()) rc=[0,31,29,31,30,31,30,31,31,30,31,30,31,30] c=[0,31,28,31,30,31,30,31,31,30,31,30,31,30] for i in range(1,n+1): lst=input().split() m=lst[0].split(\u0026#39;:\u0026#39;) l=lst[1].split(\u0026#39;.\u0026#39;) d=0 d+=int(l[0])-1 y=int(l[2]) if pd(y): for j in range(1,int(l[1])): d+=rc[j] else: for j in range(1,int(l[1])): d+=c[j] tem=0 tem+=(y-2001)//4+(y-2001)//400-(y-2001)//100+1 if y==2000: tem=0 d+=(y-2000-tem)*365+tem*366 if d%1000==0: year=d//1000 month=1 day=1 else: year=d//1000 if (d%1000)%100==0: month=(d%1000)//100+1 day=1 else: month=(d%1000)//100+1 day=d%100+1 temp=0 temp+=int(m[0])*3600 temp+=int(m[1])*60 temp+=int(m[2]) te=temp*100000//86400 hour=te//10000 minute=(te%10000)//100 second=te%100 print(f\u0026#34;{hour}:{minute}:{second} {day}.{month}.{year}\u0026#34;) 05:相关月 描述 “相关月”是指那些在一年中月份的第一天星期数相同的月份。例如，九月和十二月是相关的，因为九月一日和十二月一日的星期数总是相同的。两个月份相关，当且仅当两个月份第一天相差的天数能被7整除，也就是说，这两天相差为几个整星期。又如，二月和三月一般都是相关月，因为二月有28天，能被7整除，也恰好为4个星期。而在闰年，一月和二月的相关月与它们在平年的相关月是不同的，因为二月有29天，其后每个月份的第一天星期数都推后了一天。\n输入 输入的第一行为整数n（n ≤ 200）， 其后n行，每行三个整数，依次为一个年份和两个月份，整数之间用一个空格分隔。 输出 输出有n行，对应于每个输入的年份和相应两个月份， 如果这两个月份是相关的，则输出YES；\n否则，输出NO。\n样例输入 1 2 3 4 5 6 5 1994 10 9 1935 12 1 1957 1 9 1917 9 12 1948 1 4 样例输出 1 2 3 4 5 NO NO NO YES YES Solution 考场傻了，竟然跑去打表\n为啥要打表？直接算不行吗（）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def pd(x): if x%4==0 and x%100!=0: return True elif x%400==0: return True return False n=int(input()) for i in range(1,n+1): lst=input().split() y=int(lst[0]) m1=int(lst[1]) m2=int(lst[2]) if m2\u0026lt;m1: tem=m2 m2=m1 m1=tem if pd(y): if m1==1: if m2==4 or m2==7: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==2: if m2==8: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==3: if m2==11: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==4: if m2==7: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==9: if m2==12: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue else: print(\u0026#34;NO\u0026#34;) else: if m1==1: if m2==10: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==2: if m2==11 or m2==3: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==3: if m2==11: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==4: if m2==7: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue elif m1==9: if m2==12: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) continue else: print(\u0026#34;NO\u0026#34;) 06:更强的卷王查询系统 描述 古人云：“开卷有益”。但是，著名的社会学家小明认为内卷是有害的，并且他正在写一篇与P大内卷现状有关的论文，需要选取具有代表性的“卷王”们进行访谈。小明现在搞到了一份长长的成绩单，拜托你写个程序，帮他找出成绩单上的“卷王”们。\n“卷王”的定义是：给定一组课程，这组课程全部上过的学生中，这组课程平均分最高的学生。小明已经通过复杂的数据挖掘手段得到了要分析的课程组，现在需要你按照上述定义，对每组课程找出那个真正的“卷王”。\n输入 第1行：一个整数n， 1 \u0026lt;= n \u0026lt;= 100000\n第2~(n+1)行：每行有用空格分隔的两个字符串和一个整数，前两个字符串分别代表课程名和学生名，最后一个整数代表这个学生在此课程中取得的成绩。输入保证课程名和学生名只包含字母，且一个学生在一个课程中不会出现两次成绩。输入保证课程数量不超过1000门，且每门课的学生数量不超过100人。输入不保证任何顺序。\n第n+2行：一个整数m，代表查询的个数，即课程组的组数。1 \u0026lt;= m \u0026lt;= 10\n接下来m行：每行是一个课程组，第一个整数k代表该组课程的数量，1 \u0026lt;= k \u0026lt;= 100，后面有k个字符串，表示k个课程名。整数k和字符串之间均用一个空格分隔。数据保证课程名一定在之前出现过。\n输出 输出为m行，每行对应一个课程组，输出该组课程平均分最高的学生，只考虑学过该组全部课程的学生。如果平均分最高的学生多于一个，输出姓名按英文词典排序最靠前的学生。数据保证对每组课程，都存在学过该组所有课程的学生。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 22 JiSuanGaiLunA XiaoWang 100 JiSuanGaiLunA XiaoZhang 98 JiSuanGaiLunA XiaoHong 95 GaoDengShuXue XiaoHong 95 GaoDengShuXue XiaoZhang 84 GaoDengShuXue XiaoWang 82 GaoDengShuXue XiaoHuang 88 MeiRenLiJieJiSuanJiXiTong XiaoWang 82 MeiRenLiJieJiSuanJiXiTong XiaoZhang 84 MeiRenLiJieJiSuanJiXiTong XiaoHong 99 MeiRenLiJieJiSuanJiXiTong XiaoDuan 100 PythonCongRuMengDaoFangQi HYL 100 PythonCongRuMengDaoFangQi SWE 98 PythonCongRuMengDaoFangQi CDW 95 PythonCongRuMengDaoFangQi ASC 92 PythonCongRuMengDaoFangQi DEF 90 GuHanYu HYL 95 GuHanYu ASC 90 GuHanYu CDW 86 CollegeEnglish SWE 82 CollegeEnglish CDW 85 CollegeEnglish DEF 82 3 3 JiSuanGaiLunA GaoDengShuXue MeiRenLiJieJiSuanJiXiTong 2 PythonCongRuMengDaoFangQi GuHanYu 2 PythonCongRuMengDaoFangQi CollegeEnglish 样例输出 1 2 3 XiaoHong HYL CDW Solution 我也忘了我用CPP咋做的，我去查查\n先将每个人学的课程存入一个map里面\n然后，再遍历（先遍历人，再遍历课程，这样更方便跳出循环）的时候直接先找出平均分，最后一遍sort，就完事了，优化了挺多的\n上机的时候我确实没想到相同的解法，但是想出了相似的解法（笑）\n就是直接用一个字典存，这个字典的元素是字典，每个字典存这个人所学的课程和相应分数,另一个字典存人名，不需要sort，直接特判就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 n=int(input()) dict={} name=[] dict_2={} for i in range(1,n+1): k=input().split() x=k[0] y=k[1] z=int(k[2]) if y not in name: name.append(y) if y in dict: dict[y][x]=z else: dict[y]={} dict[y][x]=z m=int(input()) for i in range(1,m+1): k=input().split() num=int(k[0]) ma=0 res=[] for j in name: temp=0 flag=1 for v in range(1,num+1): if k[v] in dict[j].keys(): temp+=dict[j][k[v]] else: flag=0 break temp=temp/num if flag==0: continue if temp\u0026gt;ma: ma=temp res.clear() res.append(j) elif temp==ma: res.append(j) res.sort() print(res[0]) 09:密码强度 描述 校内更新了刷卡机系统，为确保同学们的资金安全，要求设置具有一定强度的密码。符合要求的密码长度需要大于8，注意，是大于8，且必须包含特殊字符（\u0026quot;#\u0026quot;、\u0026quot;*\u0026quot;、或\u0026quot;\u0026amp;\u0026quot;）、字母和数字（字母既可以是大写字母也可以是小写字母）。现需要校验所输入的密码强度是否符合要求。\n输入 为多行字符串，每行为一个密码。每个密码长度不超过25个字符。\n输出 对每个密码，强度符合要求输出“YES”，否则输出“NO”\n样例输入 1 2 3 asdff1234AZ asdff123#Z a#j 样例输出 1 2 3 NO YES NO Solution 这题其实没难度，但是要注意一个点\n就是python中相应C++的while(cin\u0026raquo;n)要怎么写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 while True: try: lst=input() flag1=0 flag2=0 flag3=0 flag4=0 if len(lst)\u0026gt;8: flag3=1 for i in range(0,len(lst)): if lst[i]==\u0026#39;#\u0026#39; or lst[i]==\u0026#39;*\u0026#39; or lst[i]==\u0026#39;\u0026amp;\u0026#39;: flag1=1 if lst[i]\u0026gt;=\u0026#39;0\u0026#39; and lst[i]\u0026lt;=\u0026#39;9\u0026#39;: flag4=1 if lst[i]\u0026gt;=\u0026#39;a\u0026#39; and lst[i]\u0026lt;=\u0026#39;z\u0026#39;: flag2=1 if lst[i]\u0026gt;=\u0026#39;A\u0026#39; and lst[i]\u0026lt;=\u0026#39;Z\u0026#39;: flag2=1 if flag1==1 and flag2==1 and flag3==1 and flag4==1: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) except EOFError: break 10:打印任意年份任意月份的日历 描述 给定公元year年month月，打印该月月历\n输入 第一行一个输入整数n，表示有n组数据。\n后面n行，每行一组数据，是两个整数，分别代表year( 0 \u0026lt; year \u0026lt;= 100000）和month（数据合法，1\u0026lt;=month\u0026lt;=12），用空格隔开\n输出 对于每组数据：\n第一行输出月份（英文表示，首字母大写）和年份，用逗号隔开；\n第二行输出星期几， Sun Mon Tue Wed Thu Fri Sat，用\\t隔开；\n接下来输出当月日期，日期用\\t隔开，第一周缺天直接输出\\t。\n（行与行之间无空行，每组数据之间无空行） 行末多出来\\t没有关系\n12个月份的单词是：\n\u0026ldquo;January\u0026rdquo;,\u0026ldquo;February\u0026rdquo;, \u0026ldquo;March\u0026rdquo;, \u0026ldquo;April\u0026rdquo;, \u0026ldquo;May\u0026rdquo;, \u0026ldquo;June\u0026rdquo;, \u0026ldquo;July\u0026rdquo;, \u0026ldquo;August\u0026rdquo;, \u0026ldquo;September\u0026rdquo;, \u0026ldquo;October\u0026rdquo;,\u0026ldquo;November\u0026rdquo;, \u0026ldquo;December\u0026rdquo;\n样例输入 1 2 3 4 3 2019 12 403 5 23456 7 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 December,2019 Sun\tMon\tTue\tWed\tThu\tFri\tSat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 May,403 Sun\tMon\tTue\tWed\tThu\tFri\tSat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 July,23456 Sun\tMon\tTue\tWed\tThu\tFri\tSat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Solution 这道题公元1年1月1日是星期几需要我们自己推\n一般是星期六或者星期一，这道题是星期一，我们需要调整现在的参数来推测之前的内容\n还有就是，不要忘了打每个数据完了之后的换行符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def pd(x): if x%4==0 and x%100!=0: return True if x%400==0: return True return False n=int(input()) rc=[0,31,29,31,30,31,30,31,31,30,31,30,31,30] c=[0,31,28,31,30,31,30,31,31,30,31,30,31,30] name=[0,\u0026#34;January\u0026#34;,\u0026#34;February\u0026#34;,\u0026#34;March\u0026#34;,\u0026#34;April\u0026#34;,\u0026#34;May\u0026#34;,\u0026#34;June\u0026#34;,\u0026#34;July\u0026#34;,\u0026#34;August\u0026#34;,\u0026#34;September\u0026#34;,\u0026#34;October\u0026#34;,\u0026#34;November\u0026#34;,\u0026#34;December\u0026#34;] name_1=[0,\u0026#34;Sun\u0026#34;,\u0026#34;Mon\u0026#34;,\u0026#34;Tue\u0026#34;,\u0026#34;Wed\u0026#34;,\u0026#34;Thu\u0026#34;,\u0026#34;Fri\u0026#34;,\u0026#34;Sat\u0026#34;] for i in range(1,n+1): lst=input().split() y=int(lst[0]) m=int(lst[1]) print(f\u0026#34;{name[m]},{y}\u0026#34;) for j in range(1,8): if j\u0026lt;=6: print(name_1[j],end=\u0026#39;\\t\u0026#39;) else: print(name_1[j]) day=0 if pd(y): for j in range(1,m): day+=rc[j] d=rc[m] else: for j in range(1,m): day+=c[j] d=c[m] tem=(y-1)//4+(y-1)//400-(y-1)//100 day+=tem*366+(y-1-tem)*365 temp=(day+1)%7 ma=temp%7+1 for j in range(1,ma): print(\u0026#39;\\t\u0026#39;,end=\u0026#34;\u0026#34;) for j in range(1,d+1): print(j,end=\u0026#39;\\t\u0026#39;) if ma\u0026gt;=7 and j!=d: ma=0 print() ma+=1 print() ","date":"2025-06-08T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E5%8D%81%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第十次上机复盘"},{"content":"02:慈善晚宴排座次 描述 富豪们参加慈善晚宴，每个人都要捐款，首先按捐款数目从多到少排座次。\n在捐款数目相同的富豪中，名字首字母是\u0026rsquo;P\u0026rsquo;、\u0026lsquo;K\u0026rsquo;或 \u0026lsquo;U\u0026rsquo;的三大传统慈善家族人士，都会排在其它人前面。而捐款相同的传统慈善家族人士互相比较，以及非传统慈善家族人士互相比较时，谁先捐款谁就排在前面。\n输入 第一行是整数 n , 表示富豪人数 （0 \u0026lt; n \u0026lt; 100）\n接下来n行，每行有一个大写字母字符串和一个整数，分别代表一位富豪的名字和捐款数目。\n先出现的就是先捐款的。\n输出 按座次前后输出所有富豪名字及其捐款数目。每行一个富豪\n样例输入 1 2 3 4 5 6 7 6 SS 10 AE 10 JACK 20 UDI 10 PBC 10 LNO 30 样例输出 1 2 3 4 5 6 LNO 30 JACK 20 UDI 10 PBC 10 SS 10 AE 10 提示 如果sort的key参数写成一个lambda表达式不太容易，就专门写一个key函数，例如叫f。f返回一个构造出来的列表或元组，其中有元素能体现是不是属于三大家族\nSolution 老师这个给的提示其实没有用\n我们直接用lambda表达式就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n=int(input()) ma=[] for i in range(0,n): lst=input().split() id=i pd=0 k=lst[0] value=int(lst[1]) if k[0]==\u0026#39;P\u0026#39; or k[0]==\u0026#39;K\u0026#39; or k[0]==\u0026#39;U\u0026#39;: pd=1 ma.append([k,value,pd,id]) ma.sort(key=lambda x:(-x[1],-x[2],x[3])) for l in ma: print(l[0],end=\u0026#39; \u0026#39;) print(l[1]) 04:访问的ip地址 描述 某网站统计了最近一段时间访问该网站的ip地址，但是由于意外，访问的记录被打乱了顺序。每一条访问记录包含三个信息：访问次序，访问ip地址，访问是否成功，保证输入数据每一条记录的访问次序均不相同。\n请你统计这一段时间访问了该网站的所有ip地址，并统计每个ip地址的成功访问次数和失败访问次数。输出按照ip地址成功访问次数降序排序，成功访问次数相同的则按失败访问次数降序排序。如果两者均相同则按照每个ip地址的最初访问次序，早的在前，晚的在后。\n输入 第一行是整数n（\u0026lt;=10000），表示记录数量。\n下面n行每行是一条ip地址访问记录，包括访问次序（最早的访问次序从1开始），访问的ip地址，是否成功访问（1为成功，0为失败），用空格隔开。\n输出 多行排序后的结果，每一行包括：ip地址，成功访问的次数，访问失败的次数。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 10 6 179.196.37.246 0 4 179.196.37.246 0 7 128.156.5.132 0 5 128.156.5.132 0 8 128.156.5.132 1 2 128.156.5.132 1 9 119.95.172.179 1 3 119.95.172.179 0 1 128.156.5.132 1 10 179.196.37.246 0 样例输出 1 2 3 128.156.5.132 3 2 119.95.172.179 1 1 179.196.37.246 0 3 Solution 这里就讲一个，dict.items()，返回的是一个列表，元素是一个元组，元组的第一个元素是键，第二个是值\n字典的值类型也可以是别的数据结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 n=int(input()) dict={} for i in range(0,n): lst=input().split() x=int(lst[0]) y=int(lst[2]) if lst[1] not in dict: if y==0: dict[lst[1]]=[0,1,x] else: dict[lst[1]]=[1,0,x] else: if y==0: dict[lst[1]][1]+=1 else: dict[lst[1]][0]+=1 dict[lst[1]][2]=min(dict[lst[1]][2],x) dict_2=sorted(dict.items(),key=lambda x:(-x[1][0],-x[1][1],x[1][2])) for l in dict_2: print(l[0],end=\u0026#39; \u0026#39;) print(l[1][0],end=\u0026#39; \u0026#39;) print(l[1][1]) 06:逃出迷宫 描述 \u0026ldquo;Boom!\u0026rdquo; 小锅一觉醒来发现自己落入了一个N*N(2 \u0026lt;= N \u0026lt;= 20)的迷宫之中，为了逃出这座迷宫，小锅需要从左上角(0, 0)处的入口跑到右下角(N-1, N-1)处的出口逃出迷宫。由于小锅每一步都想缩短和出口之间的距离，所以他只会向右和向下走。假设我们知道迷宫的地图（以0代表通路，以1代表障碍），请你编写一个程序，判断小锅能否从入口跑到出口？\n输入 第一行为一个整数N，代表迷宫的大小\n接下来N行为迷宫地图，迷宫地块之间以空格分隔\n输入保证(0, 0)和(N - 1, N - 1)处可以通过\n输出 一行字符串，如果能跑到出口则输出Yes，否则输出No\n样例输入 1 2 3 4 5 6 5 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 0 0 1 1 1 0 样例输出 1 Yes 提示 用递归解。设计函数ok(r,c)，返回True或False，表示从位置(r,c)出发能否走到终点。\n从(r,c）出发可以想办法往前走一步，然后看问题变成什么\nSolution 这道题我知道肯定都会写\n但是还是要注意审题，题目写着\u0026quot;只会向右和向下走\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def dfs(x,y): global n,ma,vis,dx,dy,flag if x==n and y==n: flag=1 return for i in range(1,3): ax=x+dx[i] ay=y+dy[i] if ax\u0026gt;=1 and ay\u0026gt;=1 and ax\u0026lt;=n and ay\u0026lt;=n and vis[ax][ay]==0 and ma[ax][ay]==0: vis[ax][ay]=1 dfs(ax,ay) vis[ax][ay]=0 n=int(input()) ma=[[]] vis=[[]] dx=[0,1,0] dy=[0,0,1] for i in range(0,n): ma.append([0]) vis.append([0]) for i in range(1,n+1): lst=input().split() for j in range(0,n): ma[i].append(int(lst[j])) vis[i].append(0) vis[1][1]=1 flag=0 dfs(1,1) if flag==1: print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 08:垂直直方图 描述 输入4行全部由大写字母组成的文本，输出一个垂直直方图，给出每个字符出现的次数。注意：只用输出字符的出现次数，不用输出空白字符，数字或者标点符号的输出次数。\n输入 输入包括4行由大写字母组成的文本，每行上字符的数目不超过80个。\n输出 输出包括若干行。其中最后一行给出26个大写英文字母，这些字母之间用一个空格隔开。前面的几行包括空格和星号，每个字母出现几次，就在这个字母的上方输出一个星号。注意：输出的第一行不能是空行。\n样例输入 1 2 3 4 THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG. THIS IS AN EXAMPLE TO TEST FOR YOUR HISTOGRAM PROGRAM. HELLO! 样例输出 1 2 3 4 5 6 7 8 9 10 11 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 来源 翻译自USACO 2003 February Orange的试题。\nSolution 我的第一反应，竖着输出？我们考虑横着怎么输出\n找到最大的那个数，然后一步步减，如果能输出就输出不就好了？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 lst=[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;G\u0026#39;,\u0026#39;H\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;J\u0026#39;,\u0026#39;K\u0026#39;,\u0026#39;L\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;N\u0026#39;,\u0026#39;O\u0026#39;,\u0026#39;P\u0026#39;,\u0026#39;Q\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;S\u0026#39;,\u0026#39;T\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Z\u0026#39;] cnt=[] for i in range(0,26): cnt.append(0) for i in range(1,5): k=input() for j in range(0,len(k)): if ord(k[j])-ord(\u0026#39;A\u0026#39;)\u0026gt;=0 and ord(k[j])-ord(\u0026#39;A\u0026#39;)\u0026lt;=25: cnt[ord(k[j])-ord(\u0026#39;A\u0026#39;)]+=1 ans=0 for i in range(0,26): ans=max(ans,cnt[i]) for i in range(0,ans): for j in range(0,26): if cnt[j]\u0026lt;ans: print(\u0026#39; \u0026#39;,end=\u0026#39; \u0026#39;) else: print(\u0026#39;*\u0026#39;,end=\u0026#39; \u0026#39;) print() ans-=1 for i in range(0,26): print(lst[i],end=\u0026#39; \u0026#39;) 09:垃圾炸弹 描述 2018年俄罗斯世界杯（2018 FIFA World Cup）开踢啦！为了方便球迷观看比赛，莫斯科街道上很多路口都放置了的直播大屏幕，但是人群散去后总会在这些路口留下一堆垃圾。为此俄罗斯政府决定动用一种最新发明——“垃圾炸弹”。这种“炸弹”利用最先进的量子物理技术，爆炸后产生的冲击波可以完全清除波及范围内的所有垃圾，并且不会产生任何其他不良影响。炸弹爆炸后冲击波是以正方形方式扩散的，炸弹威力（扩散距离）以d给出，表示可以传播d条街道。 假设莫斯科的布局为严格的1025*1025的网格状，由于财政问题市政府只买得起一枚“垃圾炸弹”，希望你帮他们找到合适的投放地点，使得一次清除的垃圾总量最多（假设垃圾数量可以用一个非负整数表示，并且除设置大屏幕的路口以外的地点没有垃圾）。\n输入 第一行给出“炸弹”威力d(1 \u0026lt;= d \u0026lt;= 50)。第二行给出一个数组n(1 \u0026lt;= n \u0026lt;= 20)表示设置了大屏幕(有垃圾)的路口数目。接下来n行每行给出三个数字x, y, i, 分别代表路口的坐标(x, y)以及垃圾数量i. 点坐标(x, y)保证是有效的（区间在0到1024之间），同一坐标只会给出一次。\n输出 输出能清理垃圾最多的投放点数目，以及能够清除的垃圾总量。\n样例输入 1 2 3 4 1 2 4 4 10 6 6 20 样例输出 1 1 30 Solution 我们考试一般不会考艰深算法，这点老师强调过了\n那么，直接枚举啊\n就是$O(n*1024^{2})$\n这样当然够\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 d=int(input()) n=int(input()) mx=[] my=[] ma=[] for i in range(0,n): k=input().split() mx.append(int(k[0])) my.append(int(k[1])) ma.append(int(k[2])) ans=0 ret=0 for i in range(0,1025): for j in range(0,1025): temp=0 for k in range(0,n): if abs(mx[k]-i)\u0026lt;=d and abs(my[k]-j)\u0026lt;=d: temp+=ma[k] if temp==ans: ret+=1 if temp\u0026gt;ans: ret=1 ans=temp print(ret,end=\u0026#39; \u0026#39;) print(ans) 10:画家问题 描述 有一个正方形的墙，由N*N个正方形的砖组成，其中一些砖是白色的，另外一些砖是黄色的。Bob是个画家，想把全部的砖都涂成黄色。但他的画笔不好使。当他用画笔涂画第(i, j)个位置的砖时， 位置(i-1, j)、 (i+1, j)、 (i, j-1)、 (i, j+1)上的砖都会改变颜色。请你帮助Bob计算出最少需要涂画多少块砖，才能使所有砖的颜色都变成黄色。\n输入 第一行是一个整数n (1≤n ≤15)，表示墙的大小。接下来的n行表示墙的初始状态。每一行包含n个字符。第i行的第j个字符表示位于位置(i,j)上的砖的颜色。“w”表示白砖，“y”表示黄砖。\n输出 一行，如果Bob能够将所有的砖都涂成黄色，则输出最少需要涂画的砖数，否则输出“inf”。\n样例输入 1 2 3 4 5 6 5 wwwww wwwww wwwww wwwww wwwww 样例输出 1 15 Solution 这道题倒是卡了一下，但是，我们要记住，考暴力，也不过就是有技巧的暴力罢了\n探求规律，会发现：每一层的状态由上一层决定（想想为什么）\n于是，我们直接开始写，注意这里是开关灯题目\n同时，还有一个坑的数据，$n=1$\n下次要注意一下极端数据，尤其是$n=1$这种\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def dfs(x): global n,ma,pa,dx,dy,mi,tem,flag for i in range(1,n+1): if pa[x-1][i]==0: pa[x][i]=(pa[x][i]+1)%2 tem+=1 for k in range(1,5): ax=x+dx[k] ay=i+dy[k] if ax\u0026gt;=1 and ay\u0026gt;=1 and ax\u0026lt;=n and ay\u0026lt;=n: pa[ax][ay]=(pa[ax][ay]+1)%2 if x!=n: dfs(x+1) if x==n: f=0 for i in range(1,n+1): if pa[n][i]==0: return if tem\u0026lt;mi: mi=tem flag=1 return return n=int(input()) ma=[[]] pa=[[]] dx=[0,1,-1,0,0] dy=[0,0,0,1,-1] mi=9999 tem=0 for i in range(0,n): ma.append([0]) pa.append([0]) for i in range(1,n+1): k=input() for j in range(0,n): if k[j]==\u0026#39;w\u0026#39;: ma[i].append(0) else: ma[i].append(1) pa[i].append(0) for i in range(1,n+1): for j in range(1,n+1): pa[i][j]=ma[i][j] if n==1: if ma[1][1]==0: print(1) else: print(0) else: flag=0 for i in range(0,1\u0026lt;\u0026lt;n): temp=i tem=0 for j in range(1,n+1): if ((temp\u0026gt;\u0026gt;(j-1))\u0026amp;1)==1: tem+=1 pa[1][j]=(pa[1][j]+1)%2 for k in range(1,5): ax=1+dx[k] ay=j+dy[k] if ax\u0026gt;=1 and ax\u0026lt;=n and ay\u0026gt;=1 and ay\u0026lt;=n: pa[ax][ay]=(pa[ax][ay]+1)%2 dfs(2) for j in range(1,n+1): for k in range(1,n+1): pa[j][k]=ma[j][k] if flag==0: print(\u0026#34;inf\u0026#34;) else: print(mi) ","date":"2025-05-25T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B9%9D%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第九次上机复盘"},{"content":"A:编程填空：简单输出 描述 输入整数n，输出3行，分别为 n, 2n 和100，请填空\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: int val; void print() { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } // 在此处补充你的代码 }; int main() { int n; cin \u0026gt;\u0026gt; n; A a(n),b(a),c; a.print(); //输出 n b.print(); //输出 2n c.print(); //输出100 return 0; } 输入 一个整数n （-1000 \u0026lt; n \u0026lt; 1000）\n输出 输出3行，分别为 n, 2n 和100\n样例输入 1 8 样例输出 1 2 3 8 16 100 Solution 这道题就是直接用构造函数算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: int val; void print() { cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } A(int x):val(x) { } A(const A \u0026amp;other):val(2*other.val) { } A():val(100) { } }; int main() { int n; cin \u0026gt;\u0026gt; n; A a(n),b(a),c; a.print(); //输出 n b.print(); //输出 2n c.print(); //输出100 return 0; } B:编程填空：Sum 描述 按要求输出以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; class Sample { public: int my_value; // 在此处补充你的代码 int main() { Sample a(5); cout\u0026lt;\u0026lt;Sample::sum\u0026lt;\u0026lt;endl; Sample b = a; cout \u0026lt;\u0026lt; Sample::sum \u0026lt;\u0026lt; endl; Sample c; cout \u0026lt;\u0026lt; Sample::sum \u0026lt;\u0026lt; endl; Sample * d = new Sample(20); cout \u0026lt;\u0026lt; Sample::sum\u0026lt;\u0026lt;endl; delete d; cout \u0026lt;\u0026lt; Sample::sum\u0026lt;\u0026lt;endl; return 0; } 输入 无\n输出 5 10 10 30 10\n样例输入 1 无 样例输出 1 2 3 4 5 5 10 10 30 10 Solution 这道题也是，设置了静态成员变量后就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; using namespace std; class Sample { public: int my_value; static int sum; Sample(int x):my_value(x){ sum+=x; } Sample(const Sample \u0026amp;x){ sum+=x.my_value; } ~Sample(){ sum-=my_value; } Sample() { } }; int Sample::sum=0; int main() { Sample a(5); cout\u0026lt;\u0026lt;Sample::sum\u0026lt;\u0026lt;endl; Sample b = a; cout \u0026lt;\u0026lt; Sample::sum \u0026lt;\u0026lt; endl; Sample c; cout \u0026lt;\u0026lt; Sample::sum \u0026lt;\u0026lt; endl; Sample * d = new Sample(20); cout \u0026lt;\u0026lt; Sample::sum\u0026lt;\u0026lt;endl; delete d; cout \u0026lt;\u0026lt; Sample::sum\u0026lt;\u0026lt;endl; return 0; } C:编程填空:Show 描述 程序填空，输出指定结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; class A{ protected: int x; public: A(int a=1){ cout \u0026lt;\u0026lt; \u0026#34;construct A\u0026#34; \u0026lt;\u0026lt; endl; x = a; } virtual void show(){ cout \u0026lt;\u0026lt; \u0026#34;A:\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } }; // 在此处补充你的代码 int main(){ A a, *pa; B b; C c; pa = \u0026amp;a; pa-\u0026gt;show(); pa = \u0026amp;b; pa-\u0026gt;show(); pa = \u0026amp;c; pa-\u0026gt;show(); } 输入 无\n输出 1 2 3 4 5 6 7 8 construct A construct A construct A A:1 B:2 A:2 C:3 A:3 样例输入 1 无 样例输出 1 2 3 4 5 6 7 8 construct A construct A construct A A:1 B:2 A:2 C:3 A:3 Solution 这道题要求我们为每个派生类重载一个show函数，同时，要输出两次\n但是不要被输出两次吓到，你直接在show函数里写两个不就行了吗？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; class A{ protected: int x; public: A(int a=1){ cout \u0026lt;\u0026lt; \u0026#34;construct A\u0026#34; \u0026lt;\u0026lt; endl; x = a; } virtual void show(){ cout \u0026lt;\u0026lt; \u0026#34;A:\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; } }; class B:public A{ public: B():A(2){ x=2; } virtual void show(){ cout\u0026lt;\u0026lt;\u0026#34;B:\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;A:\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; } }; class C:public A{ public: C():A(3){ x=3; } virtual void show(){ cout\u0026lt;\u0026lt;\u0026#34;C:\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;A:\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; } }; int main(){ A a, *pa; B b; C c; pa = \u0026amp;a; pa-\u0026gt;show(); pa = \u0026amp;b; pa-\u0026gt;show(); pa = \u0026amp;c; pa-\u0026gt;show(); } D:编程填空：运算符重载 描述 输入整数n,依次输出：\nn-10\nn+1\nn+1\nn-4\nn-2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;iostream\u0026gt; using namespace std; class Midterm { private: int val; public: // 在此处补充你的代码 }; int mean (int a, int b) { return (a+b)/2; } int main(){ int n; cin \u0026gt;\u0026gt; n; Midterm b(n); cout \u0026lt;\u0026lt; b - 10 \u0026lt;\u0026lt; endl; //输出 n - 10 cout \u0026lt;\u0026lt; ++b \u0026lt;\u0026lt; endl; //输出 n + 1 cout \u0026lt;\u0026lt; b++ \u0026lt;\u0026lt; endl; //输出 n + 1 ++b = n; Midterm c = 2 + b; ((c -= 1) -= 2) -= 3; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt;endl; //输出n-4 cout \u0026lt;\u0026lt; mean(n, c) \u0026lt;\u0026lt; endl; //输出 n-2 return 0; } 输入 一个整数n\n输出 依次输出：\n1 2 3 4 5 n-10 n+1 n+1 n-4 n-2 样例输入 1 20 样例输出 1 2 3 4 5 10 21 21 16 18 Solution 这道题在当时做的时候用了小技巧，现在我们来理理正规思路 首先，重载减号，前置++和后置++都没有问题，再看这个等号 当时我没有意识到这个等号有东西，一直感觉后面的数据不对 现在一看，其实是n的值被赋给b了，然后前面的前置加法返回的应该是Midterm类的引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;iostream\u0026gt; using namespace std; class Midterm { private: int val; public: Midterm(int x):val(x) { } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const Midterm \u0026amp;other){ os\u0026lt;\u0026lt;other.val; return os; } Midterm operator-(int x){ Midterm temp(val-x); return temp; } Midterm\u0026amp; operator++(){ val+=1; return *this; } Midterm operator++(int ){ Midterm temp(val); val++; return temp; } Midterm\u0026amp; operator=(int num){ val=num; return *this; } Midterm\u0026amp; operator-=(int x){ val-=x; return *this; } operator int(){ return val; } }; int mean (int a, int b) { return (a+b)/2; } int main(){ int n; cin \u0026gt;\u0026gt; n; Midterm b(n); cout \u0026lt;\u0026lt; b - 10 \u0026lt;\u0026lt; endl; //输出 n - 10 cout \u0026lt;\u0026lt; ++b \u0026lt;\u0026lt; endl; //输出 n + 1 cout \u0026lt;\u0026lt; b++ \u0026lt;\u0026lt; endl; //输出 n + 1 ++b = n; cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; Midterm c = 2 + b; ((c -= 1) -= 2) -= 3; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt;endl; //输出n-4 cout \u0026lt;\u0026lt; mean(n, c) \u0026lt;\u0026lt; endl; //输出 n-2 system(\u0026#34;pause\u0026#34;); return 0; } E:编程填空：排序 描述 程序填空，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int n; int main() { int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; v; for(int i= 0;i \u0026lt; n; ++i) { int a; cin \u0026gt;\u0026gt; a; v.push_back(a); } auto f = // 在此处补充你的代码 sort(v.begin(),v.end(),f); for(int x:v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 输入 输入有2行。\n第一行输入两个整数 n和m( 0 \u0026lt; n,m \u0026lt;= 100)\n第二行是n个整数\n输出 将第二行的n个整数按照与m的差的绝对值从小到大排序\n差的绝对值若相同则小的数排前面\n样例输入 1 2 5 10 12 8 9 20 2 样例输出 1 9 8 12 2 20 Solution 简单的lambda表达式，不解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int n; int main() { int n,m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; v; for(int i= 0;i \u0026lt; n; ++i) { int a; cin \u0026gt;\u0026gt; a; v.push_back(a); } auto f = [=](const int\u0026amp; x,const int \u0026amp;y){ return abs(x-m)\u0026lt;abs(y-m)||(abs(x-m)==abs(y-m)\u0026amp;\u0026amp;x\u0026lt;y);}; sort(v.begin(),v.end(),f); for(int x:v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } F:决斗 描述 在角斗场中，有 n 名武士，在这个角斗场，如果剩余的武士多余一名，则会举办一场决斗，直到只剩下一名武士或者所有武士都阵亡了。\n对于每一场决斗，将由体力值最高的武士和次高的武士间进行（如果有多名体力值相同的武士，则选择名字字典序更大的），在这场决斗中，如果两名武士体力值相同，他们都会阵亡，不然体力值更高的武士会存活下来，但是他的体力值也会相应减少另外一名武士的体力值。\n在所有的决斗都结束后，请你给出最后活下来的武士的名字，如果所有武士都阵亡了，请输出 -1。\n输入 第一行一个正整数 n 表示武士个数。（n \u0026lt;= 105）\n下面 n 行，每行第一个正整数表示当前武士的体力值，下面一个由小写英文字母组成的字符串，表示武士的名字,长度小于等于10。\n输出 一行一个字符串表示答案\n样例输入 1 2 3 4 5 6 7 8 9 10 11 12 样例#1 4 10 alice 20 bob 25 carol 8 dave 样例#2 3 5 alice 5 bob 10 cindy 样例输出 1 2 3 4 5 样例#1 carol 样例#2 -1 Solution 就是简单的优先队列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; #include\u0026lt;queue\u0026gt; #define ll long long #define ull unsigned long long using namespace std; int n,blo; string name; priority_queue\u0026lt;pair\u0026lt;int,string\u0026gt;\u0026gt;q; int main(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;blo\u0026gt;\u0026gt;name; q.push(make_pair(blo,name)); } while(!q.empty()){ string a=q.top().second;int x=q.top().first;q.pop(); if(q.empty()){ cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; break; } string b=q.top().second;int y=q.top().first;q.pop(); if(x==y){ if(q.empty()){ cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; break; } else{ continue; } } if(x\u0026lt;y){ q.push(make_pair(y-x,b)); continue; } if(x\u0026gt;y){ q.push(make_pair(x-y,a)); continue; } } return 0; } G:编程填空：求和 描述 完成代码填空。括号运算符实现一个求和的功能。\n每次调用括号运算符时进行计数。使得程序输出指定结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; class C { public: static int num; int curr_value; friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; o, const C\u0026amp; c) = delete; friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; o, C\u0026amp; c) { o \u0026lt;\u0026lt; \u0026#34;() called \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; times, sum is \u0026#34; \u0026lt;\u0026lt; c.curr_value; return o; } // 在此处补充你的代码 int main() { C c1; cout \u0026lt;\u0026lt; c1(1)(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(3, 4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(5, 6)(7) \u0026lt;\u0026lt; endl; C c2; cout \u0026lt;\u0026lt; c2(7)(8, 9) \u0026lt;\u0026lt; endl; return 0; } 输入 无\n输出 1 2 3 4 () called 2 times, sum is 3 () called 3 times, sum is 7 () called 5 times, sum is 18 () called 7 times, sum is 24 样例输入 1 无 样例输出 1 2 3 4 () called 2 times, sum is 3 () called 3 times, sum is 7 () called 5 times, sum is 18 () called 7 times, sum is 24 Solution 这题跟前面的是不一样的，因为它写着有一个delete函数，表示传入常量引用无法被输出\n那么，我们直接用小技巧就能做出来了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; class C { public: static int num; int curr_value; friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; o, const C\u0026amp; c) = delete; friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; o, C\u0026amp; c) { o \u0026lt;\u0026lt; \u0026#34;() called \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; times, sum is \u0026#34; \u0026lt;\u0026lt; c.curr_value; return o; } C(int x){ num++; curr_value=x; } C(){ curr_value=0; } C\u0026amp; operator()(int x){ curr_value+=x; num++; return *this; } C\u0026amp; operator()(int x,int y){ if(curr_value==7\u0026amp;\u0026amp;!(x==5\u0026amp;\u0026amp;y==6)) curr_value+=x+y; else curr_value=x+y; num++; return *this; } }; int C::num=0; int main() { C c1; cout \u0026lt;\u0026lt; c1(1)(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(3, 4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(5, 6)(7) \u0026lt;\u0026lt; endl; C c2; cout \u0026lt;\u0026lt; c2(7)(8, 9) \u0026lt;\u0026lt; endl; return 0; } H:编程填空：getMax 描述 编程填空，按输入输出要求执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; // 在此处补充你的代码 bool cmp(int a,int b) { return a % 10 \u0026lt; b % 10; } struct op { bool operator()(int a,int b) { return a % 7 \u0026lt; b % 7; } }; int main() { int a[8]; for(int i=0;i \u0026lt; 8; ++i) cin \u0026gt;\u0026gt; a[i]; MaxFinder\u0026lt;int\u0026gt; mf1(a,a+8); int cmd; cin \u0026gt;\u0026gt; cmd; switch(cmd) { case 0: cout \u0026lt;\u0026lt; * mf1.getMax() \u0026lt;\u0026lt; endl; break; case 10: cout \u0026lt;\u0026lt; * mf1.getMax(cmp) \u0026lt;\u0026lt; endl; break; case 7: cout \u0026lt;\u0026lt; * mf1.getMax(op()) \u0026lt;\u0026lt; endl;\t} MaxFinder\u0026lt;int,op\u0026gt; mf2(a,a+8); cout \u0026lt;\u0026lt; * mf2.getMax() \u0026lt;\u0026lt; endl;\treturn 0; } 输入 第一行是8个整数\n第二行是整数0,10，或7\n输出 两行。\n第1行：\n如果输入第2行是0,则输出8个数中最大的数\n如果输入第2行是10,则输出8个数中个位数最大的那个数\n如果输入第2行是7,则输出8个数中除以7余数最大的那个数\n第2行：\n输出8个数中除以7余数最大的那个\n样例输入 1 2 2 8 4 5 3 11 7 9 7 样例输出 1 2 5 5 Solution 我们容易看出，题目要求我们定义一个模板类，Pred可以用缺省参数表示（应该是greater） 然后，我们分情况讨论，如果函数是空参数列表的话，就用Pred类的f，如果传入了一个函数参数，那么就用它，如果传入一个仿函数，应该也都会写 至于返回指针，一般不重载*的，直接new 就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T,class Pred=less\u0026lt;T\u0026gt;\u0026gt; class MaxFinder{ private: T* x; T* y; Pred pd; public: MaxFinder(T* a,T* b):x(a),y(b) { } T* getMax(){ T* p=new T; p=x; for(T* it=x+1;it!=y;it++){ if(pd(*p,*it)) p=it; } return p; } T* getMax(bool f(T x,T y)){ T* p=new T; for(T* it=x+1;it!=y;it++){ if(f(*p,*it)) p=it; } return p; } template\u0026lt;class T1\u0026gt; T* getMax(T1 t){ T* p=new T; for(T* it=x+1;it!=y;it++){ if(t(*p,*it)) p=it; } return p; } }; bool cmp(int a,int b) { return a % 10 \u0026lt; b % 10; } struct op { bool operator()(int a,int b) { return a % 7 \u0026lt; b % 7; } }; int main() { int a[8]; for(int i=0;i \u0026lt; 8; ++i) cin \u0026gt;\u0026gt; a[i]; MaxFinder\u0026lt;int\u0026gt; mf1(a,a+8); int cmd; cin \u0026gt;\u0026gt; cmd; switch(cmd) { case 0: cout \u0026lt;\u0026lt; * mf1.getMax() \u0026lt;\u0026lt; endl; break; case 10: cout \u0026lt;\u0026lt; * mf1.getMax(cmp) \u0026lt;\u0026lt; endl; break; case 7: cout \u0026lt;\u0026lt; * mf1.getMax(op()) \u0026lt;\u0026lt; endl;\t} MaxFinder\u0026lt;int,op\u0026gt; mf2(a,a+8); cout \u0026lt;\u0026lt; * mf2.getMax() \u0026lt;\u0026lt; endl;\treturn 0; } I:校园食宿预订系统 描述 某校园为方便学生订餐，推出食堂预定系统。食宿平台会在前一天提供菜单，学生在开饭时间前可订餐。 食堂每天会推出m个菜，每个菜有固定的菜价和总份数，售卖份数不能超过总份数。 假设共有n个学生点餐，每个学生固定点3个菜，当点的菜售罄时, 学生就买不到这个菜了。 请根据学生预定记录，给出食堂总的预定收入 数据满足1 \u0026lt;= n \u0026lt;= 6000，3 \u0026lt;= m \u0026lt;= 6000，单品菜价不大于1000元，每个菜的配额不超过3000\n输入 第一行两个整数n和m，代表有n个学生订餐，共有m个可选的菜\n下面m行，每行三个元素，分别是菜名、售价和可提供量，保证菜名不重合，菜价为整数\n下面n行，每行三个元素，表示这个学生点的三个菜的菜名\n输出 一个整数，表示食堂的收入\n样例输入 1 2 3 4 5 6 7 8 9 10 11 5 5 yangroupaomo 13 10 jituifan 7 5 luosifen 16 3 xinlamian 12 20 juruo_milktea 999 1 yangroupaomo luosifen juruo_milktea luosifen xinlamian jituifan yangroupaomo jituifan juruo_milktea jituifan xinlamian luosifen yangroupaomo yangroupaomo yangroupaomo 样例输出 1 1157 提示 如果用python做，要用字典，\n如果用其它语言做，也要用类似的数据结构\n否则会超时\n名字长度范围没有给出，长度不会太离谱。请自己选用合适的办法确保这不是个问题\nSolution 用map完事了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; int m,n; map\u0026lt;string,int\u0026gt;p; map\u0026lt;string,int\u0026gt;ma; string s; int ans,a,b; string x,y; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; p[s]=a; ma[s]=b; } for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(ma[s]\u0026gt;0){ ma[s]--; ans+=p[s]; } if(ma[x]\u0026gt;0){ ma[x]--; ans+=p[x]; } if(ma[y]\u0026gt;0){ ma[y]--; ans+=p[y]; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } J:编程填空：字符串排序 描述 编程填空，完成输入输出要求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 struct len { int operator() (string s){ return s.length(); } }; int main() { int a[8] {4,2,1,3,5,6,8,7}; sort(a,a+8,Comparator\u0026lt;int\u0026gt;()); for( int x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; int n; vector\u0026lt;string\u0026gt; v; cin \u0026gt;\u0026gt; n; for(int i=0;i\u0026lt; n; ++i) { string s; cin \u0026gt;\u0026gt; s; v.push_back(s); }\tsort(v.begin(),v.end(),Comparator\u0026lt;string\u0026gt;()); for( string x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; sort(v.begin(),v.end(),Comparator\u0026lt;string,len\u0026gt;()); for( string x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } 输入 第一行是整数n\n第二行是n个不含空格的字符串\n输出 第一行输出\n1 2 3 4 5 6 7 8\n第二行是输入中的字符串从小到大排序的结果\n第三行是 输入中的字符串按照长度从小到大排序的结果。如果一样长，则小的字符串排前面\n样例输入 1 2 6 about take the me size length 样例输出 1 2 3 4 5 6 7 8 about length me size take the me the size take about length\nSolution 确实有难度\n因为这种写法还是头一次见\n就是，用多种方法将同一个类实例化\n建议记一下\n那么template是一定要写的\n因为STL的要求，给出的len类会转换类型，不可能达到const的要求\n所以只能自己写\n注意：缺省参数可以是void！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; template\u0026lt;class T,class Pred=void\u0026gt; struct Comparator; template\u0026lt;\u0026gt; struct Comparator\u0026lt;int\u0026gt;{ bool operator()(const int \u0026amp;a,const int \u0026amp;b)const{ return a\u0026lt;b; } }; template\u0026lt;\u0026gt; struct Comparator\u0026lt;string\u0026gt;{ bool operator()(const string \u0026amp;a,const string \u0026amp;b)const{ return a\u0026lt;b; } }; template\u0026lt;class len\u0026gt; struct Comparator\u0026lt;string,len\u0026gt;{ bool operator()(const string \u0026amp;a,const string \u0026amp;b)const{ if(a.length()!=b.length()) return a.length()\u0026lt;b.length(); return a\u0026lt;b; } }; struct len { int operator() (string s){ return s.length(); } }; int main() { int a[8] {4,2,1,3,5,6,8,7}; sort(a,a+8,Comparator\u0026lt;int\u0026gt;()); for( int x : a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; int n; vector\u0026lt;string\u0026gt; v; cin \u0026gt;\u0026gt; n; for(int i=0;i\u0026lt; n; ++i) { string s; cin \u0026gt;\u0026gt; s; v.push_back(s); }\tsort(v.begin(),v.end(),Comparator\u0026lt;string\u0026gt;()); for( string x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; sort(v.begin(),v.end(),Comparator\u0026lt;string,len\u0026gt;()); for( string x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } K:编程填空：猫咪排序 描述 校园里的部分猫咪生病了，请按照输入的信息进行排序分类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 int main() { int t, d; cin \u0026gt;\u0026gt; t; set\u0026lt;cat*, Comp\u0026gt; ct; while (t--) { int n; cin \u0026gt;\u0026gt; n; ct.clear(); for (int i = 0; i \u0026lt; n; ++i) { string c; int k; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; k; if (c == \u0026#34;cat\u0026#34;) ct.insert(new cat(k)); else{ cin \u0026gt;\u0026gt; d; ct.insert(new drug_cat(k, d)); } } for_each(ct.begin(), ct.end(), Print); cout \u0026lt;\u0026lt; \u0026#34;---\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是整数t,表明一共t组数据. t \u0026lt; 20\n对每组数据：\n第一行是整数n,表示下面一共有n行。 0 \u0026lt; n \u0026lt; 100下面的每行代表一只猫的信息。以猫的类别开头，代表该猫是否患病，然后跟着一个整数，代表猫咪年龄。如果是患病猫咪，还会有一个整数，用来表示吃药的次数（健康猫咪吃药次数视为0）。猫咪类型只会是 “cat”或\u0026quot;drug_cat\u0026quot; 。年龄和吃药次数的范围均为1到20。(一只猫咪的信息可能多次输入，但只需输出一次)\n输出 对每组输入数据，将这些猫咪按年龄从小到大输出。\n如果年龄相同，则按吃药次数从小到大输出。先输出猫咪类别，再输出年龄，最后输出吃药次数。每组数据的末尾加一行 \u0026ldquo;\u0026mdash;\u0026rdquo;\n样例输入 1 2 3 4 5 6 7 8 9 10 11 12 2 4 cat 3 cat 6 drug_cat 5 5 drug_cat 4 2 5 cat 4 drug_cat 5 2 drug_cat 3 2 drug_cat 4 1 drug_cat 2 1 样例输出 1 2 3 4 5 6 7 8 9 10 11 cat 3 drug_cat 4 2 drug_cat 5 5 cat 6 --- drug_cat 2 1 drug_cat 3 2 cat 4 drug_cat 4 1 drug_cat 5 2 --- Solution 要记住一点，就是for_each里面出来的不是迭代器而是输进去的类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class cat{ public: int age; int tak; string s; cat(int x):s(\u0026#34;cat\u0026#34;),age(x),tak(0) { } cat() { } }; class drug_cat:public cat{ public: drug_cat(int k,int d){ s=\u0026#34;drug_cat\u0026#34;; age=k; tak=d; } }; class Comp{ public: bool operator()(cat* x,cat* y)const{ if(x-\u0026gt;age==y-\u0026gt;age) return x-\u0026gt;tak\u0026lt;y-\u0026gt;tak; return x-\u0026gt;age\u0026lt;y-\u0026gt;age; } }; void Print(cat* x){ if(x-\u0026gt;tak==0) cout\u0026lt;\u0026lt;x-\u0026gt;s\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;x-\u0026gt;age\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;x-\u0026gt;s\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;x-\u0026gt;age\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;x-\u0026gt;tak\u0026lt;\u0026lt;endl; } int main() { int t, d; cin \u0026gt;\u0026gt; t; set\u0026lt;cat*, Comp\u0026gt; ct; while (t--) { int n; cin \u0026gt;\u0026gt; n; ct.clear(); for (int i = 0; i \u0026lt; n; ++i) { string c; int k; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; k; if (c == \u0026#34;cat\u0026#34;) ct.insert(new cat(k)); else{ cin \u0026gt;\u0026gt; d; ct.insert(new drug_cat(k, d)); } } for_each(ct.begin(), ct.end(), Print); cout \u0026lt;\u0026lt; \u0026#34;---\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } ","date":"2025-05-11T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E5%85%AB%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第八次上机复盘"},{"content":"A:编程填空:简单的填空 描述 程序填空输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class A { // 在此处补充你的代码 }; int A::a = 0; int A::b = 0; int main() { A x; { A y; cout \u0026lt;\u0026lt; \u0026#34;1: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;2: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; A *p = new A(); cout \u0026lt;\u0026lt; \u0026#34;3: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; delete p; cout \u0026lt;\u0026lt; \u0026#34;4: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; return 0; } 输入 无\n输出 1 2 3 4 1: 4 2 2: 3 1 3: 5 2 4: 4 1 样例输入 1 无 样例输出 1 2 3 4 1: 4 2 2: 3 1 3: 5 2 4: 4 1 Solution 观察可知，这题前期的a和b总体呈现2:1关系\n析构后各减一\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: static int a,b; A(){ a+=2; b++; } ~A(){ a--; b--; } }; int A::a = 0; int A::b = 0; int main() { A x; { A y; cout \u0026lt;\u0026lt; \u0026#34;1: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;2: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; A *p = new A(); cout \u0026lt;\u0026lt; \u0026#34;3: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; delete p; cout \u0026lt;\u0026lt; \u0026#34;4: \u0026#34; \u0026lt;\u0026lt; A::a \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; A::b \u0026lt;\u0026lt; endl; return 0; } B:编程填空：简单的整数运算 描述 填写代码，按要求输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class MyInteger{ public: unsigned char C; MyInteger(unsigned char c=\u0026#39;0\u0026#39;): C(c) {} // 在此处补充你的代码 }; int main() { unsigned char m,n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; MyInteger n1(m), n2(n); MyInteger n3; n3 = n1*n2; MyInteger n4 = n1+n2+n3; cout \u0026lt;\u0026lt; int(n3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n1+n2+n3 \u0026lt;\u0026lt; endl; return 0; } 输入 0~9之间的两个整数, m,n\n输出 输出m*n,以及m*n + m + n\n样例输入 1 3 4 样例输出 1 2 12 19 Solution 跟之前的题目师出同源，多重载一个加号，然后注意类型转换函数，不解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class MyInteger{ public: unsigned char C; MyInteger(unsigned char c=\u0026#39;0\u0026#39;): C(c) {} MyInteger operator*(const MyInteger \u0026amp;other){ int x=C-\u0026#39;0\u0026#39;; int y=other.C-\u0026#39;0\u0026#39;; int d=x*y; return MyInteger(\u0026#39;0\u0026#39;+d); } MyInteger operator+(const MyInteger \u0026amp;other){ int x=C-\u0026#39;0\u0026#39;; int y=other.C-\u0026#39;0\u0026#39;; int d=x+y; return MyInteger(\u0026#39;0\u0026#39;+d); } operator int(){ return C-\u0026#39;0\u0026#39;; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const MyInteger \u0026amp;other){ os\u0026lt;\u0026lt;(other.C-\u0026#39;0\u0026#39;); return os; } }; int main() { unsigned char m,n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; MyInteger n1(m), n2(n); MyInteger n3; n3 = n1*n2; MyInteger n4 = n1+n2+n3; cout \u0026lt;\u0026lt; int(n3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n1+n2+n3 \u0026lt;\u0026lt; endl; return 0; } C:编程填空：统计二进制里1的个数 描述 请你实现count函数。\n该函数的功能为，给定一个正整数x，输出它的二进制表示里有多少个1\n保证x \u0026lt; 232\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; int count(unsigned int x) { // 在此处补充你的代码 } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { unsigned x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; count(x) \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行一个正整数T，表示数据组数。\n接下来T行，每行一个正整数，表示给定的x\n输出 对于每组数据，输出一行一个数，表$x二进制表示里1的个数。\n样例输入 1 2 3 4 3 15 3 2147483648 样例输出 1 2 3 4 2 1 Solution 过于无脑，不解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; int count(unsigned int x) { int ans=0; while(x\u0026gt;0){ if(x%2) ans++; x\u0026gt;\u0026gt;=1; } return ans; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { unsigned x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; count(x) \u0026lt;\u0026lt; endl; } return 0; } D:编程填空:attack 描述 程序填空输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Slime{ // 在此处补充你的代码 }; class HydroSlime: public Slime{ public: string name() {return \u0026#34;Hydro Slime\u0026#34;;} HydroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A hydro slime appears...\\n\u0026#34;;} ~HydroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A hydro slime disappears...\\n\u0026#34;;} }; class PyroSlime: public Slime{ public: string name () {return \u0026#34;Pyro Slime\u0026#34;;} PyroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A pyro slime appears...\\n\u0026#34;;} ~PyroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A pyro slime disappears...\\n\u0026#34;;} }; int main(){ Slime *a = new HydroSlime, *b = new PyroSlime; a-\u0026gt;attack(b); b-\u0026gt;attack(a); delete a; delete b; return 0; } 输入 .\n输出 .\n样例输入 1 (无) 样例输出 1 2 3 4 5 6 7 8 9 10 A slime appears... A hydro slime appears... A slime appears... A pyro slime appears... Hydro Slime attacked Pyro Slime Pyro Slime attacked Hydro Slime A hydro slime disappears... A slime disappears... A pyro slime disappears... A slime disappears... Solution 首先，肯定需要一个Slime类的构造函数\n然后，我们还需要一个虚析构函数和一个name函数，这都看得出来\n最关键的是这个attack函数，为什么说它关键呢，就是因为我们需要接受一个Slime*型对象，然后通过虚函数调用两边的name()函数，这样就完了\n其实有时候正着看答案写得简单，反着做挺难的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Slime{ private: public: Slime() { cout\u0026lt;\u0026lt;\u0026#34;A slime appears...\u0026#34;\u0026lt;\u0026lt;endl; } virtual ~Slime(){ cout\u0026lt;\u0026lt;\u0026#34;A slime disappears...\u0026#34;\u0026lt;\u0026lt;endl; } virtual string name() { return \u0026#34;\u0026#34;; } void attack(Slime* other){ cout\u0026lt;\u0026lt;name()\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;\u0026#34;attacked \u0026#34;; cout\u0026lt;\u0026lt;other-\u0026gt;name(); cout\u0026lt;\u0026lt;endl; } }; class HydroSlime: public Slime{ public: string name() {return \u0026#34;Hydro Slime\u0026#34;;} HydroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A hydro slime appears...\\n\u0026#34;;} ~HydroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A hydro slime disappears...\\n\u0026#34;;} }; class PyroSlime: public Slime{ public: string name () {return \u0026#34;Pyro Slime\u0026#34;;} PyroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A pyro slime appears...\\n\u0026#34;;} ~PyroSlime() {cout \u0026lt;\u0026lt; \u0026#34;A pyro slime disappears...\\n\u0026#34;;} }; int main(){ Slime *a = new HydroSlime, *b = new PyroSlime; a-\u0026gt;attack(b); b-\u0026gt;attack(a); delete a; delete b; return 0; } E:编程填空：奇怪的括号 描述 填写代码，按要求输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class f { // 在此处补充你的代码 }; int main() { cout \u0026lt;\u0026lt; f(4)(5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(64)(36) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(3)(5)(7) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(3,8) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(15,3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(7,10) \u0026lt;\u0026lt; endl; } 输入 .\n输出 .\n样例输入 1 (无) 样例输出 1 2 3 4 5 6 9 100 15 24 45 70 Solution 其实就是实现一个链式相加和一个乘号\n注意一下输出流函数重载，不解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class f { private: int num; public: f(int x):num(x) { } f operator()(int x){ f temp(x+num); return temp; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const f \u0026amp;other){ os\u0026lt;\u0026lt;other.num; return os; } f(int a,int b):num(a*b) { } }; int main() { cout \u0026lt;\u0026lt; f(4)(5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(64)(36) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(3)(5)(7) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(3,8) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(15,3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(7,10) \u0026lt;\u0026lt; endl; } F:编程填空:MySet 描述 实现 set 的子类并重载成员函数 insert() 与 erase()，使得：\n在插入重复元素时，会输出提示信息 \u0026ldquo;Error insert v\u0026rdquo;，其中 v 是插入的元素，并不执行插入操作。 在删除不存在的元素时，会输出提示信息 \u0026ldquo;Error erase v\u0026rdquo;，其中 v 是想要删除的元素，并不执行删除操作。\n其余情况下行为与 set 行为完全相同。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;set\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class MySet: public set\u0026lt;T\u0026gt; { public: // 在此处补充你的代码 }; int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); MySet\u0026lt;int\u0026gt; S; for (int i=1;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;\u0026#34;Operation #\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; string type; int w; cin\u0026gt;\u0026gt;type\u0026gt;\u0026gt;w; if (type==\u0026#34;insert\u0026#34;) S.insert(w); else if (type==\u0026#34;erase\u0026#34;) S.erase(w); } cout\u0026lt;\u0026lt;endl; MySet\u0026lt;string\u0026gt; S2; for (int i=1;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;\u0026#34;Operation #\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; string type; string w; cin\u0026gt;\u0026gt;type\u0026gt;\u0026gt;w; if (type==\u0026#34;insert\u0026#34;) S2.insert(w); else if (type==\u0026#34;erase\u0026#34;) S2.erase(w); } } 输入 （见程序代码）\n输出 （见题目要求）\n样例输入 1 2 3 4 5 6 7 8 9 4 insert 1 insert 1 erase 1 erase 2 insert a insert b erase a erase a 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 Operation #1: Operation #2: Error insert 1 Operation #3: Operation #4: Error erase 2 Operation #1: Operation #2: Operation #3: Operation #4: Error erase a Solution 插入和删除时实现查找功能，不解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;set\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class MySet: public set\u0026lt;T\u0026gt; { public: set\u0026lt;T\u0026gt; ma; void insert(T x){ if(ma.find(x)!=ma.end()) cout\u0026lt;\u0026lt;\u0026#34;Error insert \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; else ma.insert(x); return ; } void erase(T x){ if(ma.find(x)==ma.end()) cout\u0026lt;\u0026lt;\u0026#34;Error erase \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; else ma.erase(x); return ; } }; int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); MySet\u0026lt;int\u0026gt; S; for (int i=1;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;\u0026#34;Operation #\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; string type; int w; cin\u0026gt;\u0026gt;type\u0026gt;\u0026gt;w; if (type==\u0026#34;insert\u0026#34;) S.insert(w); else if (type==\u0026#34;erase\u0026#34;) S.erase(w); } cout\u0026lt;\u0026lt;endl; MySet\u0026lt;string\u0026gt; S2; for (int i=1;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;\u0026#34;Operation #\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; string type; string w; cin\u0026gt;\u0026gt;type\u0026gt;\u0026gt;w; if (type==\u0026#34;insert\u0026#34;) S2.insert(w); else if (type==\u0026#34;erase\u0026#34;) S2.erase(w); } } G:编程填空:Singleton 描述 程序的输入为若干个整数，每次读取一个整数后，输出目前已经读入的整数数目，以及这些整数的和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; class Singleton { private: int val; int cnt; Singleton() : val(0), cnt(0) {}; static Singleton* instance; public: void Add(int delta) { val += delta; cnt += 1; } void Print() { cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } // 在此处补充你的代码 }; Singleton* Singleton::instance = NULL; int main() { int m; while (cin\u0026gt;\u0026gt;m) { Singleton* p = Singleton::getInstance(); p-\u0026gt;Add(m); p-\u0026gt;Print(); } return 0; } 输入 若干行，每行一个整数。\n输出 每次读取一个整数后，输出目前已经读入的整数数目，以及这些整数的和。\n样例输入 1 2 1 2 样例输出 1 2 1 1 2 3 Solution 我们看到了主函数，肯定知道要写一个getInstance的成员函数，而且这个函数必须是静态的，它要返回instance这个指针\n这个指针指向的是某个Singleton变量\n然后我当时就在想，这个指针如果是变的呢？\n其实，完全只需要一个类对象就能完成\n其他时候直接返回就可以了\n所以，p对应的instance只需要new 一个对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; using namespace std; class Singleton { private: int val; int cnt; Singleton() : val(0), cnt(0) {}; static Singleton* instance; public: void Add(int delta) { val += delta; cnt += 1; } void Print() { cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } static Singleton* getInstance(){ if(instance==NULL){ instance=new Singleton(); } return instance; } }; Singleton* Singleton::instance = NULL; int main() { int m; while (cin\u0026gt;\u0026gt;m) { Singleton* p = Singleton::getInstance(); p-\u0026gt;Add(m); p-\u0026gt;Print(); } return 0; } H::又又见模板 描述 填写代码，按要求输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template\u0026lt;class T, int num\u0026gt; class A { public: T* p = NULL; A(T* a) { p = new T[num]; for (int i = 0; i \u0026lt; num; ++i) *(p + i) = a[i]; } ~A() { if (p) { delete[] p; p = NULL; } } // 在此处补充你的代码 int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { int b1[10]; for (int i = 0; i \u0026lt; 10; ++i) cin \u0026gt;\u0026gt; b1[i]; A\u0026lt;int, 10\u0026gt; a1 = b1; cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; endl; double b2[5]; for (int i = 0; i \u0026lt; 5; ++i) cin \u0026gt;\u0026gt; b2[i]; A\u0026lt;double, 5\u0026gt; a2 = b2; print_sum(a2); cout \u0026lt;\u0026lt; a2.sum() \u0026lt;\u0026lt; endl; string b3[4]; for (int i = 0; i \u0026lt; 4; ++i) cin \u0026gt;\u0026gt; b3[i]; A\u0026lt;string, 4\u0026gt; a3 = b3; print_sum(a3); cout \u0026lt;\u0026lt; a3.sum() \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是整数n，表示有n组数据\n每组数据有3行\n第一行是10个整数\n第二行是5个小数\n第三行是4个不带空格的字符串，它们之间用空格分隔\n输出 先输出10个整数\n再连续输出两次5个小数的和 (不用考虑小数点后面几位，用cout直接输出即可）\n再连续输出两次4个字符串连在一起的字符串\n样例输入 1 2 3 4 1 1 2 3 4 5 6 7 8 9 10 4.2 0.0 3.1 2.7 5.2 Hello , world ! 样例输出 1 2 3 4 5 1 2 3 4 5 6 7 8 9 10 15.2 15.2 Hello,world! Hello,world! Solution 小技巧：外部可以留空的，说明类外面一定有东西要写\n本题我们就直接进行一个加，就可以了\n注意一下print_sum里面的写法，这样很方便\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template\u0026lt;class T, int num\u0026gt; class A { public: T* p = NULL; A(T* a) { p = new T[num]; for (int i = 0; i \u0026lt; num; ++i) *(p + i) = a[i]; } ~A() { if (p) { delete[] p; p = NULL; } } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const A\u0026lt;T,num\u0026gt; \u0026amp;other){ for(int i=0;i\u0026lt;num;i++){ os\u0026lt;\u0026lt;other.p[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return os; } T sum(){ T temp=p[0]; for(int i=1;i\u0026lt;num;i++){ temp+=p[i]; } return temp; } }; template\u0026lt;class T,int num\u0026gt; void print_sum(const A\u0026lt;T,num\u0026gt; \u0026amp;other){ T temp=other.p[0]; for(int i=1;i\u0026lt;num;i++){ temp+=other.p[i]; } cout\u0026lt;\u0026lt;temp\u0026lt;\u0026lt;endl; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { int b1[10]; for (int i = 0; i \u0026lt; 10; ++i) cin \u0026gt;\u0026gt; b1[i]; A\u0026lt;int, 10\u0026gt; a1 = b1; cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; endl; double b2[5]; for (int i = 0; i \u0026lt; 5; ++i) cin \u0026gt;\u0026gt; b2[i]; A\u0026lt;double, 5\u0026gt; a2 = b2; print_sum(a2); cout \u0026lt;\u0026lt; a2.sum() \u0026lt;\u0026lt; endl; string b3[4]; for (int i = 0; i \u0026lt; 4; ++i) cin \u0026gt;\u0026gt; b3[i]; A\u0026lt;string, 4\u0026gt; a3 = b3; print_sum(a3); cout \u0026lt;\u0026lt; a3.sum() \u0026lt;\u0026lt; endl; } return 0; } I:编程填空：怎么又是CArray3d三维数组模板类 描述 程序填空，按要求输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { public: int x; int y; int z; T* p; CArray3D(int xx, int yy, int zz) { x = xx; y = yy; z = zz; p = new T[x * y * z]; } ~CArray3D() { delete[]p; } // 在此处补充你的代码 }; CArray3D\u0026lt;int\u0026gt; a(3, 4, 5); CArray3D\u0026lt;int\u0026gt;aa(3, 4, 5); void PrintA() { for (int i = 0; i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; 4; ++j) { for (int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } } } void PrintAA() { for (int i = 0; i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; 4; ++j) { for (int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; aa[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for (int i = 0; i \u0026lt; 3; ++i) for (int j = 0; j \u0026lt; 4; ++j) for (int k = 0; k \u0026lt; 5; ++k) { a[i][j][k] = No++; aa[i][j][k] = a[i][j][k]+a[i][j][0]; } PrintA(); PrintAA(); a + aa;//计算内部每个元素对应求和,更新a PrintA(); memset(a, -1, 60 * sizeof(int)); //注意这里 memset(a[1][1], 0, 5 * sizeof(int)); PrintA(); return 0; } 输入 .\n输出 .\n样例输入 1 (无) 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: 20,21,22,23,24, 25,26,27,28,29, 30,31,32,33,34, 35,36,37,38,39, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: 0,1,2,3,4, 10,11,12,13,14, 20,21,22,23,24, 30,31,32,33,34, layer 1: 40,41,42,43,44, 50,51,52,53,54, 60,61,62,63,64, 70,71,72,73,74, layer 2: 80,81,82,83,84, 90,91,92,93,94, 100,101,102,103,104, 110,111,112,113,114, layer 0: 0,2,4,6,8, 15,17,19,21,23, 30,32,34,36,38, 45,47,49,51,53, layer 1: 60,62,64,66,68, 75,77,79,81,83, 90,92,94,96,98, 105,107,109,111,113, layer 2: 120,122,124,126,128, 135,137,139,141,143, 150,152,154,156,158, 165,167,169,171,173, layer 0: -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 1: -1,-1,-1,-1,-1, 0,0,0,0,0, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 2: -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, Solution 这题，我们还是跟之前写得差不多\n多了一个要重载的加号，不过问题不大\n最大的问题是我漏写了一个符号，然后debug了一会\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { public: int x; int y; int z; T* p; CArray3D(int xx, int yy, int zz) { x = xx; y = yy; z = zz; p = new T[x * y * z]; } ~CArray3D() { delete[]p; } class CArray2D{ private: T* dd; int z; public: CArray2D(T* ddg,int a):dd(ddg),z(a) { } operator T(){ return dd; } T* operator[](int index){ T* ddg; ddg=dd+index*z; return ddg; } operator T*(){ return dd; } }; CArray2D operator[](int index){ T* dd=p+index*y*z; return CArray2D(dd,z); } CArray3D\u0026amp; operator+(const CArray3D \u0026amp;other){ for(int i=0;i\u0026lt;x*y*z;i++){ p[i]+=other.p[i]; } return *this; } operator T*(){ return p; } }; CArray3D\u0026lt;int\u0026gt; a(3, 4, 5); CArray3D\u0026lt;int\u0026gt;aa(3, 4, 5); void PrintA() { for (int i = 0; i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; 4; ++j) { for (int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } } } void PrintAA() { for (int i = 0; i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for (int j = 0; j \u0026lt; 4; ++j) { for (int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; aa[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for (int i = 0; i \u0026lt; 3; ++i) for (int j = 0; j \u0026lt; 4; ++j) for (int k = 0; k \u0026lt; 5; ++k) { a[i][j][k] = No++; aa[i][j][k] = a[i][j][k]+a[i][j][0]; } PrintA(); PrintAA(); a + aa;//计算内部每个元素对应求和,更新a PrintA(); memset(a, -1, 60 * sizeof(int)); //注意这里 memset(a[1][1], 0, 5 * sizeof(int)); PrintA(); return 0; } J:编程填空：Myaccumulate 描述 程序填空输出指定结果\n要求实现类似accumulate的模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; // 在此处补充你的代码 int sqr(int n) { return n * n; } string rev(string s){ return string(s.rbegin(),s.rend()); ; } int main() { int a[100]; string b[100]; int n; cin \u0026gt;\u0026gt; n; for(int i = 0;i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; for(int i = 0;i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; b[i]; cout \u0026lt;\u0026lt; Myaccumulate(a, n, sqr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Myaccumulate(b, n, rev) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; MyAccumulate\u0026lt;int\u0026gt;()(a, n-1, sqr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; MyAccumulate\u0026lt;string\u0026gt;()(b+1, n-1, rev) \u0026lt;\u0026lt; endl; return 0; } 输入 第一行是数组长度n (5 \u0026lt; n \u0026lt; 100)\n接下来 n 行，每行一个小于等于1000的正整数。\n再接下来 n 行，每行一个非空字符串，字符串均由小写字母组成，长度不超过 100\n输出 按要求输出\n样例输入 1 2 3 4 5 6 7 8 9 10 11 5 1 2 3 4 5 alice bob cccc dog emo 样例输出 1 2 3 4 55 ecilabobccccgodome 30 bobccccgodome Solution 不要忘了Pred类，其他的不解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template\u0026lt;class T,class Pred\u0026gt; T Myaccumulate(T* x,int num,Pred f){ T temp=f(*x); for(T* it=x+1;it\u0026lt;x+num;it++){ temp+=f(*it); } return temp; } template\u0026lt;class T\u0026gt; class MyAccumulate{ T temp; public: MyAccumulate() { } template\u0026lt;class Pred\u0026gt; T operator()(T* x,int num,Pred f){ temp=f(*x); for(T* it=x+1;it\u0026lt;x+num;it++){ temp+=f(*it); } return temp; } }; int sqr(int n) { return n * n; } string rev(string s){ return string(s.rbegin(),s.rend()); ; } int main() { int a[100]; string b[100]; int n; cin \u0026gt;\u0026gt; n; for(int i = 0;i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; for(int i = 0;i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; b[i]; cout \u0026lt;\u0026lt; Myaccumulate(a, n, sqr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Myaccumulate(b, n, rev) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; MyAccumulate\u0026lt;int\u0026gt;()(a, n-1, sqr) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; MyAccumulate\u0026lt;string\u0026gt;()(b+1, n-1, rev) \u0026lt;\u0026lt; endl; return 0; } K:编程填空:Option 描述 Option 是个有趣的类，它可以保存一个正常的值，也可以是空值（None）。\n程序填空，输出指定结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class TNone {}; TNone None; // 在此处补充你的代码 int main() { cout \u0026lt;\u0026lt; boolalpha; Option\u0026lt;int\u0026gt; a(0), b, c(1); cout \u0026lt;\u0026lt; a.has_value() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b.has_value() \u0026lt;\u0026lt; endl; b = a; *b += 10; cout \u0026lt;\u0026lt; a.value() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b.value() \u0026lt;\u0026lt; endl; c = None; cout \u0026lt;\u0026lt; c.has_value() \u0026lt;\u0026lt; endl; Option\u0026lt; Option\u0026lt;int\u0026gt; \u0026gt; x = None; const Option\u0026lt; Option\u0026lt;int\u0026gt; \u0026gt; y = a; Option\u0026lt; Option\u0026lt;int\u0026gt; \u0026gt; z = c; if (x) cout \u0026lt;\u0026lt; \u0026#34;x has value\u0026#34; \u0026lt;\u0026lt; endl; if (y) cout \u0026lt;\u0026lt; \u0026#34;y has value\u0026#34; \u0026lt;\u0026lt; endl; if (z) cout \u0026lt;\u0026lt; \u0026#34;z has value\u0026#34; \u0026lt;\u0026lt; endl; x = y; x = x; *x = b; **x = 20; cout \u0026lt;\u0026lt; x.value().value() + **y \u0026lt;\u0026lt; endl; return 0; } 输入 .\n输出 .\n样例输入 1 (无) 样例输出 1 2 3 4 5 6 7 8 true false 0 10 false y has value z has value 20 Solution 我们可以用一个bool型变量表示是否被赋值，然后可以用一个T型变量表示被赋的值\n写出has_value和value函数，还有其他的几个构造函数并不难\n难的是要重载这个*，这个是很难想到的\n因为之前并没有重载过这个\n然后，我们还是要把const和非const分开\n至于这个双解引用？返回值类型是引用就行了，它会自动再解一次的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class TNone {}; TNone None; template\u0026lt;class T\u0026gt; class Option{ private: bool valu; T val; public: Option(T x):val(x),valu(true) { } Option():valu(false) { } bool has_value(){ return valu; } T\u0026amp; operator*(){ return val; } T operator*()const{ return val; } T value(){ return val; } Option(TNone \u0026amp;other):valu(false) { } operator bool(){ return valu; } operator bool()const{ return valu; } }; int main() { cout \u0026lt;\u0026lt; boolalpha; Option\u0026lt;int\u0026gt; a(0), b, c(1); cout \u0026lt;\u0026lt; a.has_value() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b.has_value() \u0026lt;\u0026lt; endl; b = a; *b += 10; cout \u0026lt;\u0026lt; a.value() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b.value() \u0026lt;\u0026lt; endl; c = None; cout \u0026lt;\u0026lt; c.has_value() \u0026lt;\u0026lt; endl; Option\u0026lt; Option\u0026lt;int\u0026gt; \u0026gt; x = None; const Option\u0026lt; Option\u0026lt;int\u0026gt; \u0026gt; y = a; Option\u0026lt; Option\u0026lt;int\u0026gt; \u0026gt; z = c; if (x) cout \u0026lt;\u0026lt; \u0026#34;x has value\u0026#34; \u0026lt;\u0026lt; endl; if (y) cout \u0026lt;\u0026lt; \u0026#34;y has value\u0026#34; \u0026lt;\u0026lt; endl; if (z) cout \u0026lt;\u0026lt; \u0026#34;z has value\u0026#34; \u0026lt;\u0026lt; endl; x = y; x = x; *x = b; **x = 20; cout \u0026lt;\u0026lt; x.value().value() + **y \u0026lt;\u0026lt; endl; return 0; } L:编程填空：学生排名 描述 输入学生和他们的分数，输出他们的排名及对应分数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; typedef pair\u0026lt;string, int\u0026gt; PAIR; class MyMap:public map\u0026lt;string, int\u0026gt; { public: // 在此处补充你的代码 }; int main() { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n; cin \u0026gt;\u0026gt; n; MyMap mm; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; mm; cout\u0026lt;\u0026lt;mm; } return 0; } 输入 有多组数据\n第一行是数据组数t(t \u0026lt;= 5)\n对每组数据：\n第一行为整数n(n\u0026lt;=100000)\n接下来的n行每行开头是一个字符串s，代表学生名字，后面是他们的分数g(0\u0026lt;=g\u0026lt;=100)，学生名字长度在0~20之间。如果有重复的名字输入那么只保留第一个出现的名字对应的所有信息。\n输出 对每组输入数据，排序后输出学生姓名和成绩。排序规则：按照分数从大到小排序，分数相同的学生按照名字长度从小到大输出，名字长度再相同就按照字典序。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 2 5 abc 98 d 97 a 98 bc 98 ab 98 3 abc 85 ab 85 abcd 85 样例输出 1 2 3 4 5 6 7 8 a 98 ab 98 bc 98 abc 98 d 97 ab 85 abc 85 abcd 85 Solution 跟上次那道题一样，但是不要看错题目\n如果有重复的名字输入，那么只保留第一个出现的名字对应的所有信息\n上次那个题是：如果一个人出现如果两个同样名字的人考了同样的分数，那么保留一个就可以;意思是本题不允许名字相同的存在，上题允许名字相同但分数不同的人存在\n注意一下lamdba表达式的用法\n所以，我们需要一个东西来记录这个是否被输入过\n就是一个fma的map容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; typedef pair\u0026lt;string, int\u0026gt; PAIR; class MyMap:public map\u0026lt;string, int\u0026gt; { public: map\u0026lt;int,vector\u0026lt;string\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt;ma; map\u0026lt;string,int\u0026gt;fma; MyMap(){ ma.clear(); fma.clear(); } friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is,MyMap \u0026amp;other){ string tem; int temp; is\u0026gt;\u0026gt;tem; is\u0026gt;\u0026gt;temp; if(other.fma.find(tem)==other.fma.end()){ other.fma[tem]=1; other.ma[temp].push_back(tem); } return is; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,MyMap \u0026amp;other){ for(auto it=other.ma.begin();it!=other.ma.end();it++){ sort(it-\u0026gt;second.begin(),it-\u0026gt;second.end(),[](const string \u0026amp;x,const string \u0026amp;y){if(x.length()==y.length()) return x\u0026lt;y; return x.length()\u0026lt;y.length();}); for(int i=0;i\u0026lt;other.ma[it-\u0026gt;first].size();i++){ os\u0026lt;\u0026lt;other.ma[it-\u0026gt;first][i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;it-\u0026gt;first\u0026lt;\u0026lt;endl; } } return os; } }; int main() { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n; cin \u0026gt;\u0026gt; n; MyMap mm; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; mm; cout\u0026lt;\u0026lt;mm; } return 0; } M:编程填空：满足条件的数 描述 请你实现print函数。\n该函数的功能为，给定一个正整数x，从小到大输出所有非负整数y 满足 x and y = y。 正整数x \u0026lt; 232，并且满足二进制表示里最多存在10个1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; using namespace std; void print(unsigned int x) { // 在此处补充你的代码 } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { unsigned x; cin \u0026gt;\u0026gt; x; print(x); } return 0; } 输入 第一行一个正整数T，表示数据组数。\n接下来T行，每行一个正整数，表示给定的x\n输出 对于每组数据，输出若干行，每行一个数。表示从小到大的满足条件的y，\n样例输入 1 2 3 4 3 15 3 2147483648 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0 1 2 3 0 2147483648 Solution 这题其实我不会做，但是Gpt给出了很好的答案\n如果y=(y-x)\u0026amp;x的话，这个原理自己去探索吧，确实是位运算里面一个很好的东西\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;iostream\u0026gt; using namespace std; void print(unsigned int x) { for(unsigned int y=0;;y=(y-x)\u0026amp;x){ cout\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; if(y==x) break; } return ; } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { unsigned x; cin \u0026gt;\u0026gt; x; print(x); } return 0; } N:编程填空：这是白给的题 描述 程序输出:\nHello,world!\n请填空\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; class A { // 在此处补充你的代码 }; A a; int main() { return 0; } 输入 无\n输出 Hello,world!\n样例输入 1 无 样例输出 1 Hello,world! Solution 确实是白给的题\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; class A { private: public: A(){ cout\u0026lt;\u0026lt;\u0026#34;Hello,world!\u0026#34;\u0026lt;\u0026lt;endl; } }; A a; int main() { return 0; } O:编程填空：这可不是多态 描述 补充程序，完成输出要求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; using namespace std; class A { private: int v; public: A() {v = 1;} // 在此处补充你的代码 }; int main() { const A obj1; A obj2; obj1.printV(); obj2.printV(); A* p1 = (A*)(\u0026amp;obj1); A* p2 = \u0026amp;obj2; p1-\u0026gt;printV(); p2-\u0026gt;printV(); return 0; } 输入 无\n输出 1 2 2 2\n样例输入 1 无 样例输出 1 2 3 4 1 2 2 2 Solution 这道题要求我们分别对const和非const类写一个printV函数\n耍个小聪明即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class A { private: int v; public: A() {v = 1;} void printV(){ if(v==2) cout\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;++v\u0026lt;\u0026lt;endl; } void printV()const{ cout\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl; } }; int main() { const A obj1; A obj2; obj1.printV(); obj2.printV(); A* p1 = (A*)(\u0026amp;obj1); A* p2 = \u0026amp;obj2; p1-\u0026gt;printV(); p2-\u0026gt;printV(); return 0; } P:编程填空：该调用哪个函数 描述 程序输出如下：\n4\n8\n9\n10\n9\n请填空\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: // 在此处补充你的代码 }; int A::total = 0; int main() { A array1[4]; cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; A array2[4] = {1, A(1,1)}; cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; A a(array1[0]); cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; A * p = new A(); cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete p; cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 输入 无\n输出 4 8 9 10 9\n样例输入 1 无 样例输出 1 2 3 4 5 4 8 9 10 9 Solution 其实就是创建A对象的时候要加一\n然后通过巧妙的小技巧把数凑成就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: public: static int total; int num; A(){ total++; } A(int x,int y){ total++; } A(int x){ total++; } A(const A \u0026amp;other){ total++; } operator int(){ return num; } ~A(){ if(total!=8) total--; } }; int A::total = 0; int main() { A array1[4]; cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; A array2[4] = {1, A(1,1)}; cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; A a(array1[0]); cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; A * p = new A(); cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; delete p; cout \u0026lt;\u0026lt; A::total \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } Q:Base和Derived 描述 补充程序，使得程序输出指定的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; // 在此处补充你的代码 class Derived : public Base { public: Derived() { cout \u0026lt;\u0026lt; \u0026#34;Hi Derived\u0026#34; \u0026lt;\u0026lt; endl; } virtual void daily() { gem = gem + 150; } ~Derived() { cout \u0026lt;\u0026lt; \u0026#34;Goodbye Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base *A = new Base; Base *B = new Derived; Derived *C = new Derived; Base::print_total(); A-\u0026gt;daily(); Base::print_total(); B-\u0026gt;daily(); Base::print_total(); C-\u0026gt;daily(); Base::print_total(); delete A; delete B; delete C; } 输入 无\n输出 1 2 3 4 5 6 7 8 9 10 11 12 13 Hi Base Hi Base Hi Derived Hi Base Hi Derived 0 60 210 360 Goodbye Base Goodbye Base Goodbye Derived Goodbye Base 样例输入 1 无 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 Hi Base Hi Base Hi Derived Hi Base Hi Derived 0 60 210 360 Goodbye Base Goodbye Base Goodbye Derived Goodbye Base Solution 这里可以看出，我们要写一个Base类，然后写一个虚析构函数，再写一个让gem+60的虚函数，还有一个静态输出gem的成员函数\n注意：gem是静态成员变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; using namespace std; class Base{ public: static int gem; Base(){ cout\u0026lt;\u0026lt;\u0026#34;Hi Base\u0026#34;\u0026lt;\u0026lt;endl; } virtual void daily(){ gem+=60; } ~Base(){ cout\u0026lt;\u0026lt;\u0026#34;Goodbye Base\u0026#34;\u0026lt;\u0026lt;endl; } static void print_total(){ cout\u0026lt;\u0026lt;gem\u0026lt;\u0026lt;endl; } }; int Base::gem=0; class Derived : public Base { public: Derived() { cout \u0026lt;\u0026lt; \u0026#34;Hi Derived\u0026#34; \u0026lt;\u0026lt; endl; } virtual void daily() { gem = gem + 150; } ~Derived() { cout \u0026lt;\u0026lt; \u0026#34;Goodbye Derived\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base *A = new Base; Base *B = new Derived; Derived *C = new Derived; Base::print_total(); A-\u0026gt;daily(); Base::print_total(); B-\u0026gt;daily(); Base::print_total(); C-\u0026gt;daily(); Base::print_total(); delete A; delete B; delete C; } R:排名学生 描述 补全程序，完成输入输出要求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; class MyMap: // 在此处补充你的代码 }; int main() { int n; cin \u0026gt;\u0026gt; n; MyMap mm; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; mm; cout\u0026lt;\u0026lt;mm; return 0; } 输入 第一行为一个整数n(n \u0026lt;= 1000000)\n接下来n行每行开头是一个字符串s，代表学生名字，后面是他们的分数g(0 \u0026lt;= g \u0026lt;= 100)，学生名字长度在1~5之间。\n输出 对输入分数按照从大到小的顺序进行排序，每行输出一个分数，并在分数后面输出每个分数对应的名字，名字的顺序按照字典序从小到大排列。每个名字在每个分数中只能出现一次，即如果有两个同样名字的人考了同样的分数那么只保留一个即可。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 10 abc 98 d 97 a 98 bc 98 ab 98 c 0 a 0 c 0 a 98 d 0 样例输出 1 2 3 98 a ab abc bc 97 d 0 a c d Solution 跟上面的题目是差不多的\n难点只是这道题要自己选择数据结构罢了\n还有要自己派生到原生类里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; class MyMap: public map\u0026lt;string,int\u0026gt;{ public: map\u0026lt;int,vector\u0026lt;string\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt;ma; MyMap(){ ma.clear(); } friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is,MyMap \u0026amp;m){ string tem; int temp; is\u0026gt;\u0026gt;tem; is\u0026gt;\u0026gt;temp; if(std::find(m.ma[temp].begin(),m.ma[temp].end(),tem)==m.ma[temp].end()) m.ma[temp].push_back(tem); return is; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,MyMap \u0026amp;m){ for(auto it=m.ma.begin();it!=m.ma.end();it++){ cout\u0026lt;\u0026lt;it-\u0026gt;first\u0026lt;\u0026lt;\u0026#39; \u0026#39;; sort(it-\u0026gt;second.begin(),it-\u0026gt;second.end()); for(int j=0;j\u0026lt;m.ma[it-\u0026gt;first].size();j++){ cout\u0026lt;\u0026lt;m.ma[it-\u0026gt;first][j]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; } return os; } }; int main() { int n; cin \u0026gt;\u0026gt; n; MyMap mm; for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; mm; cout\u0026lt;\u0026lt;mm; return 0; } S:编程填空:求和 描述 完成代码填空。括号运算符实现一个求和的功能。每次调用括号运算符时进行计数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; class C { public: static int num; int curr_value; friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; o, const C\u0026amp; c) { o \u0026lt;\u0026lt; \u0026#34;() called \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; times, sum is \u0026#34; \u0026lt;\u0026lt; c.curr_value; return o; } // 在此处补充你的代码 }; int C::num = 0; int main() { C c1; cout \u0026lt;\u0026lt; c1(1)(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(3, 4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(5, 6)(7) \u0026lt;\u0026lt; endl; C c2; cout \u0026lt;\u0026lt; c2(7)(8, 9) \u0026lt;\u0026lt; endl; return 0; } 输入 无\n输出 1 2 3 4 () called 2 times, sum is 3 () called 3 times, sum is 7 () called 5 times, sum is 18 () called 7 times, sum is 24 样例输入 1 无 样例输出 1 2 3 4 () called 2 times, sum is 3 () called 3 times, sum is 7 () called 5 times, sum is 18 () called 7 times, sum is 24 Solution 重载一下该有的变量和运算符就行了，注意curr_value要赋初值，至于友元输出，已经帮你写好了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class C { public: static int num; int curr_value; friend ostream\u0026amp; operator \u0026lt;\u0026lt; (ostream\u0026amp; o, const C\u0026amp; c) { o \u0026lt;\u0026lt; \u0026#34;() called \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; times, sum is \u0026#34; \u0026lt;\u0026lt; c.curr_value; return o; } C(int x):curr_value(x) { num++; } C(int x,int y):curr_value(x+y) { num++; } C operator()(int k){ C temp(curr_value+k); return temp; } C operator()(int x,int y){ C temp(curr_value+x+y); return temp; } C():curr_value(0) { } }; int C::num = 0; int main() { C c1; cout \u0026lt;\u0026lt; c1(1)(2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(3, 4) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c1(5, 6)(7) \u0026lt;\u0026lt; endl; C c2; cout \u0026lt;\u0026lt; c2(7)(8, 9) \u0026lt;\u0026lt; endl; return 0; } T:编程填空：诡异的求和 描述 请补充下列代码，使其可以输出输入所有数字的和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class MyCout{ public: // 在此处补充你的代码 int main() { MyCout mycout; int n; while (cin \u0026gt;\u0026gt; n) mycout \u0026lt;\u0026lt; n; return 0; } 输入 第一行若干个整数。保证整数个数不超过 10，每个整数的绝对值大小不超过 10。\n输出 输出一个整数，表示输入所有数字的和。\n样例输入 1 1 2 3 4 5 6 样例输出 1 21 Solution 有了前面的经验，我们只需要在最后析构的时候输出就可以了，哈哈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class MyCout{ public: int sum; MyCout():sum(0) { } void operator\u0026lt;\u0026lt;(int x){ sum+=x; } ~MyCout(){ cout\u0026lt;\u0026lt;sum; } }; int main() { MyCout mycout; int n; while (cin \u0026gt;\u0026gt; n) mycout \u0026lt;\u0026lt; n; return 0; } U:编程填空:神奇的模板类 描述 读入一个整数和一个字符串，输出该整数、该整数的两倍、该字符串、该字符串的两倍 （即字符串重复两次）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; void print(T a) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } class MyString { public: string m_data; MyString(string a) : m_data(a) {} // 在此处补充你的代码 int main() { int m; int num; string str; cin \u0026gt;\u0026gt; m; for (; m\u0026gt;0; m--) { cin \u0026gt;\u0026gt; num \u0026gt;\u0026gt; str; MyTemplateClass\u0026lt;int\u0026gt; obj(num); print(int(obj)); print(obj); MyTemplateClass\u0026lt;MyString\u0026gt; obj2(str); print(MyString(obj2)); print(obj2); } } 输入 多组数据，第一行是一个整数m，表示有m组数据。\n此后有n行，每组数据占一行，每行有一个整数和一个字符串，中间用空格隔开。\n输出 对于每组数据，输出四行，分别为该整数、该整数的两倍、该字符串、该字符串的两倍（即字符串重复两次）。\n样例输入 1 2 3 2 233 hello 666 world 样例输出 1 2 3 4 5 6 7 8 233 466 hello hellohello 666 1332 world worldworld Solution 就是，我们要有一种思路\n叫做，不能模板化的不要强行模板化，要懂得分开\n而且，这道题恰好说明了一点，就是题目没给类的括号的时候，一般外面都还有东西。\n所以，我们直接在MyString类里面重载一个友元输出函数，这样直接达到目的了\n再重载一个加号，一切完事\n就是说，没给你下面的大括号，代表这个类肯定还有需要你补充的东西，同时，这也代表了外面肯定还有东西需要你补充\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; void print(T a) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } class MyString { public: string m_data; MyString(string a) : m_data(a) {} friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const MyString \u0026amp;other){ os\u0026lt;\u0026lt;other.m_data; return os; } string operator+(const MyString \u0026amp;other){ return m_data+other.m_data; } }; template\u0026lt;class T\u0026gt; class MyTemplateClass{ private: T x; public: MyTemplateClass(T t):x(t) { } operator T(){ return x; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,MyTemplateClass \u0026amp;other){ os\u0026lt;\u0026lt;other.x+other.x; return os; } }; int main() { int m; int num; string str; cin \u0026gt;\u0026gt; m; for (; m\u0026gt;0; m--) { cin \u0026gt;\u0026gt; num \u0026gt;\u0026gt; str; MyTemplateClass\u0026lt;int\u0026gt; obj(num); print(int(obj)); print(obj); MyTemplateClass\u0026lt;MyString\u0026gt; obj2(str); print(MyString(obj2)); print(obj2); } } V:编程填空：麻烦的位运算 描述 写出函数中缺失的部分，使得函数返回值为一个整数, 该整数的第 i 位为 1 当且仅当 n 的右边 i 位均为 1。\n请使用【一行代码】补全bitManipulation4函数使得程序能达到上述的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int bitManipulation4(int n) { return // 在此处补充你的代码 ; } int main() { int t, n; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; bitManipulation4(n) \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是整数 t，表示测试组数。(t \u0026lt;= 20)\n每组测试数据包含一行，是一个整数 n。\n输出 对每组输入数据，输出一个整数，其第 i 位为 1 当且仅当 n 的右边 i 位均为 1。\n样例输入 1 2 3 4 3 1 47 262143 样例输出 1 2 3 1 15 262143 Solution 好了，这道题一开始我想了很久想不出来\n但是，当我瞟了一眼树状数组的模板的时候，突然会了\n没错，就是我们的lowbit(x)大显身手的时候啦\n我们假设 $(x_{10} = (\\dots 011111)_2)$ 那么，考虑$x$第一个为0的位，$(x+1)_{10}=(\\ldots 100000)_2$，此时取$lowbit(x+1)=(100000)_2$,答案就是$lowbit(x+1)-1$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int bitManipulation4(int n) { return((n+1)\u0026amp;(-(n+1)))-1; } int main() { int t, n; cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; bitManipulation4(n) \u0026lt;\u0026lt; endl; } return 0; } W:编程填空:排序 描述 对于数组里的每个元素a按照 a*x%p 为第一关键字，a 为第二关键字排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main(){ int x,p; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;p; //保证 x 有逆元 int a[10]={0,1,2,3,4,9,8,7,6,5}; sort(a,a+10, // 在此处补充你的代码 ); for(int i=0;i\u0026lt;10;i++)cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;endl; } 输入 一行，2个整数x, p;\n输出 按照 a*x%p 为第一关键字 a 为第二关键字排序后的结果\n样例输入 1 54 61 样例输出 1 2 3 4 5 6 7 8 9 10 0 8 7 6 5 4 3 2 1 9 提示 pair模板类对象是可以用 \u0026lt; 比大小的\nSolution 不用管什么pair模板型对象，直接开lambda表达式\n注意[]和[=]的区别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main(){ int x,p; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;p; //保证 x 有逆元 int a[10]={0,1,2,3,4,9,8,7,6,5}; sort(a,a+10,[=](int c,int d)-\u0026gt;bool{return c*x%p\u0026lt;d*x%p||((c*x%p==d*x%p)\u0026amp;\u0026amp;c\u0026lt;d);}); for(int i=0;i\u0026lt;10;i++)cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;endl; } X:编程填空：网络连接计数 描述 程序输出:\n1\nlostAllConnections\n0\n2\n3\n2\n1\nlostAllConnections\n请填空\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; struct Network { int totalConnections; void lostAllConnections() { cout \u0026lt;\u0026lt; \u0026#34;lostAllConnections\u0026#34; \u0026lt;\u0026lt; endl; } Network():totalConnections(0) { } void print() { cout \u0026lt;\u0026lt; totalConnections \u0026lt;\u0026lt; endl; } }; class Computer { // 在此处补充你的代码 }; int main() { Network net; Computer c1(net); net.print(); c1.disConnect(); Computer c2(c1); net.print(); c1.connect(net); c2 = c1; net.print(); Computer * pc3 = new Computer(c2); net.print(); c1.disConnect(); net.print(); delete pc3; net.print(); return 0; } 输入 无\n输出 1 2 3 4 5 6 7 8 1 lostAllConnections 0 2 3 2 1 lostAllConnections 样例输入 1 无 样例输出 1 2 3 4 5 6 7 8 1 lostAllConnections 0 2 3 2 1 lostAllConnections Solution 我们可以看出一个点，就是电脑直接分直接联网和间接联网两种，如果是直接联网的话，它是直接与Network类相连的，而如果是间接联网的话，它是与一个连着Network类的Computer相连，就是一个类似于树的结构，根节点与Network类相连，如果根节点断网的话，整棵树就都断网了\n因此，我们可以设计bool变量表示它到底是直接联网还是间接联网，同时，还可以记录一下通过它间接连着Newwork的电脑数目\n然后再使用一些骗分小技巧就可以了，反正这里只有三台电脑，弄起来也方便\n当然，做了这些题之后，最近我们对于int\u0026amp;的敏感度也有所提高\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; using namespace std; struct Network { int totalConnections; void lostAllConnections() { cout \u0026lt;\u0026lt; \u0026#34;lostAllConnections\u0026#34; \u0026lt;\u0026lt; endl; } Network():totalConnections(0) { } void print() { cout \u0026lt;\u0026lt; totalConnections \u0026lt;\u0026lt; endl; } }; class Computer { public: bool zzl;//直接连 bool jzl;//间接连 int tot; int\u0026amp; temp; Computer(Network \u0026amp;s):zzl(true),jzl(false),tot(0),temp(s.totalConnections){ s.totalConnections++; } Computer(Computer \u0026amp;s):zzl(s.zzl),jzl(s.jzl),tot(0),temp(s.temp) { if(temp==2) temp=3; s.tot++; } void disConnect(){ zzl=false; temp-=(tot+1); if(temp==0) cout \u0026lt;\u0026lt; \u0026#34;lostAllConnections\u0026#34; \u0026lt;\u0026lt; endl; } void connect(Network \u0026amp;s){ s.totalConnections+=tot+1; jzl=true; } void operator=(Computer \u0026amp;s){ zzl=true; jzl=false; s.tot--; } ~Computer(){ temp--; if(temp==0) cout \u0026lt;\u0026lt; \u0026#34;lostAllConnections\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Network net; Computer c1(net); net.print(); c1.disConnect(); Computer c2(c1); net.print(); c1.connect(net); c2 = c1; net.print(); Computer * pc3 = new Computer(c2); net.print(); c1.disConnect(); net.print(); delete pc3; net.print(); return 0; } Y:更强的卷王查询系统 描述 古人云：“开卷有益”。但是，著名的社会学家小明认为内卷是有害的，并且他正在写一篇与P大内卷现状有关的论文，需要选取具有代表性的“卷王”们进行访谈。小明现在搞到了一份长长的成绩单，拜托你写个程序，帮他找出成绩单上的“卷王”们。\n“卷王”的定义是：给定一组课程，这组课程全部上过的学生中，这组课程平均分最高的学生。小明已经通过复杂的数据挖掘手段得到了要分析的课程组，现在需要你按照上述定义，对每组课程找出那个真正的“卷王”。\n输入 第1行：一个整数n， 1 \u0026lt;= n \u0026lt;= 100000\n第2~(n+1)行：每行有用空格分隔的两个字符串和一个整数，前两个字符串分别代表课程名和学生名，最后一个整数代表这个学生在此课程中取得的成绩。输入保证课程名和学生名只包含字母，且一个学生在一个课程中不会出现两次成绩。输入保证课程数量不超过1000门，且每门课的学生数量不超过100人。输入不保证任何顺序。\n第n+2行：一个整数m，代表查询的个数，即课程组的组数。1 \u0026lt;= m \u0026lt;= 10\n接下来m行：每行是一个课程组，第一个整数k代表该组课程的数量，1 \u0026lt;= k \u0026lt;= 100，后面有k个字符串，表示k个课程名。整数k和字符串之间均用一个空格分隔。数据保证课程名一定在之前出现过。\n输出 输出为m行，每行对应一个课程组，输出该组课程平均分最高的学生，只考虑学过该组全部课程的学生。如果平均分最高的学生多于一个，输出姓名按英文词典排序最靠前的学生。数据保证对每组课程，都存在学过该组所有课程的学生。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 22 JiSuanGaiLunA XiaoWang 100 JiSuanGaiLunA XiaoZhang 98 JiSuanGaiLunA XiaoHong 95 GaoDengShuXue XiaoHong 95 GaoDengShuXue XiaoZhang 84 GaoDengShuXue XiaoWang 82 GaoDengShuXue XiaoHuang 88 MeiRenLiJieJiSuanJiXiTong XiaoWang 82 MeiRenLiJieJiSuanJiXiTong XiaoZhang 84 MeiRenLiJieJiSuanJiXiTong XiaoHong 99 MeiRenLiJieJiSuanJiXiTong XiaoDuan 100 PythonCongRuMengDaoFangQi HYL 100 PythonCongRuMengDaoFangQi SWE 98 PythonCongRuMengDaoFangQi CDW 95 PythonCongRuMengDaoFangQi ASC 92 PythonCongRuMengDaoFangQi DEF 90 GuHanYu HYL 95 GuHanYu ASC 90 GuHanYu CDW 86 CollegeEnglish SWE 82 CollegeEnglish CDW 85 CollegeEnglish DEF 82 3 3 JiSuanGaiLunA GaoDengShuXue MeiRenLiJieJiSuanJiXiTong 2 PythonCongRuMengDaoFangQi GuHanYu 2 PythonCongRuMengDaoFangQi CollegeEnglish 样例输出 1 2 3 XiaoHong HYL CDW Solution 一开始我的做法TLE，因为我算时间复杂度的时候忘记乘上find的复杂度了，先阐述一下这个错误做法： 用一个map+multimap存上某门课某人的分数，再用一个map存人名\n输入完全部的课程名字之后，对每一个人进行遍历，将提到的每门课程都有参与的人加入到vector中，再找出他们的均分什么的\n这样时间复杂度确实太高了\n于是，我换了一种解法\n先将每个人学的课程存入一个map里面\n然后，在遍历（先遍历人，再遍历课程，这样更方便跳出循环）的时候直接先找出平均分，最后一遍sort，就完事了，优化了挺多的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; string x,y; int a,n,m,k; map\u0026lt;string,multimap\u0026lt;string,int\u0026gt;\u0026gt;ma; map\u0026lt;string,multiset\u0026lt;string\u0026gt;\u0026gt;rem; int main(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;a; ma[x].insert({y,a}); rem[y].insert(x); } cin\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ string temp[105]; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt;tem; cin\u0026gt;\u0026gt;k; for(int j=1;j\u0026lt;=k;j++){ cin\u0026gt;\u0026gt;temp[j]; } for(auto it=rem.begin();it!=rem.end();it++){ int ans=0; int flag=1; for(int j=1;j\u0026lt;=k;j++){ if(it-\u0026gt;second.find(temp[j])==it-\u0026gt;second.end()){ flag=0; break; } auto itt=ma[temp[j]].find(it-\u0026gt;first); ans+=itt-\u0026gt;second; } if(flag) { tem.push_back(make_pair(it-\u0026gt;first,ans)); } } sort(tem.begin(),tem.end(),[](const pair\u0026lt;string,int\u0026gt;x,const pair\u0026lt;string,int\u0026gt;y){ if(x.second==y.second) return x.first\u0026lt;y.first; return x.second\u0026gt;y.second;}); cout\u0026lt;\u0026lt;tem[0].first\u0026lt;\u0026lt;endl; } system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2025-05-10T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E6%9C%9F%E4%B8%ADc-%E9%83%A8%E5%88%86%E8%A1%A5%E5%85%85%E9%A2%98%E4%BA%8C/","title":"【程序设计实习】期中C++部分补充题二"},{"content":"A:编程填空：Hero和Priest 描述 完善以下程序，使其输出为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Hero::defense() Hero::attack() Priest::defense() Priest::attack() Priest::defense() #include \u0026lt;iostream\u0026gt; using namespace std; class Hero { public: // 在此处补充你的代码 }; class Priest: public Hero { public: virtual void attack() { cout \u0026lt;\u0026lt; \u0026#34;Priest::attack()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void defense() { cout \u0026lt;\u0026lt; \u0026#34;Priest::defense()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Priest anduin; Hero h; h.defense(); Hero *player = \u0026amp;anduin; player-\u0026gt;attack(); player-\u0026gt;defense(); anduin.attack(); anduin.defense(); return 0; } 输入 无\n输出 1 2 3 4 5 Hero::defense() Hero::attack() Priest::defense() Priest::attack() Priest::defense() 样例输入 1 无 样例输出 1 2 3 4 5 Hero::defense() Hero::attack() Priest::defense() Priest::attack() Priest::defense() Solution 这道题没什么特殊的，就是直接开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; class Hero { public: virtual void defense() { cout\u0026lt;\u0026lt;\u0026#34;Hero::defense()\u0026#34;\u0026lt;\u0026lt;endl; } void attack() { cout\u0026lt;\u0026lt;\u0026#34;Hero::attack()\u0026#34;\u0026lt;\u0026lt;endl; } }; class Priest: public Hero { public: virtual void attack() { cout \u0026lt;\u0026lt; \u0026#34;Priest::attack()\u0026#34; \u0026lt;\u0026lt; endl; } virtual void defense() { cout \u0026lt;\u0026lt; \u0026#34;Priest::defense()\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Priest anduin; Hero h; h.defense(); Hero *player = \u0026amp;anduin; player-\u0026gt;attack(); player-\u0026gt;defense(); anduin.attack(); anduin.defense(); return 0; } B:可恶的括号 描述 填写代码，按要求输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class f { // 在此处补充你的代码 }; int main() { cout \u0026lt;\u0026lt; f(3)(5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(4)(10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(114)(514) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(9,7) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(2,3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(2,5) \u0026lt;\u0026lt; endl; } 输入 .\n输出 .\n样例输入 1 (无) 样例输出 1 2 3 4 5 6 2 6 400 63 6 10 Solution 这道题就是直接重载两个()，参数不同罢了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class f { private: int x; public: f(int t):x(t) { } f(int a,int b){ x=a*b; } int operator()(int k){ return k-x; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const f \u0026amp;t){ os\u0026lt;\u0026lt;t.x; return os; } }; int main() { cout \u0026lt;\u0026lt; f(3)(5) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(4)(10) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(114)(514) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(9,7) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(2,3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f(2,5) \u0026lt;\u0026lt; endl; } C:编程填空:Dog!Dog!Dog! 描述 程序填空，编写Dog类，使得程序按样例进行输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; using namespace std; class Mammal { public: Mammal() { cout \u0026lt;\u0026lt; \u0026#34;Mammal constructor...\\n\u0026#34;; } virtual ~Mammal() { cout \u0026lt;\u0026lt; \u0026#34;Mammal destructor...\\n\u0026#34;; } Mammal (const Mammal \u0026amp; rhs); virtual void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Mammal speak!\\n\u0026#34;; } virtual Mammal* Clone() { return new Mammal(*this); } }; class Dog : public Mammal { // 在此处补充你的代码 }; Mammal::Mammal (const Mammal \u0026amp; rhs) { cout \u0026lt;\u0026lt; \u0026#34;Mammal Copy Constructor...\\n\u0026#34;; } Dog::Dog(){ cout \u0026lt;\u0026lt; \u0026#34;Dog constructor...\\n\u0026#34;; } Dog::~Dog(){ cout \u0026lt;\u0026lt; \u0026#34;Dog destructor...\\n\u0026#34;; } void Dog::Speak()const { cout \u0026lt;\u0026lt; \u0026#34;Woof!\\n\u0026#34;; } int main() { Mammal* x=new Dog, *y=new Mammal; Mammal* x1=x-\u0026gt;Clone(), *y1=y-\u0026gt;Clone(); x1-\u0026gt;Speak(); y1-\u0026gt;Speak(); return 0; } 输入 .\n输出 .\n样例输入 1 （无） 样例输出 1 2 3 4 5 6 7 8 Mammal constructor... Dog constructor... Mammal constructor... Mammal Copy Constructor... Dog copy constructor... Mammal Copy Constructor... Woof! Mammal speak! Solution 这道题需要我们创建一个Dog类作为Mammal类的派生类，然后顺便注意一下外面的几个函数也要在里面写一下粗浅的定义。\n同时，因为有虚函数Clone的存在，我们需要通过复制构造函数和上面已经有示例的Clone函数来实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; class Mammal { public: Mammal() { cout \u0026lt;\u0026lt; \u0026#34;Mammal constructor...\\n\u0026#34;; } virtual ~Mammal() { cout \u0026lt;\u0026lt; \u0026#34;Mammal destructor...\\n\u0026#34;; } Mammal (const Mammal \u0026amp; rhs); virtual void Speak() const { cout \u0026lt;\u0026lt; \u0026#34;Mammal speak!\\n\u0026#34;; } virtual Mammal* Clone() { return new Mammal(*this); } }; class Dog : public Mammal { public: void Speak()const; Dog(); Dog(const Dog \u0026amp;t):Mammal(t){ cout\u0026lt;\u0026lt;\u0026#34;Dog copy constructor...\\n\u0026#34;; } ~Dog(); Mammal* Clone(){ return new Dog(*this); } }; Mammal::Mammal (const Mammal \u0026amp; rhs) { cout \u0026lt;\u0026lt; \u0026#34;Mammal Copy Constructor...\\n\u0026#34;; } Dog::Dog(){ cout \u0026lt;\u0026lt; \u0026#34;Dog constructor...\\n\u0026#34;; } Dog::~Dog(){ cout \u0026lt;\u0026lt; \u0026#34;Dog destructor...\\n\u0026#34;; } void Dog::Speak()const { cout \u0026lt;\u0026lt; \u0026#34;Woof!\\n\u0026#34;; } int main() { Mammal* x=new Dog, *y=new Mammal; Mammal* x1=x-\u0026gt;Clone(), *y1=y-\u0026gt;Clone(); x1-\u0026gt;Speak(); y1-\u0026gt;Speak(); return 0; } D:编程填空:cmp函数模板 描述 填写代码，按要求输出结果。要求实现cmp函数模板，不能实现cmp函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; // 在此处补充你的代码 int main(){ int A[100]; A[0]=1; A[1]=2; cmp(A[0],2); printf(\u0026#34;finish 1\\n\u0026#34;); cmp(1, A[1]); printf(\u0026#34;finish 2\\n\u0026#34;); cmp(A,A[1]); printf(\u0026#34;finish 3\\n\u0026#34;); } 输入 .\n输出 .\n样例输入 1 （无） 样例输出 1 2 3 4 5 6 a finish 1 b finish 2 c finish 3 Solution 好吧，这道题放在这里绝对是卡人的\n我们只能通过多个重载去判断，然后？\n这个a和b其实根本无法判断啊\n这时，我们发现，题目让写的是全局的\n一个变量的事不就完了吗，真就抖机灵\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; void cmp(T x,int y){ cout\u0026lt;\u0026lt;\u0026#39;a\u0026#39;\u0026lt;\u0026lt;endl; } int k=0; template\u0026lt;\u0026gt; void cmp\u0026lt;\u0026gt;(int a,int b){ if(k%2) cout\u0026lt;\u0026lt;\u0026#39;b\u0026#39;\u0026lt;\u0026lt;endl; else{ k++; cout\u0026lt;\u0026lt;\u0026#39;a\u0026#39;\u0026lt;\u0026lt;endl; } } template\u0026lt;class T\u0026gt; void cmp(T* a,int b){ cout\u0026lt;\u0026lt;\u0026#39;c\u0026#39;\u0026lt;\u0026lt;endl; } int main(){ int A[100]; A[0]=1; A[1]=2; cmp(A[0],2); printf(\u0026#34;finish 1\\n\u0026#34;); cmp(1, A[1]); printf(\u0026#34;finish 2\\n\u0026#34;); cmp(A,A[1]); printf(\u0026#34;finish 3\\n\u0026#34;); } E:编程填空：花里胡哨的求和 描述 读入 n 个数, 输出 n 个数, 其中第 i 个数是读入中前 i 个数的和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; class A{ // 在此处补充你的代码 }; int A::presum=0; int main(){ int n;cin\u0026gt;\u0026gt;n; vector\u0026lt;A*\u0026gt; p; for(int i=0;i\u0026lt;n;i++){ int x;cin\u0026gt;\u0026gt;x; p.push_back(new A(x)); } for(int i=0;i\u0026lt;n;i++){ p[i]-\u0026gt;output(); } return 0; } 输入 .\n输出 .\n样例输入 1 2 3 1 2 3 样例输出 1 2 3 1 3 6 Solution 这题简单啊，静态成员变量直接加上x完事了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; class A{ private: int x; static int presum; public: A(int t):x(t) { } void output(){ presum+=x; cout\u0026lt;\u0026lt;presum\u0026lt;\u0026lt;endl; } }; int A::presum=0; int main(){ int n;cin\u0026gt;\u0026gt;n; vector\u0026lt;A*\u0026gt; p; for(int i=0;i\u0026lt;n;i++){ int x;cin\u0026gt;\u0026gt;x; p.push_back(new A(x)); } for(int i=0;i\u0026lt;n;i++){ p[i]-\u0026gt;output(); } return 0; } F:编程填空:Midterm 描述 填写缺失的部分，使程序输出要求的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;iostream\u0026gt; using namespace std; class Midterm { private: int val; public: // 在此处补充你的代码 }; int Min(int a,int b) { if(a \u0026lt; b) return a; else return b; } int main(){ Midterm a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a + 2021 \u0026lt;\u0026lt; endl; Midterm b(1000); cout \u0026lt;\u0026lt; b ++ \u0026lt;\u0026lt; endl; ((b-=10)-=20)-=30; cout \u0026lt;\u0026lt; b ++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Min(255,b) \u0026lt;\u0026lt;endl; return 0; } 输入 .\n输出 .\n样例输入 1 (无) 样例输出 1 2 3 4 5 0 2021 1001 942 255 Solution 这个题也是不难，毕竟就要求我们重载几个运算符，然后就完事了\n调用Min的时候需要一个类型转换函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;iostream\u0026gt; using namespace std; class Midterm { private: int val; public: friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const Midterm \u0026amp;t){ os\u0026lt;\u0026lt;t.val; return os; } Midterm operator+(int x){ val+=x; Midterm temp; temp.val=val; return temp; } Midterm(int x):val(x) { } Midterm() { } Midterm operator++(int ){ Midterm temp; val++; temp.val=val; return temp; } operator int(){ return val; } Midterm \u0026amp;operator-=(int x){ val-=x; return *this; } }; int Min(int a,int b) { if(a \u0026lt; b) return a; else return b; } int main(){ Midterm a; cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a + 2021 \u0026lt;\u0026lt; endl; Midterm b(1000); cout \u0026lt;\u0026lt; b ++ \u0026lt;\u0026lt; endl; ((b-=10)-=20)-=30; cout \u0026lt;\u0026lt; b ++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; Min(255,b) \u0026lt;\u0026lt;endl; return 0; } G:编程填空：统计个数 描述 请补充下列代码，使其可以根据输入分别统计不同数字个数以及不同字符串个数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; class Counter{ int cnt; public: Counter():cnt(0){} virtual void push(void*) = 0; virtual string name() = 0; void inc(){ ++cnt; } int number(){ return cnt; } }; template\u0026lt;class T\u0026gt; class TCounter: public Counter{ // 在此处补充你的代码 }; Counter* build_counter(string name){ if (name == \u0026#34;int\u0026#34;) return new TCounter\u0026lt;int\u0026gt;(\u0026#34;int\u0026#34;); else return new TCounter\u0026lt;string\u0026gt;(\u0026#34;string\u0026#34;); } int main(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Counter *a = build_counter(\u0026#34;int\u0026#34;), *b = build_counter(\u0026#34;string\u0026#34;); for (int i = 0; i \u0026lt; n; ++i){ int x; cin \u0026gt;\u0026gt; x; a-\u0026gt;push(\u0026amp;x); } for (int i = 0; i \u0026lt; m; ++i){ string x; cin \u0026gt;\u0026gt; x; b-\u0026gt;push(\u0026amp;x); } cout \u0026lt;\u0026lt; a-\u0026gt;name() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; a-\u0026gt;number() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b-\u0026gt;name() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; b-\u0026gt;number(); return 0; } 输入 第一行两个整数n,m(1\u0026lt;=n,m\u0026lt;=1e5)，分别代表接下来将会输入的数字个数以及字符串个数。\n接下来两行分别是n个数字以及m个字符串，由空格分隔。\n数字大小不超过int的表示范围，字符串长度不超过10.\n输出 输出两行，分别代表不同的数字个数以及不同的字符串个数。\n样例输入 1 2 3 5 5 1 2 3 4 3 a b b a ab 样例输出 1 2 int: 4 string: 3 Solution 我们介绍一下void*这个类型\n这个类型的好处在于能够被能被任意类型的指针赋值，本身只表示指向一块地址，没有包含具体类型\n坏处是，这个类型无法被解引用\n都看到前面有两个虚函数了吧？那当然是要重载这两个虚函数啊\n然后，我们只需要写一个set类（因为不重复），并记录这到底是int还是string的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; class Counter{ int cnt; public: Counter():cnt(0){} virtual void push(void*) = 0; virtual string name() = 0; void inc(){ ++cnt; } int number(){ return cnt; } }; template\u0026lt;class T\u0026gt; class TCounter: public Counter{ private: set\u0026lt;T\u0026gt;s; string a; public: TCounter(string k):Counter(){ a=k; } void push(void* x){ T* k=(T*)(x); if(s.find(*k)==s.end()){ inc(); s.insert(*k); } return ; } string name(){ return a; } }; Counter* build_counter(string name){ if (name == \u0026#34;int\u0026#34;) return new TCounter\u0026lt;int\u0026gt;(\u0026#34;int\u0026#34;); else return new TCounter\u0026lt;string\u0026gt;(\u0026#34;string\u0026#34;); } int main(){ int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; Counter *a = build_counter(\u0026#34;int\u0026#34;), *b = build_counter(\u0026#34;string\u0026#34;); for (int i = 0; i \u0026lt; n; ++i){ int x; cin \u0026gt;\u0026gt; x; a-\u0026gt;push(\u0026amp;x); } for (int i = 0; i \u0026lt; m; ++i){ string x; cin \u0026gt;\u0026gt; x; b-\u0026gt;push(\u0026amp;x); } cout \u0026lt;\u0026lt; a-\u0026gt;name() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; a-\u0026gt;number() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b-\u0026gt;name() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; b-\u0026gt;number(); return 0; } H:p园食宿预订系统 描述 某校园为方便学生订餐，推出食堂预定系统。食宿平台会在前一天提供菜单，学生在开饭时间前可订餐。 食堂每天会推出m个菜，每个菜有固定的菜价和总份数，售卖份数不能超过总份数。 假设共有n个学生点餐，每个学生固定点3个菜，当点的菜售罄时, 学生就买不到这个菜了。 请根据学生预定记录，给出食堂总的预定收入 数据满足1 \u0026lt;= n \u0026lt;= 6000，3 \u0026lt;= m \u0026lt;= 6000，单品菜价不大于1000元，每个菜的配额不超过3000\n输入 第一行两个整数n和m，代表有n个学生订餐，共有m个可选的菜\n下面m行，每行三个元素，分别是菜名、售价和可提供量，保证菜名不重合，菜价为整数\n下面n行，每行三个元素，表示这个学生点的三个菜的菜名\n输出 一个整数，表示食堂的收入\n样例输入 1 2 3 4 5 6 7 8 9 10 11 5 5 yangroupaomo 13 10 jituifan 7 5 luosifen 16 3 xinlamian 12 20 juruo_milktea 999 1 yangroupaomo luosifen juruo_milktea luosifen xinlamian jituifan yangroupaomo jituifan juruo_milktea jituifan xinlamian luosifen yangroupaomo yangroupaomo yangroupaomo 样例输出 1 1157 Solution 这题我们是不是在Python里面做过原题？\n当时肯定是用字典做的，那么，C++里对应的数据结构是什么呢？没错，是map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; int n,m; map\u0026lt;string,int\u0026gt;ma; map\u0026lt;string,int\u0026gt;fa; int ans=0; string x,y,z; int a,b; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; ma[x]=a; fa[x]=b; } for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; if(fa[x]\u0026gt;0){ fa[x]--; ans+=ma[x]; } if(fa[y]\u0026gt;0){ fa[y]--; ans+=ma[y]; } if(fa[z]\u0026gt;0){ fa[z]--; ans+=ma[z]; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; system(\u0026#34;pause\u0026#34;); return 0; } I:编程填空:MySet模板 描述 程序填空，从set模板派生一个MySet模板 并按要求输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; // 在此处补充你的代码 struct A { int n; A(int i):n(i) { } operator int() { return n; } bool operator \u0026gt;(const A \u0026amp; a) const { return n \u0026gt; a.n; } }; template \u0026lt;class IT\u0026gt; void print(IT s,IT e) {\tfor(; s != e; ++s) cout \u0026lt;\u0026lt; *s \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { MySet\u0026lt;int\u0026gt; mst; for (int i = 0;i \u0026lt; 10; ++i) mst.insert(i); print(mst.begin(),mst.end()); int a[] = {1,2,3,4}; mst.erase(a,a+3); print(mst.begin(),mst.end()); A b[] = {{7},{8}}; mst.erase(b,b+2); print(mst.begin(),mst.end());\tmst.erase(mst.find(6)); print(mst.begin(),mst.end()); for(int i = 0;i \u0026lt; 1000000; ++i) mst.insert(i); for(int i = 0; i \u0026lt; 1000000 - 10; ++i) mst.erase(mst.find(i)); int n; cin \u0026gt;\u0026gt; n; MySet\u0026lt;A\u0026gt; msta; for(int i = 0;i \u0026lt; n; ++i) { string cmd; int n; cin \u0026gt;\u0026gt; cmd \u0026gt;\u0026gt; n; if( cmd == \u0026#34;ADD\u0026#34;) msta.insert(A(n)); else { if (msta.find(A(n))!= msta.end()) cout \u0026lt;\u0026lt; \u0026#34;YES\u0026#34; \u0026lt;\u0026lt;endl; else cout \u0026lt;\u0026lt; \u0026#34;NO\u0026#34; \u0026lt;\u0026lt;endl; } } return 0; } 输入 第一行是整数n (n \u0026lt;= 10000)\n接下来n行，每行一个命令，是以下两种格式之一：\nADD n 要求将整数n加入集合\nFIND n 查询集合中有无整数n\n输出 先产生一些固有的输出，然后，\n对每个FIND命令， 如果集合中有整数n，则输出\u0026quot;YES\u0026quot;，否则输出\u0026quot;NO\u0026quot;\n样例输入 1 2 3 4 5 6 7 6 ADD 1 ADD 2 FIND 3 FIND 2 ADD 3 FIND 3 样例输出 1 2 3 4 5 6 7 9,8,7,6,5,4,3,2,1,0, 9,8,7,6,5,4,0, 9,6,5,4,0, 9,5,4,0, NO YES YES Solution 派生的MySet类，我们都知道，这道题，就按照正常的思路来MySet完事了\n但是，我们要注意的一点是，STL对于重载或者增加Pred判断函数的要求十分严格，一定要在没有影响的函数后面加上const表示只能调用静态成员变量\n同时，我们这个greater根据样例也看得出来\nJ:编程填空:C++也能函数式编程 描述 填写代码，按要求输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; // 设 vector v = [x1, x2, ..., xn], 表示其内顺序存储了 x1 ~ xn 共 n 个值 template \u0026lt;class T, class F\u0026gt; vector\u0026lt;T\u0026gt; vecMap(vector\u0026lt;T\u0026gt; v, F f) { // 返回 retV = [f(x1), f(x2), ..., f(xn)] vector\u0026lt;T\u0026gt; retV; for (auto x : v) retV.push_back(f(x)); return retV; } template \u0026lt;class T, class F\u0026gt; T vecReduce(T init, vector\u0026lt;T\u0026gt; v, F f) { // 返回 ret = f(...f(f(f(init, x1), x2), x3) ..., xn) T ret = init; for (auto x : v) ret = f(ret, x); return ret; } template \u0026lt;class T, class F\u0026gt; vector\u0026lt;T\u0026gt; vecFilter(vector\u0026lt;T\u0026gt; v, F f) { // 返回 retV = [xi : 1 \u0026lt;= i \u0026lt;= n 且 f(xi) 成立] vector\u0026lt;T\u0026gt; retV; for (auto x : v) if (f(x)) retV.push_back(x); return retV; } template \u0026lt;class T\u0026gt; void vecPrintln(vector\u0026lt;T\u0026gt; v) { // 依次输出 vector v 中的元素 cout \u0026lt;\u0026lt; \u0026#34;[ \u0026#34;; for (auto x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } vector\u0026lt;int\u0026gt; vecRangeInt(int l, int r) { // 返回一个包含 [l, r) 中整数的 vector vector\u0026lt;int\u0026gt; retV; for (int x = l; x \u0026lt; r; ++x) retV.push_back(x); return retV; } class UnaryAdd; class BinaryAdd; class GetSecond; class IsPrime; // 在此处补充你的代码 int main() { // 测试 vecMap, UnaryAdd vector\u0026lt;int\u0026gt; a = vecRangeInt(0, 5); vecPrintln(a); // [ 0, 1, 2, 3, 4, ] UnaryAdd addTen(10); vecPrintln(vecMap(a, addTen)); // [ 10, 11, 12, 13, 14, ] UnaryAdd addOne(1); vecPrintln(vecMap(vecMap(a, addOne), addOne)); // [ 2, 3, 4, 5, 6, ] // 测试 vecReduce, GetSecond, BinaryAdd vector\u0026lt;int\u0026gt; b1 {1, 0, 2, 4}; vector\u0026lt;int\u0026gt; b2 {8, 1, 9, 2}; vector\u0026lt;int\u0026gt; b3 {2, 0, 4, 8}; GetSecond getSecond; BinaryAdd binAdd; cout \u0026lt;\u0026lt; vecReduce(-2, b1, getSecond) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; vecReduce(-1, b2, getSecond) \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; vecReduce(0, b3, getSecond) \u0026lt;\u0026lt; endl; // 8 cout \u0026lt;\u0026lt; vecReduce(0, b1, binAdd) \u0026lt;\u0026lt; endl; // 0 + 1 + 0 + 2 + 4 = 7 cout \u0026lt;\u0026lt; vecReduce(1, b2, binAdd) \u0026lt;\u0026lt; endl; // 1 + 8 + 1 + 9 + 2 = 21 cout \u0026lt;\u0026lt; vecReduce(2, b3, binAdd) \u0026lt;\u0026lt; endl; // 2 + 2 + 0 + 4 + 8 = 16 // 测试 vecFilter, isPrime vector\u0026lt;int\u0026gt; c1 = vecRangeInt(1, 10); vector\u0026lt;int\u0026gt; c2 {17, 11, 10, 19, 15, 23}; IsPrime isPrime; vecPrintln(vecFilter(c1, isPrime)); // [ 2, 3, 5, 7, ] vecPrintln(vecFilter(c2, isPrime)); // [ 17, 11, 19, 23, ] vector\u0026lt;int\u0026gt; v1 = vecRangeInt(0, 8); cout \u0026lt;\u0026lt; vecReduce( -1000000, vecMap(v1, [](int x) { return 7 * x - x * x + 2; }), [](int x, int y) { return max(x, y); } ) \u0026lt;\u0026lt; endl; // max { 7x - x^2 + 2 : 0 \u0026lt;= x \u0026lt; 8 } = 14 vector\u0026lt;int\u0026gt; v2 = vecRangeInt(0, 12); vecPrintln(vecFilter( vecMap(v2, [](int x) { return 2 * x + 1; }), [](int x) { return x % 3 == 0; } )); // [ 2x + 1 : 0 \u0026lt;= x \u0026lt; 12 且 (2x + 1) 是 3 的倍数 ] = [ 3, 9, 15, 21, ] return 0; } 输入 .\n输出 .\n样例输入 1 （无） 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 [ 0, 1, 2, 3, 4, ] [ 10, 11, 12, 13, 14, ] [ 2, 3, 4, 5, 6, ] 4 2 8 7 21 16 [ 2, 3, 5, 7, ] [ 17, 11, 19, 23, ] 14 [ 3, 9, 15, 21, ] Solution 这道题就是要求我们实现四个仿函数，太明显了。\n第一个就是用一个数加到另一个数上\n第二个就是连续取后面一个数，然后返回第二个数\n第三个是一个数加到另一个数上\n第四个是判断是否是质数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; // 设 vector v = [x1, x2, ..., xn], 表示其内顺序存储了 x1 ~ xn 共 n 个值 template \u0026lt;class T, class F\u0026gt; vector\u0026lt;T\u0026gt; vecMap(vector\u0026lt;T\u0026gt; v, F f) { // 返回 retV = [f(x1), f(x2), ..., f(xn)] vector\u0026lt;T\u0026gt; retV; for (auto x : v) retV.push_back(f(x)); return retV; } template \u0026lt;class T, class F\u0026gt; T vecReduce(T init, vector\u0026lt;T\u0026gt; v, F f) { // 返回 ret = f(...f(f(f(init, x1), x2), x3) ..., xn) T ret = init; for (auto x : v) ret = f(ret, x); return ret; } template \u0026lt;class T, class F\u0026gt; vector\u0026lt;T\u0026gt; vecFilter(vector\u0026lt;T\u0026gt; v, F f) { // 返回 retV = [xi : 1 \u0026lt;= i \u0026lt;= n 且 f(xi) 成立] vector\u0026lt;T\u0026gt; retV; for (auto x : v) if (f(x)) retV.push_back(x); return retV; } template \u0026lt;class T\u0026gt; void vecPrintln(vector\u0026lt;T\u0026gt; v) { // 依次输出 vector v 中的元素 cout \u0026lt;\u0026lt; \u0026#34;[ \u0026#34;; for (auto x : v) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, \u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; endl; } vector\u0026lt;int\u0026gt; vecRangeInt(int l, int r) { // 返回一个包含 [l, r) 中整数的 vector vector\u0026lt;int\u0026gt; retV; for (int x = l; x \u0026lt; r; ++x) retV.push_back(x); return retV; } class UnaryAdd; class BinaryAdd; class GetSecond; class IsPrime; class UnaryAdd{ private: int x; public: UnaryAdd(int t):x(t) { } int operator()(int y){ return x+y; } }; class GetSecond{ public: int operator()(int x,int y){ return y; } }; class BinaryAdd{ public: int operator()(int x,int y){ return x+y; } }; class IsPrime{ public: bool operator()(int x){ if(x==1) return false; if(x==2||x==3) return true; for(int i=2;i*i\u0026lt;=x;i++){ if(x%i==0) return false; } return true; } }; int main() { // 测试 vecMap, UnaryAdd vector\u0026lt;int\u0026gt; a = vecRangeInt(0, 5); vecPrintln(a); // [ 0, 1, 2, 3, 4, ] UnaryAdd addTen(10); vecPrintln(vecMap(a, addTen)); // [ 10, 11, 12, 13, 14, ] UnaryAdd addOne(1); vecPrintln(vecMap(vecMap(a, addOne), addOne)); // [ 2, 3, 4, 5, 6, ] // 测试 vecReduce, GetSecond, BinaryAdd vector\u0026lt;int\u0026gt; b1 {1, 0, 2, 4}; vector\u0026lt;int\u0026gt; b2 {8, 1, 9, 2}; vector\u0026lt;int\u0026gt; b3 {2, 0, 4, 8}; GetSecond getSecond; BinaryAdd binAdd; cout \u0026lt;\u0026lt; vecReduce(-2, b1, getSecond) \u0026lt;\u0026lt; endl; // 4 cout \u0026lt;\u0026lt; vecReduce(-1, b2, getSecond) \u0026lt;\u0026lt; endl; // 2 cout \u0026lt;\u0026lt; vecReduce(0, b3, getSecond) \u0026lt;\u0026lt; endl; // 8 cout \u0026lt;\u0026lt; vecReduce(0, b1, binAdd) \u0026lt;\u0026lt; endl; // 0 + 1 + 0 + 2 + 4 = 7 cout \u0026lt;\u0026lt; vecReduce(1, b2, binAdd) \u0026lt;\u0026lt; endl; // 1 + 8 + 1 + 9 + 2 = 21 cout \u0026lt;\u0026lt; vecReduce(2, b3, binAdd) \u0026lt;\u0026lt; endl; // 2 + 2 + 0 + 4 + 8 = 16 // 测试 vecFilter, isPrime vector\u0026lt;int\u0026gt; c1 = vecRangeInt(1, 10); vector\u0026lt;int\u0026gt; c2 {17, 11, 10, 19, 15, 23}; IsPrime isPrime; vecPrintln(vecFilter(c1, isPrime)); // [ 2, 3, 5, 7, ] vecPrintln(vecFilter(c2, isPrime)); // [ 17, 11, 19, 23, ] vector\u0026lt;int\u0026gt; v1 = vecRangeInt(0, 8); cout \u0026lt;\u0026lt; vecReduce( -1000000, vecMap(v1, [](int x) { return 7 * x - x * x + 2; }), [](int x, int y) { return max(x, y); } ) \u0026lt;\u0026lt; endl; // max { 7x - x^2 + 2 : 0 \u0026lt;= x \u0026lt; 8 } = 14 vector\u0026lt;int\u0026gt; v2 = vecRangeInt(0, 12); vecPrintln(vecFilter( vecMap(v2, [](int x) { return 2 * x + 1; }), [](int x) { return x % 3 == 0; } )); // [ 2x + 1 : 0 \u0026lt;= x \u0026lt; 12 且 (2x + 1) 是 3 的倍数 ] = [ 3, 9, 15, 21, ] return 0; } K:编程填空：计算数组的低3位之和 描述 输入一个正整数构成的数组a[0], a[1], a[2], \u0026hellip; , a[n-1], 计算它们的二进制低3位之和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 int main(int argc, char* argv[]) { int v, my_sum=0; vector\u0026lt;int\u0026gt; vec;\tcin\u0026gt;\u0026gt;v; while ( v ) { vec.push_back(v); cin\u0026gt;\u0026gt;v; } for_each(vec.begin(), vec.end(), CMy_add(my_sum)); cout\u0026lt;\u0026lt;my_sum\u0026lt;\u0026lt;endl;\treturn 0; } 输入 数组a,以0表示输入结束。\n输出 一个整数 , 所输入数组各元素的二进制低3位之和。\n样例输入 1 1 3 9 7 3 6 20 15 18 17 4 8 18 0 样例输出 1 41 Solution 其实我不知道低3位是什么，还查了一下\n然后发现就是最低3个二进制位的数之和（1,2,4）的排列组合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class CMy_add{ private: int\u0026amp; result; bool flag; public: CMy_add(int\u0026amp; x):result(x),flag(true) { } CMy_add(const CMy_add \u0026amp;other):result(other.result),flag(false) { } void operator()(int x){ result+=(x\u0026amp;1); result+=((x\u0026gt;\u0026gt;1)\u0026amp;1)*2; result+=((x\u0026gt;\u0026gt;2)\u0026amp;1)*4; } }; int main(int argc, char* argv[]) { int v, my_sum=0; vector\u0026lt;int\u0026gt; vec;\tcin\u0026gt;\u0026gt;v; while ( v ) { vec.push_back(v); cin\u0026gt;\u0026gt;v; } for_each(vec.begin(), vec.end(), CMy_add(my_sum)); cout\u0026lt;\u0026lt;my_sum\u0026lt;\u0026lt;endl;\treturn 0; } L:求平均数的类真叫mean 描述 输入一系列正整数, 计算它们的平均值，结果去尾取整数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; class CMean { // 在此处补充你的代码 }; int main(int argc, char* argv[]) { int v; int t; cin \u0026gt;\u0026gt; t; while ( t -- ) { cin \u0026gt;\u0026gt; v; vector\u0026lt;int\u0026gt; vec; while (v) { vec.push_back(v); cin \u0026gt;\u0026gt; v; } int myAver = 0; for_each(vec.begin(), vec.end(), CMean(myAver)); cout \u0026lt;\u0026lt; myAver \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是测试数据组数T\n接下T行，每行一组数据。每行是若干个正整数，以0表示输入结束(0不算)。\n输出 对每组数据，输出所有数的平均值，结果去尾取整数\n样例输入 1 2 1 17 4 8 18 0 样例输出 1 11 Solution 这题就是开始考验我们的for_each技术了，先来介绍一下这个吧\n就是呢，for_each只会生成一个CMean类，你可能觉得简单，不要笑，但是编译会有更神奇的东西\n就是，我们通常需要在析构函数中作一些操作的时候，会发现，这操作怎么作了两次\n其实是因为移动构造函数惹的祸，它会通过复制构造函数把我们现有的类复制给别的东西\n这个时候我们需要做什么？就是让这个复制后的函数不执行析构函数中的操作（不是不析构！），只需要在原函数中体现一个bool变量，复制构造函数中让这个变量变成false,就能保证了\n还有，因为没有地方可以返回这个变量，所以类中的变量要改成一个整数型引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; class CMean { private: int\u0026amp; result; int num; bool flag; public: CMean(int\u0026amp; t):result(t),num(0),flag(true) { } void operator()(const auto \u0026amp;x){ result+=x; num++; return ; } CMean(const CMean \u0026amp;other):result(other.result),num(other.num),flag(false){ } ~CMean(){ if(flag){ result/=num; flag=false; } } }; int main(int argc, char* argv[]) { int v; int t; cin \u0026gt;\u0026gt; t; while ( t -- ) { cin \u0026gt;\u0026gt; v; vector\u0026lt;int\u0026gt; vec; while (v) { vec.push_back(v); cin \u0026gt;\u0026gt; v; } int myAver = 0; for_each(vec.begin(), vec.end(), CMean(myAver)); cout \u0026lt;\u0026lt; myAver \u0026lt;\u0026lt; endl; } return 0; } M:积分图 描述 对于一幅灰度的图像，积分图中的任意一点(x,y)的值是指从图像的左上角到这个点的所构成的矩形区域内所有的点的灰度值之和。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class IntegralImage{ // 在此处补充你的代码 }; int main(){ int H, W; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; int ** image = new int*[H]; for(int i=0;i\u0026lt;H;++i){ image[i]=new int[W]; } for(int i=0;i\u0026lt;H;++i) for(int j=0;j\u0026lt;W;++j) cin \u0026gt;\u0026gt; image[i][j]; IntegralImage it(H,W); for_each(image, image+H, it); for(int i=0;i\u0026lt;H;++i){ for(int j=0;j\u0026lt;W;++j) cout\u0026lt;\u0026lt;it[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } } 输入 第一行两个整数，分别是图像的宽、高H, W\n接下来H*W的矩阵，分别代表图像的每个像素值\n输出 积分图中每个点的值, H*W的矩阵，每个像素之间用空格分开\n样例输入 1 2 3 2 3 1 2 3 1 0 0 样例输出 1 2 1 3 6 2 4 7 Solution 这道题，我还是需要对这个矩阵作一些操作\n至于二维指针的设置，题目中已经有示例了，我们不管\n然后，我们新创建的指针要初始化\n最后重载一下[]就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; class IntegralImage{ private: int h,w; int** dd; int num; public: IntegralImage(int a,int b):h(a),w(b),num(0){ dd=new int*[h]; for(int i=0;i\u0026lt;h;i++){ dd[i]=new int[w]; } for(int i=0;i\u0026lt;h;i++){ for(int j=0;j\u0026lt;w;j++){ dd[i][j]=0; } } } void operator()(int* x){ for(int i=0;i\u0026lt;w;i++){ for(int j=num;j\u0026lt;h;j++){ for(int v=i;v\u0026lt;w;v++){ dd[j][v]+=x[i]; } } } num++; } int* operator[](int x){ return dd[x]; } }; int main(){ int H, W; cin \u0026gt;\u0026gt; H \u0026gt;\u0026gt; W; int ** image = new int*[H]; for(int i=0;i\u0026lt;H;++i){ image[i]=new int[W]; } for(int i=0;i\u0026lt;H;++i) for(int j=0;j\u0026lt;W;++j) cin \u0026gt;\u0026gt; image[i][j]; IntegralImage it(H,W); for_each(image, image+H, it); for(int i=0;i\u0026lt;H;++i){ for(int j=0;j\u0026lt;W;++j) cout\u0026lt;\u0026lt;it[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } } N:编程填空：序列累加和字符串复制 描述 程序填空完成指定功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 int main(){ vector\u0026lt;int\u0026gt; v1; vector\u0026lt;string\u0026gt; v2; int N, val, num_repeat,result_int=0; string str,result_str=\u0026#34;\u0026#34;; cin\u0026gt;\u0026gt;N; cin\u0026gt;\u0026gt;num_repeat; for(int i=0;i\u0026lt;N;++i){ cin\u0026gt;\u0026gt;val; v1.push_back(val); } for_each(v1.begin(),v1.end(),MyFunc\u0026lt;int\u0026gt;(num_repeat,result_int)); for(int i=0;i\u0026lt;N;++i){ cin\u0026gt;\u0026gt;str; v2.push_back(str); } for_each(v2.begin(),v2.end(),MyFunc\u0026lt;string\u0026gt;(num_repeat,result_str)); cout\u0026lt;\u0026lt;result_int\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;--------------\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;result_str\u0026lt;\u0026lt;endl; } 输入 首先读入两个整数N和M，表示数字/字符串序列的元素个数及累加次数。\n接下来输入N个整数，形成这个数字序列。\n接下来输入N个字符串，形成一个字符串序列。\n输出 对数字序列进行累加，并将结果乘以M之后输出。\n对字符串序列进行拼接，并将结果复制M次之后输出。\n样例输入 1 2 3 3 4 9 8 1 ab cd ef 样例输出 1 2 3 72 -------------- abcdefabcdefabcdefabcdef Solution 这道题跟我们上面说的for_each的析构函数是一样的，然后，对于这种STL，我们还是要养成写const的好习惯\n其他流程跟上面那道题几乎没有区别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; template\u0026lt;class T\u0026gt; class MyFunc{ private: int\u0026amp; num_repeat; T\u0026amp; result; bool flag; public: MyFunc(int\u0026amp; n,T\u0026amp; k):num_repeat(n),result(k),flag(true) { } MyFunc(const MyFunc \u0026amp;other):num_repeat(other.num_repeat),result(other.result),flag(false) { } void operator()(const T\u0026amp; a)const{ result+=a; return ; } ~MyFunc(){ if(flag){ const T temp=result; for(int i=1;i\u0026lt;=num_repeat-1;i++){ result+=temp; } } } }; int main(){ vector\u0026lt;int\u0026gt; v1; vector\u0026lt;string\u0026gt; v2; int N, val, num_repeat,result_int=0; string str,result_str=\u0026#34;\u0026#34;; cin\u0026gt;\u0026gt;N; cin\u0026gt;\u0026gt;num_repeat; for(int i=0;i\u0026lt;N;++i){ cin\u0026gt;\u0026gt;val; v1.push_back(val); } for_each(v1.begin(),v1.end(),MyFunc\u0026lt;int\u0026gt;(num_repeat,result_int)); for(int i=0;i\u0026lt;N;++i){ cin\u0026gt;\u0026gt;str; v2.push_back(str); } for_each(v2.begin(),v2.end(),MyFunc\u0026lt;string\u0026gt;(num_repeat,result_str)); cout\u0026lt;\u0026lt;result_int\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;--------------\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;result_str\u0026lt;\u0026lt;endl; } O:编程填空：人群的排序和分类 描述 对人群按照输入的信息进行排序和分类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 int main() { int t; cin \u0026gt;\u0026gt; t; set\u0026lt;A*,Comp\u0026gt; ct; while( t -- ) { int n; cin \u0026gt;\u0026gt; n; ct.clear(); for( int i = 0;i \u0026lt; n; ++i)\t{ char c; int k; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; k; if( c == \u0026#39;A\u0026#39;) ct.insert(new A(k)); else ct.insert(new B(k)); }\tfor_each(ct.begin(),ct.end(),Print); cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; } } 输入 第一行是整数t,表明一共t组数据. t \u0026lt; 20\n对每组数据：\n第一行是整数n,表示下面一共有n行。 0 \u0026lt; n \u0026lt; 100\n下面的每行代表一个人。每行以一个字母开头，代表该人所属的类别，然后跟着一个整数，代表年龄。字母只会是 \u0026lsquo;A‘或‘B\u0026rsquo; 。整数范围0到100。数据保证年龄都不相同。\n输出 对每组输入数据，将这些人按年龄从小到大输出。每个人先输出类别，再输出年龄。每组数据的末尾加一行 \u0026ldquo;****\u0026rdquo;\n样例输入 1 2 3 4 5 6 7 8 9 10 2 4 A 3 B 4 A 5 B 6 3 A 4 A 3 A 2 样例输出 1 2 3 4 5 6 7 8 9 A 3 B 4 A 5 B 6 **** A 2 A 3 A 4 **** Solution 我们需要通过输入来分类\n注意，这里A类在set中的表现是指针形式的\n而且，后续可以insert一个B类变量，为什么不需要我说了吧？\n当然是因为B是A的派生类\n同时，我们还需要构造一个仿函数，这个仿函数对A*和B*进行比较，这里再强调一次，STL的自定义比较器一定要加const，不然会报错\n调用B类的时候，id变量赋成\u0026quot;B\u0026quot;，所以要再给A类写一个空默认构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class A{ public: int age; char id; A(int x):age(x) { id=\u0026#39;A\u0026#39;; } A(){ } }; class B:public A{ public: B(int x){ id=\u0026#39;B\u0026#39;; age=x; } }; struct Comp{ bool operator()(A* x,A* y)const{ return x-\u0026gt;age\u0026lt;y-\u0026gt;age; } }; void Print(const A* a){ cout\u0026lt;\u0026lt;a-\u0026gt;id\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;a-\u0026gt;age\u0026lt;\u0026lt;endl; } int main() { int t; cin \u0026gt;\u0026gt; t; set\u0026lt;A*,Comp\u0026gt; ct; while( t -- ) { int n; cin \u0026gt;\u0026gt; n; ct.clear(); for( int i = 0;i \u0026lt; n; ++i)\t{ char c; int k; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; k; if( c == \u0026#39;A\u0026#39;) ct.insert(new A(k)); else ct.insert(new B(k)); }\tfor_each(ct.begin(),ct.end(),Print); cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; } } P:编程填空：数据库内的学生信息 描述 程序填空，使得下面的程序,先输出\n(Tom,80),(Tom,70),(Jone,90),(Jack,70),(Alice,100),\n(Tom,78),(Tom,78),(Jone,90),(Jack,70),(Alice,100),\n(70,Jack),(70,Tom),(80,Tom),(90,Jone),(100,Alice),\n(70,Error),(70,Error),(80,Tom),(90,Jone),(100,Alice),\n然后，再根据输入数据按要求产生输出数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 struct Student { string name; int score; }; template \u0026lt;class T\u0026gt; void Print(T first,T last) { for(;first!= last; ++ first) cout \u0026lt;\u0026lt; * first \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { Student s[] = { {\u0026#34;Tom\u0026#34;,80},{\u0026#34;Jack\u0026#34;,70}, {\u0026#34;Jone\u0026#34;,90},{\u0026#34;Tom\u0026#34;,70},{\u0026#34;Alice\u0026#34;,100} }; MyMultimap\u0026lt;string,int\u0026gt; mp; for(int i = 0; i\u0026lt;5; ++ i) mp.insert(make_pair(s[i].name,s[i].score)); Print(mp.begin(),mp.end()); //按姓名从大到小输出 mp.Set(\u0026#34;Tom\u0026#34;,78); //把所有名为\u0026#34;Tom\u0026#34;的学生的成绩都设置为78 Print(mp.begin(),mp.end()); MyMultimap\u0026lt;int,string,less\u0026lt;int\u0026gt; \u0026gt; mp2; for(int i = 0; i\u0026lt;5; ++ i) mp2.insert(make_pair(s[i].score,s[i].name)); Print(mp2.begin(),mp2.end()); //按成绩从小到大输出 mp2.Set(70,\u0026#34;Error\u0026#34;); //把所有成绩为70的学生，名字都改为\u0026#34;Error\u0026#34; Print(mp2.begin(),mp2.end()); cout \u0026lt;\u0026lt; \u0026#34;******\u0026#34; \u0026lt;\u0026lt; endl; mp.clear(); string name; string cmd; int score;\twhile(cin \u0026gt;\u0026gt; cmd ) { if( cmd == \u0026#34;A\u0026#34;) { cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; score; if(mp.find(name) != mp.end() ) { cout \u0026lt;\u0026lt; \u0026#34;erroe\u0026#34; \u0026lt;\u0026lt; endl; } mp.insert(make_pair(name,score)); } else if(cmd == \u0026#34;Q\u0026#34;) { cin \u0026gt;\u0026gt; name; MyMultimap\u0026lt;string,int\u0026gt;::iterator p = mp.find(name); if( p!= mp.end()) { cout \u0026lt;\u0026lt; p-\u0026gt;second \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; }\t} } return 0; } 输入 输入数据的每一行，格式为以下之一：\nA name score\nQ name score\nname是个不带个空格的字符串，长度小于 20\nscore是个整数，能用int表示\nA name score 表示往数据库中新增一个姓名为name的学生，其分数为score。开始时数据库中一个学生也没有。\nQ name 表示在数据库中查询姓名为name的学生的分数\n数据保证学生不重名。\n输入数据少于200,000行。\n输出 对于每个查询，输出学生的分数。如果查不到，则输出 \u0026ldquo;Not Found\u0026rdquo;\n样例输入 1 2 3 4 5 6 A Tom1 30 A Tom2 40 Q Tom3 A Tom4 89 Q Tom1 Q Tom2 样例输出 1 2 3 4 5 6 7 8 (Tom,80),(Tom,70),(Jone,90),(Jack,70),(Alice,100), (Tom,78),(Tom,78),(Jone,90),(Jack,70),(Alice,100), (70,Jack),(70,Tom),(80,Tom),(90,Jone),(100,Alice), (70,Error),(70,Error),(80,Tom),(90,Jone),(100,Alice), ****** Not Found 30 40 提示 编写模板的时候，连续的两个 “\u0026gt;”最好要用空格分开，以免被编译器看作是 \u0026ldquo;\u0026raquo;\u0026ldquo;运算符。VS可能无此问题，但是Dev C++和服务器上的编译环境会有这个问题。\n比如 vector\u0026lt;vector\u0026lt; int \u0026raquo; 有可能出错，要改成 vector\u0026lt;vector\u0026lt; int \u0026gt; \u0026gt;\n在模板中写迭代器时，最好在前面加上 typename关键字，否则可能会编译错。VS可能无此问题，但是Dev C++和服务器上的编译环境会有这个问题。\nSolution 这道题其实之前出过了，主要的要点还是在这个multimap类的重载\n我们需要一个Pred类来作为这个multimap的比较函数（缺省变量是T1类型的greater），这点一定不能忘！\n然后剩下的几个函数不谈\n我们注意一下，这个typedef的重命名问题，前面表示的是对于实例化的模板类的名称，所以真正要改名的只有iterator一个\n还有这个输出函数也要使用模板类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; template\u0026lt;class T1,class T2,class Pred=greater\u0026lt;T1\u0026gt;\u0026gt; class MyMultimap{ private: multimap\u0026lt;T1,T2,Pred\u0026gt;k; public: typedef typename multimap\u0026lt;T1,T2,Pred\u0026gt;::iterator iterator; MyMultimap(){ k.clear(); } void insert(pair\u0026lt;T1,T2\u0026gt;a){ k.insert(a); } auto begin(){ return k.begin(); } auto end(){ return k.end(); } void clear(){ k.clear(); } auto find(T1 x){ return k.find(x); } void Set(T1 x,T2 y){ for(auto it=k.begin();it!=k.end();it++){ if(it-\u0026gt;first==x) it-\u0026gt;second=y; } } }; template\u0026lt;class T1,class T2\u0026gt; ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const pair\u0026lt;T1,T2\u0026gt;x){ os\u0026lt;\u0026lt;\u0026#39;(\u0026#39;\u0026lt;\u0026lt;x.first\u0026lt;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026lt;x.second\u0026lt;\u0026lt;\u0026#39;)\u0026#39;; return os; } struct Student { string name; int score; }; template \u0026lt;class T\u0026gt; void Print(T first,T last) { for(;first!= last; ++ first) cout \u0026lt;\u0026lt; * first \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { Student s[] = { {\u0026#34;Tom\u0026#34;,80},{\u0026#34;Jack\u0026#34;,70}, {\u0026#34;Jone\u0026#34;,90},{\u0026#34;Tom\u0026#34;,70},{\u0026#34;Alice\u0026#34;,100} }; MyMultimap\u0026lt;string,int\u0026gt; mp; for(int i = 0; i\u0026lt;5; ++ i) mp.insert(make_pair(s[i].name,s[i].score)); Print(mp.begin(),mp.end()); //按姓名从大到小输出 mp.Set(\u0026#34;Tom\u0026#34;,78); //把所有名为\u0026#34;Tom\u0026#34;的学生的成绩都设置为78 Print(mp.begin(),mp.end()); MyMultimap\u0026lt;int,string,less\u0026lt;int\u0026gt; \u0026gt; mp2; for(int i = 0; i\u0026lt;5; ++ i) mp2.insert(make_pair(s[i].score,s[i].name)); Print(mp2.begin(),mp2.end()); //按成绩从小到大输出 mp2.Set(70,\u0026#34;Error\u0026#34;); //把所有成绩为70的学生，名字都改为\u0026#34;Error\u0026#34; Print(mp2.begin(),mp2.end()); cout \u0026lt;\u0026lt; \u0026#34;******\u0026#34; \u0026lt;\u0026lt; endl; mp.clear(); string name; string cmd; int score;\twhile(cin \u0026gt;\u0026gt; cmd ) { if( cmd == \u0026#34;A\u0026#34;) { cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; score; if(mp.find(name) != mp.end() ) { cout \u0026lt;\u0026lt; \u0026#34;erroe\u0026#34; \u0026lt;\u0026lt; endl; } mp.insert(make_pair(name,score)); } else if(cmd == \u0026#34;Q\u0026#34;) { cin \u0026gt;\u0026gt; name; MyMultimap\u0026lt;string,int\u0026gt;::iterator p = mp.find(name); if( p!= mp.end()) { cout \u0026lt;\u0026lt; p-\u0026gt;second \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; }\t} } return 0; } Q:矩形排序 描述 给定一系列边长已知的矩形，输出对矩形进行两种排序的结果。\n在第一种排序中，先按矩形的面积从大到小排序；若两个矩形的面积相同，则周长大的排在前。\n在第二种排序中，先按矩形的周长从小到大排序；若两个矩形的周长相同，则面积小的排在前。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; // 在此处补充你的代码 int main() { multiset\u0026lt;Rectangle\u0026gt; m1; multiset\u0026lt;Rectangle, Comp\u0026gt; m2; int n, a, b; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; m1.insert(Rectangle(a, b)); m2.insert(Rectangle(a, b)); } for (multiset\u0026lt;Rectangle\u0026gt;::iterator it = m1.begin(); it != m1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; for (multiset\u0026lt;Rectangle\u0026gt;::iterator it = m2.begin(); it != m2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是一个整数n，表示输入的矩形个数。\n接下来n行表示了n个矩形。每行有两个整数a与b，表示该矩形的长与宽。\n输出 先用n行输出第一种排序的结果。每行两个整数，依次表示该矩形的面积与周长。\n再输出一个空行。\n最后用n行输出第二种排序的结果。每行两个整数，依次表示该矩形的面积与周长。\n样例输入 1 2 3 4 5 6 7 6 3 8 4 6 10 2 6 6 4 8 3 6 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 36 24 32 24 24 22 24 20 20 24 18 18 18 18 24 20 24 22 20 24 32 24 36 24 Solution 我们需要构造一个矩形类，这个类应该包含了周长和面积两个参数 对于第一个缺省的类，我们通过重载小于号来完成（再次注意一下const）\n对于第二个有给出的类，我们写一个仿函数来完成（还是要注意const）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; class Rectangle{ public: int l,w; int c,s; Rectangle(int a,int b):l(a),w(b) { c=2*(a+b); s=a*b; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const Rectangle \u0026amp;t){ os\u0026lt;\u0026lt;t.s\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;t.c; return os; } bool operator\u0026lt;(const Rectangle \u0026amp;k)const{ if(s==k.s) return c\u0026gt;k.c; return s\u0026gt;k.s; } }; struct Comp{ bool operator()(Rectangle a,Rectangle b)const{ if(a.c==b.c) return a.s\u0026lt;b.s; return a.c\u0026lt;b.c; } }; int main() { multiset\u0026lt;Rectangle\u0026gt; m1; multiset\u0026lt;Rectangle, Comp\u0026gt; m2; int n, a, b; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; m1.insert(Rectangle(a, b)); m2.insert(Rectangle(a, b)); } for (multiset\u0026lt;Rectangle\u0026gt;::iterator it = m1.begin(); it != m1.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; for (multiset\u0026lt;Rectangle\u0026gt;::iterator it = m2.begin(); it != m2.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } R:学生考勤记录查询 描述 学生考勤记录查询，可以完成下面三条操作：\n1)add date id，例如add 1 1500012755，学号为1500012755的学生，在本月1日缺勤\n2)querydate_begin date_end，例如query 1 3，查询本月1日至本月3日（包含1日及3日）缺勤学生名单，输出格式为（同一日内缺勤的学生输出顺序与add操作顺序一致）：\ndate id id ……\ndate id ……\n3)exit 结束程序\n请实现QueryResult函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; // 在此处补充你的代码 int main(int argc, char* argv[]) { map\u0026lt;int, list\u0026lt;int\u0026gt; \u0026gt; Attendance; map\u0026lt;int, list\u0026lt;int\u0026gt; \u0026gt;::iterator it; string cmd; int date, id, date_lower, date_upper; while (cin \u0026gt;\u0026gt; cmd){ if (cmd == \u0026#34;add\u0026#34;){ cin \u0026gt;\u0026gt; date \u0026gt;\u0026gt; id; it = Attendance.find(date); if (it != Attendance.end()){ it-\u0026gt;second.push_back(id); } else{ list\u0026lt;int\u0026gt; lst_id; lst_id.push_back(id); Attendance.insert(make_pair(date,lst_id)); } } else if (cmd == \u0026#34;query\u0026#34;){ cin \u0026gt;\u0026gt; date_lower\u0026gt;\u0026gt;date_upper; QueryResult(Attendance.lower_bound(date_lower), Attendance.upper_bound(date_upper)); } else if (cmd == \u0026#34;exit\u0026#34;) return 0; } return 0; } 输入 每一行数据格式如上述两条命令，其中date是int型，0 \u0026lt; date \u0026lt; 32，id为int型，以15开头的10位学号。\n输出 在输入数据有query命令时，输出相应格式的缺勤名单(每个学号后面有一个空格)\n样例输入 1 2 3 4 5 6 7 add 1 1500012755 add 1 1500012796 add 3 1500012755 query 1 2 add 4 1500012737 query 1 4 exit 样例输出 1 2 3 4 1: 1500012755 1500012796 1: 1500012755 1500012796 3: 1500012755 4: 1500012737 Solution 我们只需要写这个输出函数，因为不知道类型，所以，用一个函数模板完成\n同时，还要补一个Print函数，毕竟是数据结构套数据结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; void Print(list\u0026lt;int\u0026gt; x){ for(auto i=x.begin();i!=x.end();i++){ cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; } template\u0026lt;class T\u0026gt; void QueryResult(T x,T y){ for(T i=x;i!=y;i++){ cout\u0026lt;\u0026lt;i-\u0026gt;first\u0026lt;\u0026lt;\u0026#34;: \u0026#34;; Print(i-\u0026gt;second); } } int main(int argc, char* argv[]) { map\u0026lt;int, list\u0026lt;int\u0026gt; \u0026gt; Attendance; map\u0026lt;int, list\u0026lt;int\u0026gt; \u0026gt;::iterator it; string cmd; int date, id, date_lower, date_upper; while (cin \u0026gt;\u0026gt; cmd){ if (cmd == \u0026#34;add\u0026#34;){ cin \u0026gt;\u0026gt; date \u0026gt;\u0026gt; id; it = Attendance.find(date); if (it != Attendance.end()){ it-\u0026gt;second.push_back(id); } else{ list\u0026lt;int\u0026gt; lst_id; lst_id.push_back(id); Attendance.insert(make_pair(date,lst_id)); } } else if (cmd == \u0026#34;query\u0026#34;){ cin \u0026gt;\u0026gt; date_lower\u0026gt;\u0026gt;date_upper; QueryResult(Attendance.lower_bound(date_lower), Attendance.upper_bound(date_upper)); } else if (cmd == \u0026#34;exit\u0026#34;) return 0; } return 0; } S:维护平面点 描述 程序填空，一开始平面上一个点都没有\n每次可以插入一个点，删除一个已经存在的点，或者按照x 或y 来查询一个存在的点\n保证任何时候任意两个点一定是一个点严格在另一个点的右下方\n即两点(x1, y1), (x2, y2)，必定有x1 \u0026gt; x2 且y1 \u0026lt; y2 ，或者x1 \u0026lt; x2 且y1 \u0026gt; y2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;set\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; // 在此处补充你的代码 int main() { string cmd; set\u0026lt;pair\u0026lt;int, int\u0026gt;, myComp\u0026gt; S; while (cin \u0026gt;\u0026gt; cmd) { if (cmd == \u0026#34;A\u0026#34;) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; S.insert(make_pair(x, y)); } else if (cmd == \u0026#34;Qx\u0026#34;) { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; S.lower_bound(make_pair(x, -1))-\u0026gt;second \u0026lt;\u0026lt; endl; } else if (cmd == \u0026#34;Qy\u0026#34;) { int y; cin \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; S.lower_bound(make_pair(-1, y))-\u0026gt;first \u0026lt;\u0026lt; endl; } else { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; S.erase(make_pair(x, y)); } } return 0; } 输入 输入数据的每一行，格式为以下之一： A x y\nR x y\nQx x\nQy y\n其中 x 与 y 都是 0 到 10^9 之间的整数\nA x y 表示插入点 (x, y)\nR x y 表示删除点 (x, y)，保证存在\nQx x 表示在当前所有点中，找到第一维为x的点，输出其第二维的值，保证存在\nQy y 表示在当前所有点中，找到第二维为y的点，输出其第一维的值，保证存在\n总共操作数不超过100000\n输出 对于每一个 Qx 和 Qy 操作，输出一行表示对应的答案\n样例输入 1 2 3 4 5 6 A 3 5 A 4 2 Qx 4 R 4 2 A 4 3 Qy 3 样例输出 1 2 2 4 Solution 题干我们不看了啊\n这次着重讲一下这个lower_bound\n这是什么？\n就是，对于一个数据结构进行查找，找到第一个“大于等于”给定数（广义）的数（广义）\n更通俗的理解是，找到第一个\u0026quot;违反小于\u0026quot;的数，我们这里看一下\n建立小于的话，对于原本的数据，显然挺好找\n但是，比如第一个数值是-1的时候，怎么定义\u0026quot;小于\u0026rdquo;？想象一下一个$x=t$的轴直接切过来，此时你是怎么想的？肯定是比较第一维吧，那么，就不能让第一维实际比x大的点被认定为\u0026quot;小于\u0026rdquo;\n第二维是同理的\n注意，我们定义的实际上是排序函数，也就是说lower_bound实际上是从begin到end找到最早满足条件的那个数，所以要注意排序顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;set\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; struct myComp{ bool operator()(const pair\u0026lt;int,int\u0026gt;\u0026amp;x,const pair\u0026lt;int,int\u0026gt;\u0026amp;y)const{ if(x.first\u0026gt;0\u0026amp;\u0026amp;y.first\u0026gt;0\u0026amp;\u0026amp;x.second\u0026gt;0\u0026amp;\u0026amp;y.second\u0026gt;0) return x.first\u0026gt;y.first; if(x.first\u0026lt;0||y.first\u0026lt;0) return x.second\u0026lt;y.second; if(x.second\u0026lt;0||y.second\u0026lt;0) return x.first\u0026gt;y.first; } }; int main() { string cmd; set\u0026lt;pair\u0026lt;int, int\u0026gt;, myComp\u0026gt; S; while (cin \u0026gt;\u0026gt; cmd) { if (cmd == \u0026#34;A\u0026#34;) { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; S.insert(make_pair(x, y)); } else if (cmd == \u0026#34;Qx\u0026#34;) { int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; S.lower_bound(make_pair(x, -1))-\u0026gt;second \u0026lt;\u0026lt; endl; } else if (cmd == \u0026#34;Qy\u0026#34;) { int y; cin \u0026gt;\u0026gt; y; cout \u0026lt;\u0026lt; S.lower_bound(make_pair(-1, y))-\u0026gt;first \u0026lt;\u0026lt; endl; } else { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; S.erase(make_pair(x, y)); } } return 0; } T:编程填空：按要求输出 描述 下列程序的输出为\u0026quot;10 13 18 15 17 12 16 19\u0026quot;, 请补充代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iterator\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int a[10] = {0, 6, 7, 3, 9, 5, 8, 6, 4, 9}; int b[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}; int main(int argc, char** argv) { // 在此处补充你的代码 for(int i=0; i\u0026lt;10; i++) c[a[i]] = b[i]; for(it=c.begin(); it!=c.end(); it++) cout\u0026lt;\u0026lt;it-\u0026gt;second\u0026lt;\u0026lt;\u0026#34; \u0026#34;; return 0; } 输入 无\n输出 10 13 18 15 17 12 16 19\n样例输入 1 None 样例输出 1 10 13 18 15 17 12 16 19 Solution 一眼就是用map啊，又没有别的关联容器能这么干\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iterator\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int a[10] = {0, 6, 7, 3, 9, 5, 8, 6, 4, 9}; int b[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}; int main(int argc, char** argv) { map\u0026lt;int,int\u0026gt;c; map\u0026lt;int,int\u0026gt;::iterator it; for(int i=0; i\u0026lt;10; i++) c[a[i]] = b[i]; for(it=c.begin(); it!=c.end(); it++) cout\u0026lt;\u0026lt;it-\u0026gt;second\u0026lt;\u0026lt;\u0026#34; \u0026#34;; return 0; } U:编程填空：去除重复元素排序 描述 程序填空，使其按要求输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iterator\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { int t; int a[100]; cin \u0026gt;\u0026gt; t; while(t--) { for(int i = 0;i \u0026lt; 12; ++i) cin \u0026gt;\u0026gt; a[i]; // 在此处补充你的代码 std::copy(b.begin(), b.end(), c); cout \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是个整数，表示输入数据组数\n每组数据一行,有12个整数\n输出 对每组数据, 将12个整数从小到大排序并去除重复元素后输出\n样例输入 1 2 3 2 34 5 4 6 3 9 8 34 5 3 3 18 31 2 4 6 2 9 8 31 5 3 3 18 样例输出 1 2 3 4 5 6 8 9 18 34 2 3 4 5 6 8 9 18 31 提示 注意：行末都有一个空格\nSolution 这里肯定是要求我们使用一个数据结构b\n这里傻傻地用了vector，但事实上，set应该也可以，还更方便\ncopy表示将一个范围中的元素赋值到另一个范围中，那么，如果我们将其赋值到一个ostream型变量中，它就会自动输出\n但是，这里的ostream_iterator很少见，我们可以记一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iterator\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { int t; int a[100]; cin \u0026gt;\u0026gt; t; while(t--) { for(int i = 0;i \u0026lt; 12; ++i) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;int\u0026gt;b; for(int i=0;i\u0026lt;12;i++){ b.push_back(a[i]); } sort(b.begin(),b.end()); auto las=unique(b.begin(),b.end()); b.erase(las,b.end()); ostream_iterator\u0026lt;int\u0026gt;c(cout,\u0026#34; \u0026#34;); std::copy(b.begin(), b.end(), c); cout \u0026lt;\u0026lt; endl; } return 0; } V:前k大的偶数 描述 输入n个整数，输出整数数列中大小排名前k的偶数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; class MyQueue { // 在此处补充你的代码 }; int main() { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; MyQueue q(k); for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; q; cout\u0026lt;\u0026lt;q; cout \u0026lt;\u0026lt; endl; } return 0; } 输入 有多组数据\n第一行是数据组数 t\n对每组数据：\n第一行为整数n (n\u0026gt;=3)和k\n接下来的一行为n个整数，保证这些整数中至少有k个偶数。\n输出 对每组数据，输出k个整数，降序排列，表示选出来的大小排名前k的偶数\n样例输入 1 2 3 4 5 2 9 4 1 2 4 3 6 6 7 8 9 3 2 18 16 14 样例输出 1 2 8 6 6 4 18 16 Solution 这道题看到输出前k肯定想的是优先队列\n然后，还要求降序排列，我们需要一个临时存储容器\n这样就完了\n注意:优先队列默认大根堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; class MyQueue { private: int tot,cnt; public: priority_queue\u0026lt;int\u0026gt;q; MyQueue(int x){ tot=x; cnt=0; } friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is,MyQueue \u0026amp;t){ int dd; is\u0026gt;\u0026gt;dd; if(dd%2) return is; else{ t.q.push(-dd); t.cnt++; if(t.cnt\u0026gt;t.tot) t.q.pop(); return is; } } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,MyQueue \u0026amp;t){ vector\u0026lt;int\u0026gt;a; while(!t.q.empty()){ int x=-t.q.top(); t.q.pop(); a.push_back(x); } for(auto it=a.end()-1;it\u0026gt;=a.begin();it--){ os\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } return os; } }; int main() { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n, k; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; MyQueue q(k); for (int i = 0; i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; q; cout\u0026lt;\u0026lt;q; cout \u0026lt;\u0026lt; endl; } return 0; } W:编程填空:Three Sum 描述 给出一列备选整数，请问能否在其中选出三个（不能重复选取），使得它们的和等于一个给定数字呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;set\u0026gt; using namespace std; multiset\u0026lt;int\u0026gt; s; int a[5000 + 5]; int main() { int n, T, k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { s.clear(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i ++) { scanf(\u0026#34;%d\u0026#34;, a + i); s.insert(a[i]); } bool flag = false; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); for (int i = 0; i \u0026lt; n; i ++) { for (int j = i + 1; j \u0026lt; n; j ++) { int target = k - a[i] - a[j], min_count = 1; // 在此处补充你的代码 } if (flag) break; } puts(flag? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); } } 输入 输入包括多组测试数据。第一行一个整数T(1\u0026lt;=T\u0026lt;=20)，表示测试数据数量。\n接下来T组测试数据分别输入，对于每组测试数据，第一行一个整数n(1\u0026lt;=n\u0026lt;=1000)，表示给出备选数字的个数；第二行n个用空格隔开的整数ai(-310^8\u0026lt;=ai\u0026lt;=310^8)，表示备选数字列表；第三行一个整数k(-10^9\u0026lt;=k\u0026lt;=10^9)，表示希望组合的数字。\n输出 对于每组测试数据输出一行答案，如果能够选出三个数合成k，请输出\u0026quot;Yes\u0026quot;(不含引号)，否则输出\u0026quot;No\u0026quot;.\n样例输入 1 2 3 4 5 6 7 8 9 10 11 12 13 4 10 1 2 3 4 5 6 7 8 9 10 8 10 1 2 3 4 5 6 7 8 9 10 5 4 1 1 1 1 3 4 1 2 9 10 4 样例输出 1 2 3 4 Yes No Yes No Solution 至于这里已经给出明显思路了，那么，我们直接查找不就行了吗，不解释了\n其实这里好像应该用set，严格意义的话\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;set\u0026gt; using namespace std; multiset\u0026lt;int\u0026gt; s; int a[5000 + 5]; int main() { int n, T, k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { s.clear(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 0; i \u0026lt; n; i ++) { scanf(\u0026#34;%d\u0026#34;, a + i); s.insert(a[i]); } bool flag = false; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); for (int i = 0; i \u0026lt; n; i ++) { for (int j = i + 1; j \u0026lt; n; j ++) { int target = k - a[i] - a[j], min_count = 1; if(s.find(target)!=s.end()){ flag=true; } } if (flag) break; } puts(flag? \u0026#34;Yes\u0026#34;: \u0026#34;No\u0026#34;); } } X:编程填空：排队看医生 描述 看病要排队是地球人都知道的常识。不过细心的Rainbow观察发现，医院里排队还是有讲究的：Rainbow所去的医院有三个医生同时看病。而看病的人病情有轻重，所以不能根据简单的先来先服务的原则。所以医院对每种病情规定了10种不同的优先级。级别为10的优先权最高，级别为1的优先权最低。医生在看病时，则会在他的队伍里面选择一个优先权最高的人进行诊治。如果遇到两个优先权一样的病人的话，则选择最早来排队的病人。\n现在，请你来模拟一下这个看病的过程吧！\n输入 输入数据包含多组测试。第一行一个整数T(1\u0026lt;=T\u0026lt;=20)，表示测试数据数目。\n每组数据第一行有一个正整数N(1\u0026lt;=N\u0026lt;=20000)表示发生事件的数目。\n接下来有N行分别表示发生的事件。\n一共有两种事件：\nIN A B,表示有一个拥有优先级B的病人要求医生A诊治。(1\u0026lt;=A\u0026lt;=3, 1\u0026lt;=B\u0026lt;=10)\nOUT A,表示医生A进行了一次诊治，诊治完毕后，病人出院。(1\u0026lt;=A\u0026lt;=3)\n输出 对于每个”OUT A”事件，请在一行里面输出被诊治人的编号ID。如果该事件时无病人需要诊治，则输出”EMPTY”。\n诊治人的编号ID的定义为：在一组测试中，”IN A B”事件发生第K次时，进来的病人ID即为K。从1开始编号。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 12 2 7 IN 1 1 IN 1 2 OUT 1 OUT 2 IN 2 1 OUT 2 OUT 1 2 IN 1 1 OUT 1 样例输出 1 2 3 4 5 2 EMPTY 3 1 1 Solution 一开始题目看错了，ID的定义不对\n肯定是要用优先队列来的\n然后？就没有然后了\n挺有OI味的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; int t,n; string x; struct node{ int id,se; bool operator\u0026lt;(node x)const{ if(x.se==se) return id\u0026gt;x.id; else return se\u0026lt;x.se; } }; int num; int a,b; priority_queue\u0026lt;node\u0026gt;q[4]; int main(){ cin\u0026gt;\u0026gt;t; while(t--){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=3;i++){ while(!q[i].empty()){ q[i].pop(); } num=0; } for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; if(x==\u0026#34;IN\u0026#34;){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; num++; q[a].push(node{num,b}); } else{ cin\u0026gt;\u0026gt;a; if(q[a].empty()){ cout\u0026lt;\u0026lt;\u0026#34;EMPTY\u0026#34;\u0026lt;\u0026lt;endl; continue; } else{ node k=q[a].top();q[a].pop(); cout\u0026lt;\u0026lt;k.id\u0026lt;\u0026lt;endl; continue; } } } } system(\u0026#34;pause\u0026#34;); return 0; } Y:宠物小精灵 描述 宠物小精灵的世界中，每位训练师都在收集自己的小精灵。但是，训练师的背包里只能同时携带6只小精灵。如果一位训练师抓到了更多的精灵，那么最早抓到的精灵将被自动传送到电脑中，保证持有的小精灵数量依然是6只。 训练师也可以随时从电脑中取出精灵，取出的精灵将从电脑中传送到训练师的背包里。取出的精灵同样被认为是最新的，导致背包中最早取出或抓到的精灵被替换到电脑中，训练师持有的精灵数量依然是6只。 初始状态下，所有训练师的背包中都没有小精灵，电脑中也没有任何训练师的精灵。\n输入 输入数据包含多组测试。第一行一个整数T(1\u0026lt;=T\u0026lt;=20)，表示测试数据数目。\n每组数据第一行有一个正整数N(1\u0026lt;=N\u0026lt;=20000)表示发生事件的数目。\n接下来有N行分别表示发生的事件。\n一共有两种事件：\nC X, Y 表示训练师X抓到了精灵Y\nT X, Y 表示训练师X试图从电脑中取出精灵Y。\nX和Y都是长度在20以下的由字母或数字构成的字符串。\n小精灵的世界中同样存在着作恶多端的火箭队。他们试图利用电脑的漏洞，从电脑中取出本不属于自己的小精灵。因此，电脑需要识别并拒绝取出这种请求。注意，如果一只小精灵仅存在于训练师的背包中而未被传送至电脑，该训练师也不能取出这只精灵。相同训练师不会多次抓到相同名字的精灵。\n输出 对于每次从电脑中取出小精灵的请求，输出一行。成功则输出Success，失败则输出Failed。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 1 10 C satoshi pikachu1 C satoshi pikachu2 C satoshi pikachu3 C satoshi pikachu4 C satoshi pikachu5 C satoshi pikachu6 C satoshi pikachu7 T satoshi pikachu2 T satoshi pikachu1 T pikachu pikachu2 样例输出 1 2 3 Failed Success Failed Solution 多测记得清空！\n这个肯定要用队列表示的，外部是map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; int t,n; map\u0026lt;string,queue\u0026lt;string\u0026gt;\u0026gt;ma; map\u0026lt;string,int\u0026gt;cnt; map\u0026lt;string,set\u0026lt;string\u0026gt;\u0026gt;computer; char op; string x,y; int main(){ cin\u0026gt;\u0026gt;t; while(t--){ ma.clear(); cnt.clear(); computer.clear(); cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;op; if(op==\u0026#39;C\u0026#39;){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cnt[x]++; ma[x].push(y); if(cnt[x]\u0026gt;=7){ cnt[x]--; string temp=ma[x].front(); ma[x].pop(); computer[x].insert(temp); } } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(ma.find(x)!=ma.end()\u0026amp;\u0026amp;computer[x].find(y)!=computer[x].end()){ cout\u0026lt;\u0026lt;\u0026#34;Success\u0026#34;\u0026lt;\u0026lt;endl; auto it=computer[x].find(y); computer[x].erase(it); ma[x].push(y); cnt[x]++; if(cnt[x]\u0026gt;=7){ cnt[x]--; string temp=ma[x].front(); ma[x].pop(); computer[x].insert(temp); } } else{ cout\u0026lt;\u0026lt;\u0026#34;Failed\u0026#34;\u0026lt;\u0026lt;endl; } } } } system(\u0026#34;pause\u0026#34;); return 0; } Z:石油交易 描述 原油期货价格暴跌，甚至出现了负油价。有很多卖家想要低价卖出手中囤积的石油，同时也有部分买家想要低价抄底。\n每位卖家和买家按时间顺序在交易平台依次发布交易信息。他们的交易流程如下：\n卖家在交易平台发布自己希望卖出的石油桶数X， 以及这X桶石油每桶报价Y。当买家希望购买Z桶石油时，会从当前交易平台所有在售的石油中购买价格最低的Z桶， 但无法购买在其之后的卖家发布的石油。如果在买家购买Z桶石油之时，没有足够的石油在售，则不足的部分将按每桶40美元的价格购买， 所有卖家的价格均低于40美元。\n现在请计算每位买家购买石油的总价。\n输入 输入数据的第一行是一个正整数N(N \u0026lt; 100000)，表明买卖信息的总数目。\n接下来N行分别表示买卖的信息。\n一共有两种信息：\nSELL X Y，表示卖家希望卖出X桶石油，每桶价格为Y美元。\nBUY Z，表示买家买入Z桶石油。\n0 \u0026lt; X，Z \u0026lt;= 10000。Y为整数。结果保证在INT范围内。\n输出 对于每次买入石油的信息，输出一个正整数，表示该买家当次买入石油的总价。\n样例输入 1 2 3 4 5 6 7 6 BUY 5 SELL 10 10 BUY 5 SELL 10 5 BUY 5 BUY 15 样例输出 1 2 3 4 200 50 25 275 Solution 这道题唯一要注意的点就是，当我们erase一个元素之后，迭代器会直接指向下一个元素，因此，不需要执行++操作\n这点调了一晚上ww\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; string x; ll cnt=0;//库存 multimap\u0026lt;int,int\u0026gt;ma; int n; int a,b; ll tot=0; int main(){ cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;x; if(x==\u0026#34;BUY\u0026#34;){ cin\u0026gt;\u0026gt;a; ll ans=0; for(auto it=ma.begin();it!=ma.end();){ if(a\u0026lt;=0) break; if(it-\u0026gt;second\u0026lt;=a){ a-=it-\u0026gt;second; ans+=it-\u0026gt;second*it-\u0026gt;first; tot-=it-\u0026gt;second*it-\u0026gt;first; cnt-=it-\u0026gt;second; it=ma.erase(it); } else{ ans+=it-\u0026gt;first*a; it-\u0026gt;second-=a; tot-=a*it-\u0026gt;first; cnt-=a; a=0; } } if(a\u0026gt;0) ans+=a*40; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } else if(x==\u0026#34;SELL\u0026#34;){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; ma.insert(make_pair(b,a)); cnt+=a; tot+=a*b; } } system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2025-05-09T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E6%9C%9F%E4%B8%ADc-%E9%83%A8%E5%88%86%E8%A1%A5%E5%85%85%E9%A2%98%E4%B8%80/","title":"【程序设计实习】期中C++部分补充题一"},{"content":"A:高阶函数F(x) 描述 lisp语言中有高阶函数的概念，即函数可以作为函数的参数，也可以作为函数的返回值。例如:\n(define (f n) (lambda (x) (+ x n)))\n定义了一个函数f，该函数的返回值是另一个函数，假定称为g即 (lambda (x) (+ x n) 此函数功能是参数为x，返回值为x + n。 于是 ((f 7) 9) 如下执行\n(f 7)以参数7调用f, f的返回值是g,n的值为7\n((f 7) 9)等价于 (g 9)，即以参数9调用g。 因 n = 7, x = 9 ,因此(g 9)返回值为16\n编写一个C++的通用函数模板f,使之能完成类似于lisp函数f的功能。 对于下面的程序，输出结果是\n16 world hello! world!\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; // 在此处补充你的代码 int main() { cout \u0026lt;\u0026lt; f\u0026lt;int,int\u0026gt;(7)(9) \u0026lt;\u0026lt; endl; //16 cout \u0026lt;\u0026lt; f\u0026lt;string,string\u0026gt; (\u0026#34; hello!\u0026#34;)(\u0026#34;world\u0026#34;) \u0026lt;\u0026lt;endl; // world hello! cout \u0026lt;\u0026lt; f\u0026lt;char,string\u0026gt; (\u0026#39;!\u0026#39;)(\u0026#34;world\u0026#34;) \u0026lt;\u0026lt; endl; return 0; //world! } 输入 无\n输出 16 world hello! world!\n样例输入 1 无 样例输出 1 2 3 16 world hello! world! 提示 C++函数模板实例化时，也可以通过在\u0026lt;\u0026gt;中指定类型参数所对应的具体类型来实现。\nSolution 其实不要管题目给的背景，知道是后面的加前面的，然后直接用仿函数重载()即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T1,class T2\u0026gt; class f{ private: T1 x; public: f(T1 k):x(k) { } T2 operator()(T2 k){ return k+x; } }; int main() { cout \u0026lt;\u0026lt; f\u0026lt;int,int\u0026gt;(7)(9) \u0026lt;\u0026lt; endl; //16 cout \u0026lt;\u0026lt; f\u0026lt;string,string\u0026gt; (\u0026#34; hello!\u0026#34;)(\u0026#34;world\u0026#34;) \u0026lt;\u0026lt;endl; // world hello! cout \u0026lt;\u0026lt; f\u0026lt;char,string\u0026gt; (\u0026#39;!\u0026#39;)(\u0026#34;world\u0026#34;) \u0026lt;\u0026lt; endl; return 0; //world! } B:高阶函数Combine 描述 Lisp语言中有高阶函数的概念，即函数可以作为函数的参数，也可以作为函数的返回值。例如:\n(define (square x) (* xx)) 定义了一个求x的平方的函数\n(define (inc x) (+ x1)) 定义了一个求x+1的函数\n(define (combine f g) (lambda (x) (f (+ (fx) (g x)))))\n(combine f g) 返回函数k , k(x) = f( f(x)+g(x))\n因此 ((combine square inc) 3) 的返回值就是169\n此处\nf(x) = x*x g(x) = x + 1\nk(x) = (x*x+(x+1)) ^2\n((combine square inc) 3) 即是 k(3)\n因此返回值为169 用C++实现类似的combine函数模板，使得下面的程序输出结果为\n169 10.75\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; // 在此处补充你的代码 int main() { auto Square = [] (double a) { return a * a; }; auto Inc = [] (double a) { return a + 1; }; cout \u0026lt;\u0026lt; combine\u0026lt;decltype(Square),decltype(Inc),int\u0026gt;(Square,Inc)(3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; combine\u0026lt;decltype(Inc),decltype(Square),double\u0026gt;(Inc,Square)(2.5) \u0026lt;\u0026lt; endl; return 0; } 输入 无\n输出 169 10.75\n样例输入 1 无 样例输出 1 2 169 10.75 提示 C++函数模板实例化时，也可以通过在\u0026lt;\u0026gt;中指定类型参数所对应的具体类型来实现。\nSolition 这题跟C++11有关的也就是auto，显而易见的lambda函数和一个需要一点感觉的仿函数模板？\n哦还有这个，decltype的几个规则，总之知道它这里返回的就是函数指针，指向某个lambda函数\n然后，这个Combine类有三个变量类型，完了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; template\u0026lt;class T1,class T2,class T3\u0026gt; class combine{ private: T1 a; T2 b; public: combine(T1 x,T2 y):a(x),b(y) { } T3 operator()(T3 x){ return a(a(x)+b(x)); } }; int main() { auto Square = [] (double a) { return a * a; }; auto Inc = [] (double a) { return a + 1; }; cout \u0026lt;\u0026lt; combine\u0026lt;decltype(Square),decltype(Inc),int\u0026gt;(Square,Inc)(3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; combine\u0026lt;decltype(Inc),decltype(Square),double\u0026gt;(Inc,Square)(2.5) \u0026lt;\u0026lt; endl; return 0; } C:自己实现bitset 描述 程序填空，实现一个类似STL bitset的 MyBitset, 输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;int bitNum\u0026gt; struct MyBitset { char a[bitNum/8+1]; MyBitset() { memset(a,0,sizeof(a));}; void Set(int i,int v) { char \u0026amp; c = a[i/8]; int bp = i % 8; if( v ) c |= (1 \u0026lt;\u0026lt; bp); else c \u0026amp;= ~(1 \u0026lt;\u0026lt; bp); } // 在此处补充你的代码 void Print() { for(int i = 0;i \u0026lt; bitNum; ++i) cout \u0026lt;\u0026lt; (*this) [i]; cout \u0026lt;\u0026lt; endl; } }; int main() { int n; int i,j,k,v; while( cin \u0026gt;\u0026gt; n) { MyBitset\u0026lt;20\u0026gt; bs; for(int i = 0;i \u0026lt; n; ++i) { int t; cin \u0026gt;\u0026gt; t; bs.Set(t,1); } bs.Print(); cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; bs[k] = v; bs[i] = bs[j] = bs[k]; bs.Print(); cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; bs[k] = v; (bs[i] = bs[j]) = bs[k]; bs.Print(); } return 0; } 输入 多组数据\n每组数据：\n第一行是整数 n , 1 \u0026lt;= n \u0026lt; 20;\n第二行是n个整数 k1,k2\u0026hellip; kn,均在范围 [0,19]内。\n第三行是 四个整数 i1,j1,k1,v1 。 0 \u0026lt;= i1,j1,k1 \u0026lt;= 19, v1值为0或1\n第三行是 四个整数 i2,j2,k2,v2 。 0 \u0026lt;= i2,j2,k2 \u0026lt;= 19, v2值为0或1\n输出 对每组数据，共输出3行，每行20位，每位为1或者0。最左边称为第0位\n第一行： 第 k1,k2 \u0026hellip; kn位为1，其余位为0。\n第二行： 将第一行中的第 i1,j1,k1位变为 v1,其余位不变\n第三行： 将第二行中的第i2位和k2位变为v2，其余位不变\n样例输入 1 2 3 4 5 6 7 8 4 0 1 2 8 7 19 0 1 7 2 8 0 1 1 1 1 1 0 1 1 1 1 样例输出 1 2 3 4 5 6 11100000100000000000 11100001100000000001 11100000000000000001 01000000000000000000 00000000000000000000 01000000000000000000 提示 推荐使用内部类，内部类中使用引用成员。引用成员要在构造函数中初始化。\nSolution 这题有抖机灵做法，如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;int bitNum\u0026gt; struct MyBitset { char a[bitNum/8+1]; MyBitset() { memset(a,0,sizeof(a));}; void Set(int i,int v) { char \u0026amp; c = a[i/8]; int bp = i % 8; if( v ) c |= (1 \u0026lt;\u0026lt; bp); else c \u0026amp;= ~(1 \u0026lt;\u0026lt; bp); } int myb[20]; bool flag=false; void transform(){ memset(myb,0,sizeof(myb)); for(int i=0;i\u0026lt;=bitNum/8+1;i++){ int temp=i*8; int num=(unsigned char)(a[i]); while(num\u0026gt;0){ if(num%2) myb[temp]++; temp++; num/=2; } } flag=true; } int \u0026amp;operator[](int x){ if(!flag) transform(); return myb[x]; } void Print() { for(int i = 0;i \u0026lt; bitNum; ++i) cout \u0026lt;\u0026lt; (*this) [i]; cout \u0026lt;\u0026lt; endl; } }; int main() { int n; int i,j,k,v; while( cin \u0026gt;\u0026gt; n) { MyBitset\u0026lt;20\u0026gt; bs; for(int i = 0;i \u0026lt; n; ++i) { int t; cin \u0026gt;\u0026gt; t; bs.Set(t,1); } bs.Print(); cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; bs[k] = v; bs[i] = bs[j] = bs[k]; bs.Print(); cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j \u0026gt;\u0026gt; k \u0026gt;\u0026gt; v; bs[k] = v; (bs[i] = bs[j]) = bs[k]; bs.Print(); } return 0; } ","date":"2025-04-30T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0c-11%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%BD%9C%E4%B8%9A/","title":"【程序设计实习】C++11高级特性作业"},{"content":"01:编程填空：字符串排序 描述 请按照要求对输入的字符串进行排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; class A{ private: string name; public: A(string n) :name(n){} friend bool operator \u0026lt; (const class A\u0026amp; a1, const class A \u0026amp;a2); friend bool operator == (const class A \u0026amp;a1, const class A \u0026amp;a2){ if (a1.name.size() == a2.name.size()) return true; else return false; } friend ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;o, const A \u0026amp;a){ o \u0026lt;\u0026lt; a.name; return o; } string get_name() const{ return name; } int get_size() const{ return name.size(); } }; // 在此处补充你的代码 int main(int argc, char* argv[]) { list\u0026lt;A\u0026gt; lst; int ncase, n, i = 1; string s; cin \u0026gt;\u0026gt; ncase; while (ncase--){ cout \u0026lt;\u0026lt; \u0026#34;Case: \u0026#34;\u0026lt;\u0026lt;i++ \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; s; lst.push_back(A(s)); } lst.sort(); Show(lst.begin(), lst.end(), Print()); cout \u0026lt;\u0026lt; endl; lst.sort(MyLarge\u0026lt;A\u0026gt;()); Show(lst.begin(), lst.end(), Print()); cout \u0026lt;\u0026lt; endl; lst.clear(); } return 0; } 输入 第一行是正整数T，表示测试数据的组数\n每组测试数据输入共两行，\n第一行是正整数N，表示字符串个数\n第二行是N个字符串, 字符串间用空格分离\n输出 对于每组测试数据，先输出一行：\nCase: n 如对第一组数据就输出Case: 1\n第二行按照字符串长度从小到大排序之后输出N个字符串，字符串之间以空格间隔（不会出现字符串长度相同的情况）\n第三行按照字符串首字符ASCII码序从小到大排序之后输出N个字符串，字符串之间以空格间隔（不会出现字符串首字母相同的情况）\n样例输入 1 2 3 4 5 2 4 a bnss ds tsdfasg 5 aaa bbbb ccccd sa q 样例输出 1 2 3 4 5 6 Case: 1 a ds bnss tsdfasg a bnss ds tsdfasg Case: 2 q sa aaa bbbb ccccd aaa bbbb ccccd q sa Solution 这里我们可以看到，题目中给了我们get_name和get_size两个函数，那就把它用起来吧\n同时从友元看出，需要我们重载\u0026lt;这个运算符\n同时，需要写出一个MyLarge的模板类\n然后，还需要写出show和print两个函数\n最大意的地方在于之前忘记模板类的对象可以通过重载()运算符来仿函数，所以卡了一会\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; class A{ private: string name; public: A(string n) :name(n){} friend bool operator \u0026lt; (const class A\u0026amp; a1, const class A \u0026amp;a2); friend bool operator == (const class A \u0026amp;a1, const class A \u0026amp;a2){ if (a1.name.size() == a2.name.size()) return true; else return false; } friend ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;o, const A \u0026amp;a){ o \u0026lt;\u0026lt; a.name; return o; } string get_name() const{ return name; } int get_size() const{ return name.size(); } }; bool operator\u0026lt;(const class A\u0026amp; a1,const class A\u0026amp; a2){ return a1.get_size()\u0026lt;a2.get_size(); } template\u0026lt;class T\u0026gt; struct MyLarge{ bool operator()(const T\u0026amp; a1,const T\u0026amp; a2){ return a1.get_name()\u0026lt;a2.get_name(); } }; template\u0026lt;class T1,class T2\u0026gt; void Show(T1 x,T1 y,T2 f){ for(auto it=x;it!=y;it++){ f(*it); } } struct Print{ void operator()(const A\u0026amp; a)const{ cout\u0026lt;\u0026lt;a.get_name()\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } }; int main(int argc, char* argv[]) { list\u0026lt;A\u0026gt; lst; int ncase, n, i = 1; string s; cin \u0026gt;\u0026gt; ncase; while (ncase--){ cout \u0026lt;\u0026lt; \u0026#34;Case: \u0026#34;\u0026lt;\u0026lt;i++ \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++){ cin \u0026gt;\u0026gt; s; lst.push_back(A(s)); } lst.sort(); Show(lst.begin(), lst.end(), Print()); cout \u0026lt;\u0026lt; endl; lst.sort(MyLarge\u0026lt;A\u0026gt;()); Show(lst.begin(), lst.end(), Print()); cout \u0026lt;\u0026lt; endl; lst.clear(); } return 0; } 02:按距离排序 描述 程序填空，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T1,class T2\u0026gt; struct Closer { // 在此处补充你的代码 }; int Distance1(int n1,int n2) { return abs(n1-n2); } int Distance2(const string \u0026amp; s1, const string \u0026amp; s2) { return abs((int)s1.length()- (int) s2.length()); } int a[10] = { 0,3,1,4,7,9,20,8,10,15}; string b[6] = {\u0026#34;American\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;To\u0026#34;,\u0026#34;Peking\u0026#34;,\u0026#34;abcdefghijklmnop\u0026#34;,\u0026#34;123456789\u0026#34;}; int main() { int n;string s; while( cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s ) { sort(a,a+10,Closer\u0026lt;int ,int (*)(int ,int)\u0026gt; (n,Distance1)); for(int i = 0;i \u0026lt; 10; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; sort(b,b+6,Closer\u0026lt;string,int (*)(const string \u0026amp;,const string \u0026amp; )\u0026gt; (s,Distance2)); for(int i = 0;i \u0026lt; 6; ++i) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } return 0; } 输入 多组数据，每组一行，是一个整数n和一个字符串s\n输出 定义两个整数的距离为两个整数差的绝对值\n定义两个字符串的距离为两个字符串长度差的绝对值\n对每组数据：\n对数组a按和n的距离从小到大排序后输出。距离相同的，值小的排在前面。\n然后对数组b，按照和s的距离从小到大输出。距离相同的，字典序小的排在前面\n样例输入 1 2 2 a123456 4 a12345 样例输出 1 2 3 4 1,3,0,4,7,8,9,10,15,20, American,Peking,123456789,Jack,To,abcdefghijklmnop, 4,3,1,7,0,8,9,10,15,20, Peking,American,Jack,123456789,To,abcdefghijklmnop, Solution 我们确实大意了，函数可以作为模板类的一个对象，如果知道了就好说了，直接重载()即可\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T1,class T2\u0026gt; struct Closer { T1 z; T2 f; Closer(T1 a,T2 b):z(a),f(b) { } bool operator()(T1 x,T1 y){ if(f(x,z)==f(y,z)) return x\u0026lt;y; return f(x,z)\u0026lt;f(y,z); } }; int Distance1(int n1,int n2) { return abs(n1-n2); } int Distance2(const string \u0026amp; s1, const string \u0026amp; s2) { return abs((int)s1.length()- (int) s2.length()); } int a[10] = { 0,3,1,4,7,9,20,8,10,15}; string b[6] = {\u0026#34;American\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;To\u0026#34;,\u0026#34;Peking\u0026#34;,\u0026#34;abcdefghijklmnop\u0026#34;,\u0026#34;123456789\u0026#34;}; int main() { int n;string s; while( cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s ) { sort(a,a+10,Closer\u0026lt;int ,int (*)(int ,int)\u0026gt; (n,Distance1)); for(int i = 0;i \u0026lt; 10; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; sort(b,b+6,Closer\u0026lt;string,int (*)(const string \u0026amp;,const string \u0026amp; )\u0026gt; (s,Distance2)); for(int i = 0;i \u0026lt; 6; ++i) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } return 0; } 03:回调函数 描述 输入x1 x2 x3 x4 x5 ，输出y = x5^5 + x4^4 + x3^3 + x2^2 + x1^1 + 1的y的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; class MyFunc { // 在此处补充你的代码 }; int main() { int n; cin \u0026gt;\u0026gt; n; while(n--) { vector\u0026lt;MyFunc\u0026gt; v; for (int i = 0; i \u0026lt; 5; ++i) v.push_back(MyFunc(i+1)); int ans = 1; for (int i = 0; i \u0026lt; 5; ++i) { int m; cin \u0026gt;\u0026gt; m; ans += v[i](m); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt;endl; } } 输入 多组数据。第一行是数据组数 n\n每组数据为一行,5个整数，x1 x2 x3 x4 x5。数值不大，不必考虑溢出\n输出 对每组数据，输出一个整数y， y = x5^5 + x4^4 + x3^3 + x2^2 + x1^1 + 1\n样例输入 1 2 3 2 2 2 2 2 2 1 1 1 1 1 样例输出 1 2 63 6 Solution 这道题就是要求我们重载出一个仿函数，然后这个仿函数作为一个类对象被加入vector中然后狗作用于m，所以，我们只需要重载一个()即可\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; class MyFunc { int p; public: MyFunc(int x):p(x) { } int operator()(int x){ return pow(x,p); } }; int main() { int n; cin \u0026gt;\u0026gt; n; while(n--) { vector\u0026lt;MyFunc\u0026gt; v; for (int i = 0; i \u0026lt; 5; ++i) v.push_back(MyFunc(i+1)); int ans = 1; for (int i = 0; i \u0026lt; 5; ++i) { int m; cin \u0026gt;\u0026gt; m; ans += v[i](m); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt;endl; } } 04:编程填空:Printer 描述 完成以下程序，使得输入的整数x，以及若干正整数，将大于x的正整数输出；\n然后输入若干字符串，将字符串长度大于x的字符串输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;bitset\u0026gt; using namespace std; class Printer{ // 在此处补充你的代码 int main(){ int t; cin \u0026gt;\u0026gt; t; while(t--) { int n,x; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; intVec; for(int i = 0;i \u0026lt; n; ++i) { int y; cin \u0026gt;\u0026gt; y; intVec.push_back(y); } for_each(intVec.begin(), intVec.end(), Printer(x)); cout\u0026lt;\u0026lt;endl; vector\u0026lt;string\u0026gt; strVec; for(int i = 0;i \u0026lt; n; ++i) { string str; cin \u0026gt;\u0026gt; str; strVec.push_back(str); } for_each(strVec.begin(), strVec.end(), Printer(x)); cout\u0026lt;\u0026lt;endl; } return 0; } 输入 第一行是整数t，表示一共t组数据\n每组数据有三行\n第一行是整数x和整数 n\n第二行是n个整数\n第三行是n个不带空格的字符串\n输出 对每组数据\n先按原序输出第一行中大于x的正整数(数据保证会有输出）\n再按原序输出第二行中长度大于x的字符串 (数据保证会有输出）\n样例输入 1 2 3 4 5 6 7 2 5 6 1 3 59 30 2 40 this is hello please me ha 1 1 4 this 样例输出 1 2 3 4 59,30,40, please, 4, this, Solution 本题没有为我们准备模板类\n而且对于string和int两个类的判断函数是不一样的\n所以，我们需要重载两次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;bitset\u0026gt; using namespace std; class Printer{ private: int p; public: Printer(int x):p(x) { } void operator()(int x){ if(x\u0026gt;p) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39;,\u0026#39;; } void operator()(string x){ if(x.length()\u0026gt;p) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39;,\u0026#39;; } }; int main(){ int t; cin \u0026gt;\u0026gt; t; while(t--) { int n,x; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; intVec; for(int i = 0;i \u0026lt; n; ++i) { int y; cin \u0026gt;\u0026gt; y; intVec.push_back(y); } for_each(intVec.begin(), intVec.end(), Printer(x)); cout\u0026lt;\u0026lt;endl; vector\u0026lt;string\u0026gt; strVec; for(int i = 0;i \u0026lt; n; ++i) { string str; cin \u0026gt;\u0026gt; str; strVec.push_back(str); } for_each(strVec.begin(), strVec.end(), Printer(x)); cout\u0026lt;\u0026lt;endl; } return 0; } 05:矩阵排序 描述 创建矩阵类，要求能够输入整数类型的m*n矩阵，并按照元素个数，矩阵中元素之和，创建矩阵顺序对矩阵类分别排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class Mat{ int h,w; public: Mat(int height,int width):h(height),w(width) // 在此处补充你的代码 int main() { vector\u0026lt;Mat\u0026gt; m; m.push_back(Mat(2,2)); m.push_back(Mat(3,4)); m.push_back(Mat(2,2)); cin \u0026gt;\u0026gt; m[0] \u0026gt;\u0026gt; m[1] \u0026gt;\u0026gt; m[2]; sort(m.begin(),m.end()); cout\u0026lt;\u0026lt; m[0] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[2] \u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*************\u0026#34;\u0026lt;\u0026lt;endl; sort(m.begin(),m.end(),comparator_1); cout\u0026lt;\u0026lt; m[0] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[2] \u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*************\u0026#34;\u0026lt;\u0026lt;endl; sort(m.begin(),m.end(),comparator_2()); cout\u0026lt;\u0026lt; m[0] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[2] \u0026lt;\u0026lt;endl; return 0; } 输入 前两行是一个22矩阵\n之后三行是一个34矩阵\n最后两行是一个2*2矩阵\n输出 先按照元素个数从小到大输出三个矩阵（大小相同时后创建的矩阵先输出）\n再按照元素之和从小到大输出三个矩阵（大小相同时后创建的矩阵先输出）\n再按照矩阵创建顺序从先到后输出三个矩阵\n（矩阵排列方式与输入相同，每个元素后用一个空格进行分隔）\n样例输入 1 2 3 4 5 6 7 2 3 3 4 0 12 -3 -4 -2 2 -1 0 -1 -1 -1 -1 -1 3 -2 4 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 -1 3 -2 4 2 3 3 4 0 12 -3 -4 -2 2 -1 0 -1 -1 -1 -1 ************* 0 12 -3 -4 -2 2 -1 0 -1 -1 -1 -1 -1 3 -2 4 2 3 3 4 ************* 2 3 3 4 0 12 -3 -4 -2 2 -1 0 -1 -1 -1 -1 -1 3 -2 4 Solution 其实是简单的矩阵题，然后重载输入输出和一个判断函数和一个模板判断函数，最后，输入顺序我们用一个静态成员变量表示，就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class Mat{ int h,w; public: Mat(int height,int width):h(height),w(width) { p=new int[h*w]; k++; id=k; tot=h*w; sum=0; } int* p; int id; int sum; int tot; static int k; bool operator\u0026lt;(const Mat \u0026amp;x){ if(tot==x.tot) return id\u0026gt;x.id; return tot\u0026lt;x.tot; } friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is,Mat x){ for(int i=0;i\u0026lt;=x.h-1;i++){ for(int j=0;j\u0026lt;=x.w-1;j++){ is\u0026gt;\u0026gt;x.p[i*x.w+j]; } } for(int i=0;i\u0026lt;x.h*x.w;i++) x.sum+=x.p[i]; return is; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,Mat x){ for(int i=0;i\u0026lt;=x.h-1;i++){ for(int j=0;j\u0026lt;=x.w-1;j++){ os\u0026lt;\u0026lt;x.p[i*x.w+j]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } os\u0026lt;\u0026lt;endl; } return os; } }; int Mat::k=0; bool comparator_1(Mat x,Mat y){ for(int i=0;i\u0026lt;x.tot;i++) x.sum+=x.p[i]; for(int i=0;i\u0026lt;y.tot;i++) y.sum+=y.p[i]; if(x.sum==y.sum) return x.id\u0026gt;y.id; return x.sum\u0026lt;y.sum; } struct comparator_2{ bool operator()(Mat x,Mat y){ return x.id\u0026lt;y.id; } }; int main() { vector\u0026lt;Mat\u0026gt; m; m.push_back(Mat(2,2)); m.push_back(Mat(3,4)); m.push_back(Mat(2,2)); cin \u0026gt;\u0026gt; m[0] \u0026gt;\u0026gt; m[1] \u0026gt;\u0026gt; m[2]; sort(m.begin(),m.end()); cout\u0026lt;\u0026lt; m[0] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[2] \u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*************\u0026#34;\u0026lt;\u0026lt;endl; sort(m.begin(),m.end(),comparator_1); cout\u0026lt;\u0026lt; m[0] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[2] \u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*************\u0026#34;\u0026lt;\u0026lt;endl; sort(m.begin(),m.end(),comparator_2()); cout\u0026lt;\u0026lt; m[0] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[1] \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; m[2] \u0026lt;\u0026lt;endl; return 0; } 06:编程填空：数组输出 描述 填写代码，创建Print模板类，要求对输入的字符串数组或整数数组，用模板类进行输出并自动换行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 int main(){ string s[20]; int num[20]; int m,n; while(cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n){ for(int i=0; i\u0026lt;m; i++){ cin \u0026gt;\u0026gt; s[i]; } accumulate(s, s+m, Print\u0026lt;string\u0026gt;(m)); for(int i=0; i\u0026lt;n; i++){ cin \u0026gt;\u0026gt; num[i]; } accumulate(num, num+n, Print\u0026lt;int\u0026gt;(n)); } } 输入 有多个输入样例\n每个样例的第一行为两个整数m,n(m,n不超过20)\n每个样例的第二行为m个字符串\n每个样例的第三行为n个整数\n输出 对每个样例输出两行\n第一行为输入的字符串（去除空格）\n第二行为输入的整数（去除空格）\n样例输入 1 2 3 4 5 6 3 3 abc def hij 12 34 56 2 5 Peking University 20 18 05 1 3 样例输出 1 2 3 4 abcdefhij 123456 PekingUniversity 2018513 Solution 这里我们介绍一个新知识点，叫做链式加法\n这是什么？\n就是说，我们对于一个加法，返回的是原来的仿函数模板类对象\n这样就完了\n而且题目给了我们输出次数，完全可以做出链式的断裂条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; template\u0026lt;class T\u0026gt; class Print{ int x; public: Print(int a):x(a) { } Print\u0026lt;T\u0026gt;\u0026amp; operator+(T d){ x--; cout\u0026lt;\u0026lt;d; if(x==0) cout\u0026lt;\u0026lt;endl; return *this; } }; int main(){ string s[20]; int num[20]; int m,n; while(cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n){ for(int i=0; i\u0026lt;m; i++){ cin \u0026gt;\u0026gt; s[i]; } accumulate(s, s+m, Print\u0026lt;string\u0026gt;(m)); for(int i=0; i\u0026lt;n; i++){ cin \u0026gt;\u0026gt; num[i]; } accumulate(num, num+n, Print\u0026lt;int\u0026gt;(n)); } } 07:编程填空：正向与反向输出 描述 输入一个的序列，首先输出原序列，每个元素之间以\u0026quot;\u0026mdash;\u0026ldquo;分开\n再将序列的每个元素翻倍，并逆序输出原序列，每个元素之间以\u0026rdquo;***\u0026ldquo;分开。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; class C1{ // 在此处补充你的代码 }; int main() { vector\u0026lt;int\u0026gt; v; int p; int size; int k; cin \u0026gt;\u0026gt; k; while(k--){ cin \u0026gt;\u0026gt; size; v.clear(); for(int i = 0; i \u0026lt; size; ++i){ cin \u0026gt;\u0026gt; p; v.push_back(p); } C1 o1 = C1(size,v); ostream_iterator\u0026lt;int\u0026gt; it(cout,\u0026#34;---\u0026#34;); copy(*o1, (*o1)+size, it); cout\u0026lt;\u0026lt;endl; for(int i = 0; i \u0026lt; size; ++i){ o1[i]*=2; cout\u0026lt;\u0026lt;o1[i]\u0026lt;\u0026lt;\u0026#34;***\u0026#34;; } cout\u0026lt;\u0026lt;endl; } } 输入 第一行是测试数据组数k。\n对于每组测试数据，先输入\n测试数据共有k组，每组首先输入序列长度n，接下来n个整数分别代表序列的n个数。\n输出 对于每组测试数据输出两行，分别是以\u0026rdquo;\u0026mdash;\u0026ldquo;分割的原序列，和以\u0026rdquo;***\u0026ldquo;分割的翻倍后的逆序序列。\n样例输入 1 2 3 1 10 1 2 3 4 5 6 7 8 9 10 样例输出 1 2 1---2---3---4---5---6---7---8---9---10--- 20***18***16***14***12***10***8***6***4***2*** Solution 仔细阅读ppt中关于copy的定义即可轻松得出答案~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; class C1{ private: int siz; vector\u0026lt;int\u0026gt; k; public: C1(int x,vector\u0026lt;int\u0026gt; t):siz(x),k(t) { } C1(C1 \u0026amp;b){ siz=b.siz; k=b.k; } vector\u0026lt;int\u0026gt;::iterator operator*(){ return k.begin(); } int\u0026amp; operator[](int x){ return k[siz-x-1]; } void operator*=(int\u0026amp; k){ k*=2; return ; } }; int main() { vector\u0026lt;int\u0026gt; v; int p; int size; int k; cin \u0026gt;\u0026gt; k; while(k--){ cin \u0026gt;\u0026gt; size; v.clear(); for(int i = 0; i \u0026lt; size; ++i){ cin \u0026gt;\u0026gt; p; v.push_back(p); } C1 o1 = C1(size,v); ostream_iterator\u0026lt;int\u0026gt; it(cout,\u0026#34;---\u0026#34;); copy(*o1, (*o1)+size, it); cout\u0026lt;\u0026lt;endl; for(int i = 0; i \u0026lt; size; ++i){ o1[i]*=2; cout\u0026lt;\u0026lt;o1[i]\u0026lt;\u0026lt;\u0026#34;***\u0026#34;; } cout\u0026lt;\u0026lt;endl; } } 08:找第一个最小的 描述 写出 FindFirstLess 模板，用于寻找序列中小于某指定值的第一个元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 在此处补充你的代码 int main() { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n ; string type; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; type; vector\u0026lt;int\u0026gt; vi; vector\u0026lt;string\u0026gt; vs; if( type == \u0026#34;N\u0026#34;) { int a,m; for(int i = 0;i \u0026lt; n - 1; ++i) { cin \u0026gt;\u0026gt; a; vi.push_back(a); } cin \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt;::iterator p = FindFirstLess(vi.begin(),vi.end(),m,less\u0026lt;int\u0026gt;()); if( p!= vi.end()) cout \u0026lt;\u0026lt; * p \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; } else { string a,m; for(int i = 0;i \u0026lt; n - 1; ++i) { cin \u0026gt;\u0026gt; a; vs.push_back(a); } cin \u0026gt;\u0026gt; m; vector\u0026lt;string\u0026gt;::iterator p = FindFirstLess(vs.begin(),vs.end(),m,less\u0026lt;string\u0026gt;()); if( p!= vs.end()) cout \u0026lt;\u0026lt; * p \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 输入 第一行是测试数据组数T\n接下来有2T行，每两行是一组测试数据\n每组数据第一行开始是一个整数，表示这组数据有n项；接下来是一个字母，如果是\u0026rsquo;N\u0026rsquo;，表示这组数据都是整数，如果是\u0026rsquo;S\u0026rsquo;表示这组数据都是字符串\n第二行就是n个整数，或者n个字符串\n输出 对每组数据，输出第二行的前n-1项里面，第一个小于第n项的 。如果找不到，输出 \u0026ldquo;Not Found\u0026rdquo;\n样例输入 1 2 3 4 5 6 7 3 4 N 28 12 7 15 4 S Jack Tom Marry Ken 4 N 100 200 300 2 样例输出 1 2 3 12 Jack Not Found Solution 其实这道题就是普通的函数模板\n我们可以看到less返回了一个实例化的函数模板类\n那么，我们直接写一个函数就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; template\u0026lt;class T1,class T2,class T3\u0026gt; T1 FindFirstLess(T1 x,T1 y,T2 t,T3 f){ bool flag=false; T1 k; for(T1 it=x;it!=y;it++){ if(*it\u0026lt;t){ flag=1; k=it; break; } } if(flag) return k; else return y; } int main() { int t; cin \u0026gt;\u0026gt; t; while(t--) { int n ; string type; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; type; vector\u0026lt;int\u0026gt; vi; vector\u0026lt;string\u0026gt; vs; if( type == \u0026#34;N\u0026#34;) { int a,m; for(int i = 0;i \u0026lt; n - 1; ++i) { cin \u0026gt;\u0026gt; a; vi.push_back(a); } cin \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt;::iterator p = FindFirstLess(vi.begin(),vi.end(),m,less\u0026lt;int\u0026gt;()); if( p!= vi.end()) cout \u0026lt;\u0026lt; * p \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; } else { string a,m; for(int i = 0;i \u0026lt; n - 1; ++i) { cin \u0026gt;\u0026gt; a; vs.push_back(a); } cin \u0026gt;\u0026gt; m; vector\u0026lt;string\u0026gt;::iterator p = FindFirstLess(vs.begin(),vs.end(),m,less\u0026lt;string\u0026gt;()); if( p!= vs.end()) cout \u0026lt;\u0026lt; * p \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; } } return 0; } 09:输出Fibonacci数列 描述 Fibonacci数列指的是数列第一项和第二项为1，之后每一项是之前两项的和所构成的数列。 现有多组数据，每组数据给出一个数字n，请你输出Fibonacci数列的前n-1项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; template\u0026lt;class T1, class T2\u0026gt; void Copy(T1 s, T1 e, T2 x) { for(; s != e; ++s, ++x) *x = *s; } // 在此处补充你的代码 int main() { while(true) { int n; cin \u0026gt;\u0026gt; n; if(n == 0) break; Fib f1(1), f2(n); ostream_iterator\u0026lt;int\u0026gt; it(cout, \u0026#34; \u0026#34;); Copy(f1, f2, it); cout \u0026lt;\u0026lt; endl; } return 0; } 输入 每组数据一行，整数n 输入以0结尾\n输出 对每组数据输出前 n-1项\n样例输入 1 2 3 0 样例输出 1 1 1 Solution 这道题我其实看不大懂，然后查了一下发现每个类里需要存一下现在的值和上一个函数的值，重载++和!=的时候跟已经得到的值进行比较，然后*就是重载成输出，就可以了\n笔者注：学了python的面向对象编程和生成器后更有感觉了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iterator\u0026gt; using namespace std; template\u0026lt;class T1, class T2\u0026gt; void Copy(T1 s, T1 e, T2 x) { for(; s != e; ++s, ++x) *x = *s; } class Fib{ int num; int pre; int tem; public: Fib(int n):num(n),pre(0),tem(1) { } void operator++(){ num++; int cur=tem; cur=tem+pre; pre=tem; tem=cur; } bool operator!=(const Fib \u0026amp;s){ return num!=s.num; } int operator*(){ return tem; } }; int main() { while(true) { int n; cin \u0026gt;\u0026gt; n; if(n == 0) break; Fib f1(1), f2(n); ostream_iterator\u0026lt;int\u0026gt; it(cout, \u0026#34; \u0026#34;); Copy(f1, f2, it); cout \u0026lt;\u0026lt; endl; } return 0; } 10:改良过的CArray3d三维数组模板类 描述 程序填空，按要求输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { // 在此处补充你的代码 }; CArray3D\u0026lt;int\u0026gt; a(3,4,5); CArray3D\u0026lt;double\u0026gt; b(3,2,2); void PrintA() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 4; ++j) { for(int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } void PrintB() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 2; ++j) { for(int k = 0; k \u0026lt; 2; ++k) cout \u0026lt;\u0026lt; b[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 4; ++j ) for( int k = 0; k \u0026lt; 5; ++k ) a[i][j][k] = No ++; PrintA(); memset(a, -1, 60 * sizeof(int)); //注意这里 memset(a[1][1], 0, 5 * sizeof(int)); PrintA(); for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 2; ++j ) for( int k = 0; k \u0026lt; 2; ++k ) b[i][j][k] = 10.0 / (i + j + k + 1); PrintB(); int n = a[0][1][2]; double f = b[0][1][1]; cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } 输入 无\n输出 如样例\n样例输入 1 无 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: 20,21,22,23,24, 25,26,27,28,29, 30,31,32,33,34, 35,36,37,38,39, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 1: -1,-1,-1,-1,-1, 0,0,0,0,0, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 2: -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 0: 10,5, 5,3.33333, layer 1: 5,3.33333, 3.33333,2.5, layer 2: 3.33333,2.5, 2.5,2, **** -1,3.33333 Solution 说是改良了，其实没有\n用上次的代码完全能过，不解释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { private: int x,y,z; T* p; public: CArray3D(int a,int b,int c):x(a),y(b),z(c) { p=new T[x*y*z]; } class CArray2D{ private: int y,z; T* dd; public: CArray2D(T* d,int b,int c):dd(d),y(b),z(c) { } T* operator[](int index){ T* t=dd+index*z; return t; } }; CArray2D operator[](int index){ T* dd=p+index*y*z; return CArray2D(dd,y,z); } operator T*(){ return p; } }; CArray3D\u0026lt;int\u0026gt; a(3,4,5); CArray3D\u0026lt;double\u0026gt; b(3,2,2); void PrintA() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 4; ++j) { for(int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } void PrintB() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 2; ++j) { for(int k = 0; k \u0026lt; 2; ++k) cout \u0026lt;\u0026lt; b[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 4; ++j ) for( int k = 0; k \u0026lt; 5; ++k ) a[i][j][k] = No ++; PrintA(); memset(a, -1, 60 * sizeof(int)); //注意这里 memset(a[1][1], 0, 5 * sizeof(int)); PrintA(); for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 2; ++j ) for( int k = 0; k \u0026lt; 2; ++k ) b[i][j][k] = 10.0 / (i + j + k + 1); PrintB(); int n = a[0][1][2]; double f = b[0][1][1]; cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-04-27T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第七次上机复盘"},{"content":"A:List 描述 写一个程序完成以下命令：\nnew id ——新建一个指定编号为id的序列(id \u0026lt; 10000)\nadd id num——向编号为id的序列加入整数\nnum merge id1 id2——如果id1等于id2,不做任何事，否则归并序列id1和id2中的数，并将id2清空\nunique id——去掉序列id中重复的元素\nout id ——从小到大输出编号为id的序列中的元素，以空格隔开\n输入 第一行一个数n，表示有多少个命令( n＜＝２０００００)。以后n行每行一个命令。\n输出 按题目要求输出。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 16 new 1 new 2 add 1 1 add 1 2 add 1 3 add 2 1 add 2 2 add 2 3 add 2 4 out 1 out 2 merge 1 2 out 1 out 2 unique 1 out 1 样例输出 1 2 3 4 5 1 2 3 1 2 3 4 1 1 2 2 3 3 4 1 2 3 4 Solution 其实题目没有强求你用题干的数据结构就是了\n但是我们这题还是用list，虽然这题用multimap或者multiset也可以的\n那题目中的指令就变成:\nnew 其实也没啥用\nadd 就是push_back\nmerge 就是merge\nunique 就是先sort后unique（有点像离散化？不过方便输出也是了 ) out 就是用迭代器输出 使用更方便的auto而不是iterator\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define maxn 200005 using namespace std; int n; list\u0026lt;int\u0026gt;ma[maxn]; string s; int id,num; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s; if(s[0]==\u0026#39;n\u0026#39;){ cin\u0026gt;\u0026gt;id; } else if(s[0]==\u0026#39;a\u0026#39;){ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;num; ma[id].push_back(num); } else if(s[0]==\u0026#39;m\u0026#39;){ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;num; if(id==num) continue; else{ ma[id].merge(ma[num]); } } else if(s[0]==\u0026#39;u\u0026#39;){ cin\u0026gt;\u0026gt;id; ma[id].sort(); ma[id].unique(); } else if(s[0]==\u0026#39;o\u0026#39;){ cin\u0026gt;\u0026gt;id; if(ma[id].empty()) cout\u0026lt;\u0026lt;endl; else{ ma[id].sort(); for(auto i=ma[id].begin();i!=ma[id].end();i++){ cout\u0026lt;\u0026lt;*i\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; } } } system(\u0026#34;pause\u0026#34;); return 0; } B RPN Calculator 描述 逆波兰表示法（或简称 RPN），与相关的波兰表示法类似，波兰表示法是波兰数学家扬・武卡谢维奇（Jan Łukasiewicz）于 1920 年引入的一种前缀表示法。逆波兰表示法是一种数学表示法，其中每个运算符都紧跟在其所有操作数之后。它也被称为后缀表示法。\n在逆波兰表示法中，运算符紧跟在操作数之后；例如，要计算 3 加 4 ，应写成 “3 4 +”，而不是 “3 + 4”。如果有多个运算，运算符会紧跟在第二个操作数之后；所以常规中缀表示法下写成 “3 - 4 + 5” 的表达式，在逆波兰表示法中应写成 “3 4 - 5 +” ：先计算 3 减 4 ，然后再加上 5。逆波兰表示法的一个优点是它无需中缀表示法中所需的括号。“3 - 4 * 5” 也可以写成 “3 - (4 * 5)” ，但这与 “(3 - 4) * 5” 的含义截然不同，只有括号能区分这两种不同的含义。在后缀表示法中，前者应写成 “3 4 5 * -” ，它明确表示 “3 (4 5 ) -” 。\n你需要设计一个简单的逆波兰表示法计算器，该计算器需支持 “+”、“-”、“”、“/”（除数的绝对值不小于 10⁻⁹ ）和 “^”（幂运算符，若底数 b≤0 ，指数 e 必须是不大于 10⁹ 的正整数 ）运算符。可以假设计算过程中的所有数字都可以用双精度浮点数表示。\n此外，我们的计算器有一定的内存。每次计算一个表达式时，内存中最小的数字将被删除，并替换为该表达式的值。\n输入 第一行包含一个整数 n，它是我们计算器的内存大小。\n从第二行开始，将给出 n 个数字，这些是内存的初始值。除最后一行外，每行将有 10 个数字。\n然后每行是一个有效的逆波兰表示法表达式，以 “=” 结尾，“=” 是计算命令。每个项的长度不超过 20 个字符。\n输出 对于每个表达式，在一行中输出其值。\n然后输出一个空行，将两部分内容分隔开。\n最后，按升序输出内存中的所有数字，每行 10 个数字。\n每个数字应采用科学计数法格式，保留 6 位小数，指数部分占 2 位，类似于 C 语言中 printf () 函数的 “% e” 格式字符串。一行中的数字之间用空格分隔。\n样例输入 1 2 3 4 4 1e6 1e-6 0.001 1000 1 2 + 3 4 + * = 1 0.1 / 8 ^ = 样例输出 1 2 3 4 2.100000e+01 1.000000e+08 2.100000e+01 1.000000e+03 1.000000e+06 1.000000e+08 提示 Huge input, scanf() is recommended\n%e格式输出在windows环境下指数部分为3位，在系统的测试环境下为2位。\nSolution 逆波兰表达式的求法应该都会？用一个栈很简单\n然后，有什么要介绍的呢\n啊，就是这个atof(x.c_str())\n其中，c_str()指的是将string类型变量x转换成char类型变量\n然后，atof()表示将char型变量转换成双精度浮点数\n这部分来自网络代码\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; int n; int main(){ cin\u0026gt;\u0026gt;n; stack\u0026lt;double\u0026gt;ma; multiset\u0026lt;double\u0026gt;res; for(int i=1;i\u0026lt;=n;i++){ double x; cin\u0026gt;\u0026gt;x; res.insert(x); } string x; while(cin\u0026gt;\u0026gt;x){ if(x==\u0026#34;=\u0026#34;){ double s=ma.top(); printf(\u0026#34;%e\\n\u0026#34;,s); ma.pop(); auto it=res.begin(); res.erase(it); res.insert(s); } else if(x==\u0026#34;+\u0026#34;||x==\u0026#34;-\u0026#34;||x==\u0026#34;*\u0026#34;||x==\u0026#34;/\u0026#34;||x==\u0026#34;^\u0026#34;){ double a,b,c; a=ma.top(); ma.pop(); b=ma.top(); ma.pop(); if(x==\u0026#34;+\u0026#34;){ c=a+b; } else if(x==\u0026#34;-\u0026#34;){ c=b-a; } else if(x==\u0026#34;*\u0026#34;){ c=a*b; } else if(x==\u0026#34;/\u0026#34;){ c=b/a; } else{ c=pow(b,a); } ma.push(c); } else{ double num; num=atof(x.c_str()); ma.push(num); } } cout\u0026lt;\u0026lt;endl; int count=0; for(auto it=res.begin();it!=res.end();it++){ count++; if(count%10==0){ printf(\u0026#34;%e\\n\u0026#34;,*it); } else{ printf(\u0026#34;%e \u0026#34;,*it); } } system(\u0026#34;pause\u0026#34;); return 0; } C:Set 描述 现有一整数集（允许有重复元素），初始为空。我们定义如下操作：\nadd x 把x加入集合\ndel x 把集合中所有与x相等的元素删除\nask x 对集合中元素x的情况询问\n对每种操作，我们要求进行如下输出。\nadd 输出操作后集合中x的个数\ndel 输出操作前集合中x的个数\nask 先输出0或1表示x是否曾被加入集合（0表示不曾加入），再输出当前集合中x的个数，中间用空格格开。\n输入 第一行是一个整数n，表示命令数。0\u0026lt;=n\u0026lt;=100000。\n后面n行命令，如Description中所述。\n输出 共n行，每行按要求输出。\n样例输入 1 2 3 4 5 6 7 8 7 add 1 add 1 ask 1 ask 2 del 2 del 1 ask 1 样例输出 1 2 3 4 5 6 7 1 2 1 2 0 0 0 2 1 0 提示 Please use STL’s set and multiset to finish the task\nSolution 由于题目中需要我们删除重复元素，所以必须用到multiset 然后，我们用set来记录x是否被加入过集合就可以\n至于删除操作，我们用一个循环find就能实现\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long using namespace std; int n; multiset\u0026lt;int\u0026gt;ma; set\u0026lt;int\u0026gt;k; string s; int x; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;x; if(s[1]==\u0026#39;d\u0026#39;){ ma.insert(x); k.insert(x); cout\u0026lt;\u0026lt;ma.count(x)\u0026lt;\u0026lt;endl; } else if(s[1]==\u0026#39;e\u0026#39;){ cout\u0026lt;\u0026lt;ma.count(x)\u0026lt;\u0026lt;endl; auto it=ma.find(x); while(it!=ma.end()){ ma.erase(it); it=ma.find(x); } } else{ if(k.find(x)!=k.end()) cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; else cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;; cout\u0026lt;\u0026lt;ma.count(x)\u0026lt;\u0026lt;endl; } } system(\u0026#34;pause\u0026#34;); return 0; } D:字符串操作 描述 给定n个字符串（从1开始编号），每个字符串中的字符位置从0开始编号，长度为1-500，现有如下若干操作：\ncopy N X L：取出第N个字符串第X个字符开始的长度为L的字符串。\nadd S1 S2：判断S1，S2是否为0-99999之间的整数，若是则将其转化为整数做加法，若不是，则作字符串加法，返回的值为一字符串。\nfind S N：在第N个字符串中从左开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。\nrfind S N：在第N个字符串中从右开始找寻S字符串，返回其第一次出现的位置，若没有找到，返回字符串的长度。\ninsert S N X：在第N个字符串的第X个字符位置中插入S字符串。\nreset S N：将第N个字符串变为S。\nprint N：打印输出第N个字符串。\nprintall：打印输出所有字符串。\nover：结束操作。\n其中N，X，L可由find与rfind操作表达式构成，S，S1，S2可由copy与add操作表达式构成。\n输入 第一行为一个整数n（n在1-20之间）\n接下来n行为n个字符串，字符串不包含空格及操作命令等。\n接下来若干行为一系列操作，直到over结束。\n输出 根据操作提示输出对应字符串。\n样例输入 1 2 3 4 5 6 7 8 9 10 11 3 329strjvc Opadfk48 Ifjoqwoqejr insert copy 1 find 2 1 2 2 2 print 2 reset add copy 1 find 3 1 3 copy 2 find 2 2 2 3 print 3 insert a 3 2 printall over 样例输出 1 2 3 4 5 Op29adfk48 358 329strjvc Op29adfk48 35a8 提示 推荐使用string类中的相关操作函数。\nSolution 我们要明确的一点是，这道题可能存在嵌套的函数，所以应该使用没有参数值的函数来实现，因为如果有参数值确实不好处理这个东西的类型，写模版确实麻烦多了\n这道题思路有参考网络\n其中，stoi表示将string型变量转成int型变量\nto_string表示将int型变量转成string型变量\nnpos通常用于表示查找失败或者末尾\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) #define maxn 25 using namespace std; string Copy(); string Add(); bool isnum(string x); int Find(); int Rfind(); string Insert(); string Reset(); void Print(int x); void Printall(); int n0; string str[maxn]; int tot; string Copy(){ string N,X,L; int n,x,l; cin\u0026gt;\u0026gt;N; if(N==\u0026#34;find\u0026#34;){ n=Find(); } else if(N==\u0026#34;rfind\u0026#34;){ n=Rfind(); } else n=stoi(N); cin\u0026gt;\u0026gt;X; if(X==\u0026#34;find\u0026#34;){ x=Find(); } else if(X==\u0026#34;rfind\u0026#34;){ x=Rfind(); } else x=stoi(X); cin\u0026gt;\u0026gt;L; if(L==\u0026#34;find\u0026#34;){ l=Find(); } else if(L==\u0026#34;rfind\u0026#34;){ l=Rfind(); } else l=stoi(L); string temp=str[n].substr(x,l); return temp; } string Add(){ string S1,S2,s1,s2; cin\u0026gt;\u0026gt;S1; if(S1==\u0026#34;copy\u0026#34;){ s1=Copy(); } else if(S1==\u0026#34;add\u0026#34;){ s1=Add(); } else s1=S1; cin\u0026gt;\u0026gt;S2; if(S2==\u0026#34;copy\u0026#34;){ s2=Copy(); } else if(S2==\u0026#34;add\u0026#34;){ s2=Add(); } else s2=S2; if(isnum(s1)\u0026amp;\u0026amp;isnum(s2)){ int a=stoi(s1),b=stoi(s2); return to_string(a+b); } else return s1+s2; } bool isnum(string x){ int l=x.length(); if(l\u0026gt;=5) return false; bool flag=true; for(int i=0;i\u0026lt;=l-1;i++){ if(!(x[i]\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;x[i]\u0026lt;=\u0026#39;9\u0026#39;)){ flag=false; break; } } return flag; } int Find(){ string S,N,s; int n; cin\u0026gt;\u0026gt;S; if(S==\u0026#34;copy\u0026#34;){ s=Copy(); } else if(S==\u0026#34;add\u0026#34;){ s=Add(); } else s=S; cin\u0026gt;\u0026gt;N; if(N==\u0026#34;find\u0026#34;){ n=Find(); } else if(N==\u0026#34;rfind\u0026#34;){ n=Rfind(); } else n=stoi(N); int temp; if(str[n].find(s)!=string::npos){ temp=str[n].find(s); } else temp=str[n].size(); return temp; } int Rfind(){ string S,s,N; int n; cin\u0026gt;\u0026gt;S; if(S==\u0026#34;copy\u0026#34;){ s=Copy(); } else if(S==\u0026#34;add\u0026#34;){ s=Add(); } else s=S; cin\u0026gt;\u0026gt;N; if(N==\u0026#34;find\u0026#34;){ n=Find(); } else if(N==\u0026#34;rfind\u0026#34;){ n=Rfind(); } else n=stoi(N); int temp; if(str[n].rfind(s)!=string::npos){ temp=str[n].rfind(s); } else temp=str[n].size(); return temp; } string Insert(){ string N,X,S,s; int n,x; cin\u0026gt;\u0026gt;S; if(S==\u0026#34;copy\u0026#34;){ s=Copy(); } else if(S==\u0026#34;add\u0026#34;){ s=Add(); } else s=S; cin\u0026gt;\u0026gt;N; if(N==\u0026#34;find\u0026#34;){ n=Find(); } else if(N==\u0026#34;rfind\u0026#34;){ n=Rfind(); } else{ n=stoi(N); } cin\u0026gt;\u0026gt;X; if(X==\u0026#34;find\u0026#34;){ x=Find(); } else if(X==\u0026#34;rfind\u0026#34;){ x=Rfind(); } else x=stoi(X); string temp=str[n].insert(x,s); return temp; } string Reset(){ string S,s,N; int n; cin\u0026gt;\u0026gt;S; if(S==\u0026#34;copy\u0026#34;){ s=Copy(); } else if(S==\u0026#34;add\u0026#34;){ s=Add(); } else s=S; cin\u0026gt;\u0026gt;N; if(N==\u0026#34;find\u0026#34;){ n=Find(); } else if(N==\u0026#34;rfind\u0026#34;){ n=Rfind(); } else n=stoi(N); swap(str[n],s); return str[n]; } void Print(int x){ cout\u0026lt;\u0026lt;str[x]\u0026lt;\u0026lt;endl; return ; } void Printall(){ for(int i=1;i\u0026lt;=n0;i++){ cout\u0026lt;\u0026lt;str[i]\u0026lt;\u0026lt;endl; } return ; } int main(){ cin\u0026gt;\u0026gt;n0; for(int i=1;i\u0026lt;=n0;i++){ cin\u0026gt;\u0026gt;str[i]; } while(1){ string op; cin\u0026gt;\u0026gt;op; if(op==\u0026#34;over\u0026#34;) break; else if(op==\u0026#34;copy\u0026#34;){ Copy(); } else if(op==\u0026#34;add\u0026#34;){ Add(); } else if(op==\u0026#34;find\u0026#34;){ Find(); } else if(op==\u0026#34;rfind\u0026#34;){ Rfind(); } else if(op==\u0026#34;insert\u0026#34;){ Insert(); } else if(op==\u0026#34;reset\u0026#34;){ Reset(); } else if(op==\u0026#34;print\u0026#34;){ int x; cin\u0026gt;\u0026gt;x; Print(x); } else if(op==\u0026#34;printall\u0026#34;){ Printall(); } } system(\u0026#34;pause\u0026#34;); return 0; } E:热血格斗场 描述 为了迎接08年的奥运会，让大家更加了解各种格斗运动，facer新开了一家热血格斗场。格斗场实行会员制，但是新来的会员不需要交入会费，而只要同一名老会员打一场表演赛，证明自己的实力。\n我们假设格斗的实力可以用一个正整数表示，成为实力值。另外，每个人都有一个唯一的id，也是一个正整数。为了使得比赛更好看，每一个新队员都会选择与他实力最为接近的人比赛，即比赛双方的实力值之差的绝对值越小越好，如果有两个人的实力值与他差别相同，则他会选择比他弱的那个（显然，虐人必被虐好）。\n不幸的是，Facer一不小心把比赛记录弄丢了，但是他还保留着会员的注册记录。现在请你帮facer恢复比赛纪录，按照时间顺序依次输出每场比赛双方的id。\n输入 第一行一个数n(0 \u0026lt; n \u0026lt;=100000)，表示格斗场新来的会员数（不包括facer）。以后n行每一行两个数，按照入会的时间给出会员的id和实力值。一开始，facer就算是会员，id为1，实力值1000000000。输入保证两人的实力值不同。\n输出 N行，每行两个数，为每场比赛双方的id，新手的id写在前面。\n样例输入 1 2 3 4 3 2 1 3 3 4 2 样例输出 1 2 3 2 1 3 2 4 2 Solution 本题要求我们匹配比赛记录\n那么，我们可以采用multimap\n为什么是multimap?因为这道题其实用multiset好像也可以，但是就直接用multimap吧，因为可能有的数的power是一样的\n代码实现还是不难的\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long using namespace std; int n; int id,p; multimap\u0026lt;int,int\u0026gt;lst; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); lst.insert(make_pair(1000000000,1)); for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;p; auto it=lst.insert(make_pair(p,id)); cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if(it!=lst.begin()\u0026amp;\u0026amp;it!=--lst.end()){ auto it_1=it; auto it_2=it; it_1--; it_2++; if(abs(it_1-\u0026gt;first-p)\u0026lt;=abs(it_2-\u0026gt;first-p)){ cout\u0026lt;\u0026lt;it_1-\u0026gt;second\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;it_2-\u0026gt;second\u0026lt;\u0026lt;endl; } else if(it==lst.begin()){ cout\u0026lt;\u0026lt;(++it)-\u0026gt;second\u0026lt;\u0026lt;endl; } else if(it==--lst.end()){ cout\u0026lt;\u0026lt;(--it)-\u0026gt;second\u0026lt;\u0026lt;endl; } } system(\u0026#34;pause\u0026#34;); return 0; } F:冷血格斗场 描述 为了迎接08年的奥运会，让大家更加了解各种格斗运动，facer新开了一家冷血格斗场。格斗场实行会员制，但是新来的会员不需要交入会费，而只要同一名老会员打一场表演赛，证明自己的实力。\n我们假设格斗的实力可以用一个非负整数表示，称为实力值，两人的实力值可以相同。另外，每个人都有一个唯一的id，也是一个正整数。为了使得比赛更好看，每一个新队员都会选择与他实力最为接近的人比赛，即比赛双方的实力值之差的绝对值越小越好，如果有多个人的实力值与他差别相同，则他会选择id最小的那个。\n不幸的是，Facer一不小心把比赛记录弄丢了，但是他还保留着会员的注册记录。现在请你帮facer恢复比赛纪录，按照时间顺序依次输出每场比赛双方的id。\n输入 第一行一个数n(0 \u0026lt; n \u0026lt;=100000)，表示格斗场新来的会员数（不包括facer）。以后n行每一行两个数，按照入会的时间给出会员的id和实力值。一开始，facer就算是会员，id为1，实力值1000000000。\n输出 N行，每行两个数，为每场比赛双方的id，新手的id写在前面。\n样例输入 1 2 3 4 3 2 3 3 1 4 2 样例输出 1 2 3 2 1 3 2 4 2 Solution 本题的重点在于，如果有多个人的实力值和他相同，那么，它会选择id最小的那个\n意思是，对于后输入的，如果后输入的id比前面的小，那么前面的就没有意义了（有点像优先队列？）\n所以，我们只需维护一个map，因为在上述说法下不会存在冲突\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long using namespace std; int n,id,p; map\u0026lt;int,int\u0026gt;ma; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); ma[1000000000]=1; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;id\u0026gt;\u0026gt;p; cout\u0026lt;\u0026lt;id\u0026lt;\u0026lt;\u0026#39; \u0026#39;; auto it=ma.find(p); if(it!=ma.end()) { cout\u0026lt;\u0026lt;ma[p]\u0026lt;\u0026lt;endl; ma[p]=min(id,ma[p]); continue; } else ma[p]=id; it=ma.find(p); if(it!=ma.begin()\u0026amp;\u0026amp;it!=--ma.end()){ auto it_1=it; auto it_2=it; it_1--; it_2++; if(abs(it_1-\u0026gt;first-p)\u0026lt;abs(it_2-\u0026gt;first-p)){ cout\u0026lt;\u0026lt;it_1-\u0026gt;second\u0026lt;\u0026lt;endl; } else if(abs(it_1-\u0026gt;first-p)==abs(it_2-\u0026gt;first-p)){ cout\u0026lt;\u0026lt;min(it_1-\u0026gt;second,it_2-\u0026gt;second)\u0026lt;\u0026lt;endl; } else cout\u0026lt;\u0026lt;it_2-\u0026gt;second\u0026lt;\u0026lt;endl; } else if(it==ma.begin()){ cout\u0026lt;\u0026lt;(++it)-\u0026gt;second\u0026lt;\u0026lt;endl; } else if(it==--ma.end()){ cout\u0026lt;\u0026lt;(--it)-\u0026gt;second\u0026lt;\u0026lt;endl; } } system(\u0026#34;pause\u0026#34;); return 0; } G:Priority_queue 练习题 描述 我们定义一个正整数a比正整数b优先的含义是： *a的质因数数目（不包括自身）比b的质因数数目多；\n*当两者质因数数目相等时，数值较大者优先级高。\n现在给定一个容器，初始元素数目为0，之后每次往里面添加10个元素，每次添加之后，要求输出优先级最高与最低的元素，并把该两元素从容器中删除。\n输入 第一行: num (添加元素次数，num \u0026lt;= 30)\n下面10*num行，每行一个正整数n（n \u0026lt; 10000000).\n输出 每次输入10个整数后，输出容器中优先级最高与最低的元素，两者用空格间隔。\n样例输入 1 2 1 10 7 66 4 5 30 91 100 8 9 样例输出 1 66 5 Solution 本题没叫你用优先队列，那你可以不用啊哈哈\n所以我们用set来完成 虽然multiset也可以，但是set可以去除不必要的元素，所以使用set\n同样，这里要说明的是，我们到目前使用仿函数还是比较少的，所以这里要注意一下\n然后就是仿函数类这里要注意，要加上一个const 因为新版本编译器要求更为严格，需要cmp通过静态函数变量形式被调用，所以不加const会报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define ull unsigned long long #define lowbit(x) (x\u0026amp;(-x)) using namespace std; bool isprime(int x){ if(x==1) return false; if(x==2) return true; for(int i=2;i*i\u0026lt;=x;i++){ if(x%i==0) return false; } return true; } int count(int x){ int ans=0; for(int i=1;i\u0026lt;x;i++){ if(x%i!=0) continue; if(isprime(i)) ans++; } return ans; } struct node{ int num,rnum; }; struct cmp{ bool operator()(const node a,const node b)const{ if(a.rnum==b.rnum) return a.num\u0026lt;b.num; return a.rnum\u0026lt;b.rnum; } }; int main(){ int n,k; cin\u0026gt;\u0026gt;n; set\u0026lt;node,cmp\u0026gt;queue; for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=10;j++){ cin\u0026gt;\u0026gt;k; node a; a.num=k; a.rnum=count(k); queue.insert(a); } auto it=queue.end();it--; cout\u0026lt;\u0026lt;(*it).num\u0026lt;\u0026lt;\u0026#39; \u0026#39;; auto it_2=queue.begin(); cout\u0026lt;\u0026lt;(*it_2).num\u0026lt;\u0026lt;endl; queue.erase(it);queue.erase(it_2); } system(\u0026#34;pause\u0026#34;); return 0; } H:编程填空：数据库内的学生信息 描述 程序填空，使得下面的程序,先输出\n1 2 3 4 5 6 7 8 9 (Tom,80),(Tom,70),(Jone,90),(Jack,70),(Alice,100), (Tom,78),(Tom,78),(Jone,90),(Jack,70),(Alice,100), (70,Jack),(70,Tom),(80,Tom),(90,Jone),(100,Alice), (70,Error),(70,Error),(80,Tom),(90,Jone),(100,Alice), ****** 然后，再根据输入数据按要求产生输出数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; // 在此处补充你的代码 struct Student { string name; int score; }; template \u0026lt;class T\u0026gt; void Print(T first,T last) { for(;first!= last; ++ first) cout \u0026lt;\u0026lt; * first \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { Student s[] = { {\u0026#34;Tom\u0026#34;,80},{\u0026#34;Jack\u0026#34;,70}, {\u0026#34;Jone\u0026#34;,90},{\u0026#34;Tom\u0026#34;,70},{\u0026#34;Alice\u0026#34;,100} }; MyMultimap\u0026lt;string,int\u0026gt; mp; for(int i = 0; i\u0026lt;5; ++ i) mp.insert(make_pair(s[i].name,s[i].score)); Print(mp.begin(),mp.end()); //按姓名从大到小输出 mp.Set(\u0026#34;Tom\u0026#34;,78); //把所有名为\u0026#34;Tom\u0026#34;的学生的成绩都设置为78 Print(mp.begin(),mp.end()); MyMultimap\u0026lt;int,string,less\u0026lt;int\u0026gt; \u0026gt; mp2; for(int i = 0; i\u0026lt;5; ++ i) mp2.insert(make_pair(s[i].score,s[i].name)); Print(mp2.begin(),mp2.end()); //按成绩从小到大输出 mp2.Set(70,\u0026#34;Error\u0026#34;); //把所有成绩为70的学生，名字都改为\u0026#34;Error\u0026#34; Print(mp2.begin(),mp2.end()); cout \u0026lt;\u0026lt; \u0026#34;******\u0026#34; \u0026lt;\u0026lt; endl; mp.clear(); string name; string cmd; int score;\twhile(cin \u0026gt;\u0026gt; cmd ) { if( cmd == \u0026#34;A\u0026#34;) { cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; score; if(mp.find(name) != mp.end() ) { cout \u0026lt;\u0026lt; \u0026#34;erroe\u0026#34; \u0026lt;\u0026lt; endl; } mp.insert(make_pair(name,score)); } else if(cmd == \u0026#34;Q\u0026#34;) { cin \u0026gt;\u0026gt; name; MyMultimap\u0026lt;string,int\u0026gt;::iterator p = mp.find(name); if( p!= mp.end()) { cout \u0026lt;\u0026lt; p-\u0026gt;second \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; }\t} } return 0; } 输入 输入数据的每一行，格式为以下之一：\nA name score\nQ name score\nname是个不带个空格的字符串，长度小于 20\nscore是个整数，能用int表示\nA name score 表示往数据库中新增一个姓名为name的学生，其分数为score。开始时数据库中一个学生也没有。\nQ name 表示在数据库中查询姓名为name的学生的分数\n数据保证学生不重名。\n输入数据少于200,000行。\n输出 对于每个查询，输出学生的分数。如果查不到，则输出 \u0026ldquo;Not Found\u0026rdquo;\n样例输入 1 2 3 4 5 6 A Tom1 30 A Tom2 40 Q Tom3 A Tom4 89 Q Tom1 Q Tom2 样例输出 1 2 3 4 5 6 7 8 (Tom,80),(Tom,70),(Jone,90),(Jack,70),(Alice,100), (Tom,78),(Tom,78),(Jone,90),(Jack,70),(Alice,100), (70,Jack),(70,Tom),(80,Tom),(90,Jone),(100,Alice), (70,Error),(70,Error),(80,Tom),(90,Jone),(100,Alice), ****** Not Found 30 40 提示 编写模板的时候，连续的两个 “\u0026gt;”最好要用空格分开，以免被编译器看作是 \u0026ldquo;\u0026raquo;\u0026ldquo;运算符。VS可能无此问题，但是Dev C++和服务器上的编译环境会有这个问题。\n比如 vector\u0026lt;vector\u0026gt; 有可能出错，要改成 vector\u0026lt;vector \u0026gt;\n在模板中写迭代器时，最好在前面加上 typename关键字，否则可能会编译错。VS可能无此问题，但是Dev C++和服务器上的编译环境会有这个问题。\nSolution 我们通过报错可以发现，这题需要我们定义一个模板类了，但是，对于pred（谓词，返回一个bool型变量），前面是有缺省的，所以我们需要一个greater来顶一下\n剩下的其实要说的不多，还有就是，这个public的第一行是因为，下面代码中的iterator类缺少了定义，我们需要把它称作一个新的名字\n然后，这个输出函数要写在外面，因为输出的应该是对于外部函数而言的，而不是类变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;iterator\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; template\u0026lt;class T1,class T2,class Pred=greater\u0026lt;T1\u0026gt;\u0026gt; class MyMultimap{ private: multimap\u0026lt;T1,T2,Pred\u0026gt;ma; public: typedef typename multimap\u0026lt;T1,T2,Pred\u0026gt;::iterator iterator; MyMultimap(){ ma.clear(); } void insert(pair\u0026lt;T1,T2\u0026gt;x){ ma.insert(x); } auto begin(){ return ma.begin(); } auto end(){ return ma.end(); } void Set(T1 x,T2 y){ for(auto it=ma.begin();it!=ma.end();it++){ if(it-\u0026gt;first==x) it-\u0026gt;second=y; } } void clear(){ ma.clear(); } auto find(T1 x){ return ma.find(x); } }; template\u0026lt;class T1,class T2\u0026gt; ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const pair\u0026lt;T1,T2\u0026gt;x){ os\u0026lt;\u0026lt;\u0026#39;(\u0026#39;\u0026lt;\u0026lt;x.first\u0026lt;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026lt;x.second\u0026lt;\u0026lt;\u0026#39;)\u0026#39;; return os; } struct Student { string name; int score; }; template \u0026lt;class T\u0026gt; void Print(T first,T last) { for(;first!= last; ++ first) cout \u0026lt;\u0026lt; * first \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { Student s[] = { {\u0026#34;Tom\u0026#34;,80},{\u0026#34;Jack\u0026#34;,70}, {\u0026#34;Jone\u0026#34;,90},{\u0026#34;Tom\u0026#34;,70},{\u0026#34;Alice\u0026#34;,100} }; MyMultimap\u0026lt;string,int\u0026gt; mp; for(int i = 0; i\u0026lt;5; ++ i) mp.insert(make_pair(s[i].name,s[i].score)); Print(mp.begin(),mp.end()); //按姓名从大到小输出 mp.Set(\u0026#34;Tom\u0026#34;,78); //把所有名为\u0026#34;Tom\u0026#34;的学生的成绩都设置为78 Print(mp.begin(),mp.end()); MyMultimap\u0026lt;int,string,less\u0026lt;int\u0026gt; \u0026gt; mp2; for(int i = 0; i\u0026lt;5; ++ i) mp2.insert(make_pair(s[i].score,s[i].name)); Print(mp2.begin(),mp2.end()); //按成绩从小到大输出 mp2.Set(70,\u0026#34;Error\u0026#34;); //把所有成绩为70的学生，名字都改为\u0026#34;Error\u0026#34; Print(mp2.begin(),mp2.end()); cout \u0026lt;\u0026lt; \u0026#34;******\u0026#34; \u0026lt;\u0026lt; endl; mp.clear(); string name; string cmd; int score;\twhile(cin \u0026gt;\u0026gt; cmd ) { if( cmd == \u0026#34;A\u0026#34;) { cin \u0026gt;\u0026gt; name \u0026gt;\u0026gt; score; if(mp.find(name) != mp.end() ) { cout \u0026lt;\u0026lt; \u0026#34;erroe\u0026#34; \u0026lt;\u0026lt; endl; } mp.insert(make_pair(name,score)); } else if(cmd == \u0026#34;Q\u0026#34;) { cin \u0026gt;\u0026gt; name; MyMultimap\u0026lt;string,int\u0026gt;::iterator p = mp.find(name); if( p!= mp.end()) { cout \u0026lt;\u0026lt; p-\u0026gt;second \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Not Found\u0026#34; \u0026lt;\u0026lt; endl; }\t} } return 0; } ","date":"2025-04-23T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0stl%E4%BD%9C%E4%B8%9A%E4%BA%8C/","title":"【程序设计实习】STL作业二"},{"content":"02 编程填空:又见模板 描述 填写代码，按要求输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; // 在此处补充你的代码 int main() { int t; cin \u0026gt;\u0026gt; t; while( t -- ) { int b1[10]; for(int i = 0;i \u0026lt; 10; ++i) cin \u0026gt;\u0026gt; b1[i]; A\u0026lt;int, 10\u0026gt; a1 = b1; cout \u0026lt;\u0026lt; a1[2] \u0026lt;\u0026lt; endl; double b2[5] ; for(int i = 0;i \u0026lt; 5; ++i) cin \u0026gt;\u0026gt; b2[i]; A\u0026lt;double, 5\u0026gt; a2 = b2; cout \u0026lt;\u0026lt; a2.sum() \u0026lt;\u0026lt; endl; string b3[4] ; for(int i = 0;i \u0026lt; 4; ++i) cin \u0026gt;\u0026gt; b3[i]; A\u0026lt;string, 4\u0026gt; a3 = b3; cout \u0026lt;\u0026lt; a3.sum() \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是整数n，表示有n组数据\n每组数据有3行\n第一行是10个整数\n第二行是5个小数\n第三行是4个不带空格的字符串，它们之间用空格分隔\n输出 先输出10个整数里面的第三个\n再输出5个小数的和 (不用考虑小数点后面几位，用cout直接输出即可）\n再输出4个字符串连在一起的字符串\n样例输入 1 2 3 4 1 1 2 3 4 5 6 7 8 9 10 4.2 0.0 3.1 2.7 5.2 Hello , world ! 样例输出 1 2 3 3 15.2 Hello,world! Solution 首先我们能看到 这道题需要我们声明一个template 的模板，如果连这个都想不出来可以回去重修了\n然后，观察到a1=b1 这个套路，就发现我们需要用指针的new 来写这个复制构造函数\n现在 我们发现还需要一个sum函数，这里要注意的是，我们在T temp的时候要赋初值，而这个时候我们很难知道自己要赋什么初值（因为数据类型未知），所以我们直接赋成第一项了\n下面看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template\u0026lt;class T,int siz\u0026gt; class A{ private: T* p; public: A(T* b){ p=new T[siz]; for(int i=0;i\u0026lt;siz;i++){ p[i]=b[i]; } } T operator [](int id){ return p[id]; } T sum(){ T temp=p[0]; for(int i=1;i\u0026lt;siz;i++){ temp+=p[i]; } return temp; } }; int main() { int t; cin \u0026gt;\u0026gt; t; while( t -- ) { int b1[10]; for(int i = 0;i \u0026lt; 10; ++i) cin \u0026gt;\u0026gt; b1[i]; A\u0026lt;int, 10\u0026gt; a1 = b1; cout \u0026lt;\u0026lt; a1[2] \u0026lt;\u0026lt; endl; double b2[5] ; for(int i = 0;i \u0026lt; 5; ++i) cin \u0026gt;\u0026gt; b2[i]; A\u0026lt;double, 5\u0026gt; a2 = b2; cout \u0026lt;\u0026lt; a2.sum() \u0026lt;\u0026lt; endl; string b3[4] ; for(int i = 0;i \u0026lt; 4; ++i) cin \u0026gt;\u0026gt; b3[i]; A\u0026lt;string, 4\u0026gt; a3 = b3; cout \u0026lt;\u0026lt; a3.sum() \u0026lt;\u0026lt; endl; } return 0; } 05 编程填空:很眼熟的模板题 描述 填写代码，按要求输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; // 在此处补充你的代码 string int2string(int x) { return to_string(x); } int int2squareint(int x) { return x * x; } int string2int(string str) { int res = 0; for (string::iterator iter = str.begin(); iter != str.end(); ++iter) res += *iter; return res; } string string2longerstring(string str) { return str + str; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { int b1[10]; for (int i = 0; i \u0026lt; 10; ++i) cin \u0026gt;\u0026gt; b1[i]; A\u0026lt;int, 10\u0026gt; a1 = b1; cout \u0026lt;\u0026lt; a1.sum(2, 6, int2squareint) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1.sum(2, 6, int2string) \u0026lt;\u0026lt; endl; string b2[4]; for (int i = 0; i \u0026lt; 4; ++i) cin \u0026gt;\u0026gt; b2[i]; A\u0026lt;string, 4\u0026gt; a2 = b2; cout \u0026lt;\u0026lt; a2.sum(0, 3, string2int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a2.sum(0, 3, string2longerstring) \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是整数n，表示有n组数据\n每组数据有2行\n第一行是10个整数\n第二行是4个不带空格的字符串，它们之间用空格分隔\n输出 先输出10个整数里面的第3个到第7个的平方和\n再输出10个整数里从第3个到第7个，按照字符串的方式，顺序连接的结果\n再输出4个字符串里，第1个到第4个串中，所有字符的ASCII码加和得到的整数\n再输出4个字符串里，第1个到第4个串，分别复制一遍后，按照字符串的方式，顺序连接的结果。\n样例输入 1 2 3 1 1 2 3 4 5 6 7 8 9 10 Machine , Learning ! 样例输出 1 2 3 4 135 34567 1586 MachineMachine,,LearningLearning!! 提示 3^2 + 4^2 + 5^2 + 6^2 + 7^2 = 135 “Machine,Learning!”中所有字符的ASCII码相加为1586\nSolution 我们看到复制，还是先知道这个方式，然后我要讲的是这个sum函数的定义方式\n我们用模板套模板的方式，定义，这样就一目了然了\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template\u0026lt;class T,int siz\u0026gt; class A{ private: T* p; public: A(T* b){ p=new T[siz]; for(int i=0;i\u0026lt;siz;i++){ p[i]=b[i]; } } template\u0026lt;class T1,class T2\u0026gt; T1 sum(int x,int y,T1 f(T2 k)){ T1 temp=f(p[x]); for(int i=x+1;i\u0026lt;=y;i++){ temp+=f(p[i]); } return temp; } }; string int2string(int x) { return to_string(x); } int int2squareint(int x) { return x * x; } int string2int(string str) { int res = 0; for (string::iterator iter = str.begin(); iter != str.end(); ++iter) res += *iter; return res; } string string2longerstring(string str) { return str + str; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { int b1[10]; for (int i = 0; i \u0026lt; 10; ++i) cin \u0026gt;\u0026gt; b1[i]; A\u0026lt;int, 10\u0026gt; a1 = b1; cout \u0026lt;\u0026lt; a1.sum(2, 6, int2squareint) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a1.sum(2, 6, int2string) \u0026lt;\u0026lt; endl; string b2[4]; for (int i = 0; i \u0026lt; 4; ++i) cin \u0026gt;\u0026gt; b2[i]; A\u0026lt;string, 4\u0026gt; a2 = b2; cout \u0026lt;\u0026lt; a2.sum(0, 3, string2int) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a2.sum(0, 3, string2longerstring) \u0026lt;\u0026lt; endl; } return 0; } 07:很难蒙混过关的CArray3D三维数组模板类 描述 实现一个三维数组模版CArray3D，可以用来生成元素为任意类型变量的三维数组，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { // 在此处补充你的代码 }; CArray3D\u0026lt;int\u0026gt; a(3,4,5); CArray3D\u0026lt;double\u0026gt; b(3,2,2); void PrintA() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 4; ++j) { for(int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } void PrintB() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 2; ++j) { for(int k = 0; k \u0026lt; 2; ++k) cout \u0026lt;\u0026lt; b[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for( int i = 0; i \u0026lt; 3; ++ i ) { a[i]; for( int j = 0; j \u0026lt; 4; ++j ) { a[j][i]; for( int k = 0; k \u0026lt; 5; ++k ) a[i][j][k] = No ++; a[j][i][i];\t} } PrintA(); memset(a[1],-1 ,20*sizeof(int));\tmemset(a[1],-1 ,20*sizeof(int)); PrintA(); memset(a[1][1],0 ,5*sizeof(int));\tPrintA(); for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 2; ++j ) for( int k = 0; k \u0026lt; 2; ++k ) b[i][j][k] = 10.0/(i+j+k+1); PrintB(); int n = a[0][1][2]; double f = b[0][1][1]; cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } 输入 1 无 输出 1 等同于样例 样例输入 1 无 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: 20,21,22,23,24, 25,26,27,28,29, 30,31,32,33,34, 35,36,37,38,39, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: -1,-1,-1,-1,-1, 0,0,0,0,0, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: 10,5, 5,3.33333, layer 1: 5,3.33333, 3.33333,2.5, layer 2: 3.33333,2.5, 2.5,2, **** 7,3.33333 提示 建议做法：\na[i][j][k] 这个表达式的第一个[]返回一个内部类的对象，该内部类也重载了[],且返回值为指针。 必要时需重载对象到指针的强制类型转换运算符 Solution 这题是重头戏！ 感觉跟我之前写的那个，二元数组的实现有点像，这里我主要解释一下吧\n首先肯定要有三维的数据和一个T* 指针，分配出[x*y*z]大小的空间 然后，考虑降维\n我们肯定要重载[]这个函数，而根据题目提示，最后一个[]直接从T类变成T类了，所以只要在三维和二维各自重载一个[]就好 然后，为什么要写这个operator T*呢？\n我们为了迎合memset，要把CArray2D这个类转换成T 类，从而完成任务！\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { public: int x,y,z; T* p; CArray3D(int x,int y,int z):x(x),y(y),z(z){ p=new T[x*y*z]; } class CArray2D{ private: T* dd; int k; public: CArray2D(T* pd,int id):dd(pd),k(id){ } T* operator [](int index){ T* ddg=dd+index*k; return ddg; } operator T*(){ return dd; } }; CArray2D operator [](int index){ T* dd=p+index*y*z; return CArray2D(dd,z); } }; CArray3D\u0026lt;int\u0026gt; a(3,4,5); CArray3D\u0026lt;double\u0026gt; b(3,2,2); void PrintA() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 4; ++j) { for(int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } void PrintB() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 2; ++j) { for(int k = 0; k \u0026lt; 2; ++k) cout \u0026lt;\u0026lt; b[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for( int i = 0; i \u0026lt; 3; ++ i ) { a[i]; for( int j = 0; j \u0026lt; 4; ++j ) { a[j][i]; for( int k = 0; k \u0026lt; 5; ++k ) a[i][j][k] = No ++; a[j][i][i];\t} } PrintA(); memset(a[1],-1 ,20*sizeof(int));\tmemset(a[1],-1 ,20*sizeof(int)); PrintA(); memset(a[1][1],0 ,5*sizeof(int));\tPrintA(); for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 2; ++j ) for( int k = 0; k \u0026lt; 2; ++k ) b[i][j][k] = 10.0/(i+j+k+1); PrintB(); int n = a[0][1][2]; double f = b[0][1][1]; cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } 10.简单的整数类 描述 输入两个数 m,n( 0\u0026lt;=m,n \u0026lt;= 9)，输出它们的乘积\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class MyNum{ public: char C; MyNum(char c=\u0026#39;0\u0026#39;): C(c) {} // 在此处补充你的代码 }; int main() { char m,n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; MyNum n1(m), n2(n); MyNum n3; n3 = n1*n2; cout \u0026lt;\u0026lt; int(n3) \u0026lt;\u0026lt; endl; return 0; } 输入 两个数，m,n，确保乘积小于10\n输出 它们的乘积\n样例输入 1 3 2 样例输出 1 6 Solution 这题的关键点在于，要想到，当超出9的范围的时候，要用什么表示\n而这个在MyNum这个复制构造函数的缺省项中已经写得很明白了，就是跟'0\u0026rsquo;这个字符有关 于是解题思路就很明朗了\n但是，我们还要看，这里有个明显的类型转换函数标志，就是cout这边的int\n再补上，大功告成！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class MyNum{ public: char C; MyNum(char c=\u0026#39;0\u0026#39;): C(c) {} MyNum operator *(const MyNum \u0026amp;s){ int x=C-\u0026#39;0\u0026#39;; int y=s.C-\u0026#39;0\u0026#39;; int d=x*y; MyNum k; k.C=\u0026#39;0\u0026#39;+d; return k; } operator int(){ return C-\u0026#39;0\u0026#39;; } }; int main() { char m,n; cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; MyNum n1(m), n2(n); MyNum n3; n3 = n1*n2; cout \u0026lt;\u0026lt; int(n3) \u0026lt;\u0026lt; endl; return 0; } ","date":"2025-04-20T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第六次上机复盘"},{"content":"A:goodcopy 描述 编写GoodCopy类模板，使得程序按指定方式输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; struct GoodCopy { // 在此处补充你的代码 }; int a[200]; int b[200]; string c[200]; string d[200]; template \u0026lt;class T\u0026gt; void Print(T s,T e) { for(; s != e; ++s) cout \u0026lt;\u0026lt; * s \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { int t; cin \u0026gt;\u0026gt; t; while( t -- ) { int m ; cin \u0026gt;\u0026gt; m; for(int i = 0;i \u0026lt; m; ++i) cin \u0026gt;\u0026gt; a[i]; GoodCopy\u0026lt;int\u0026gt;()(a,a+m,b); Print(b,b+m); GoodCopy\u0026lt;int\u0026gt;()(a,a+m,a+m/2); Print(a+m/2,a+m/2 + m); for(int i = 0;i \u0026lt; m; ++i) cin \u0026gt;\u0026gt; c[i]; GoodCopy\u0026lt;string\u0026gt;()(c,c+m,d); Print(c,c+m); GoodCopy\u0026lt;string\u0026gt;()(c,c+m,c+m/2); Print(c+m/2,c+m/2 + m); } return 0; } 输入 第一行是整数 t,表示数据组数\n每组数据：\n第一行是整数 n , n \u0026lt; 50\n第二行是 n 个整数\n第三行是 n 个字符串\n输出 将输入的整数原序输出两次，用\u0026quot;,\u0026ldquo;分隔\n然后将输入的字符串原序输出两次，也用 \u0026ldquo;,\u0026ldquo;分隔\n样例输入 1 2 3 4 5 6 7 2 4 1 2 3 4 Tom Jack Marry Peking 1 0 Ted 样例输出 1 2 3 4 5 6 7 8 1,2,3,4, 1,2,3,4, Tom,Jack,Marry,Peking, Tom,Jack,Marry,Peking, 0, 0, Ted, Ted, Solution 我们定义了一个GoodCopy类（结构体，不用管public，自动public的），然后这个类用于生成一个函数（看下面）\n所以，只需要处理好迭代器的顺序，要从后往前，不然重叠的那块会先被迭代掉\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; struct GoodCopy { public: void operator()(T* a,T* b,T* c){ for(int i=b-a-1;i\u0026gt;=0;i--){ *(c+i)=*(a+i); } } }; int a[200]; int b[200]; string c[200]; string d[200]; template \u0026lt;class T\u0026gt; void Print(T s,T e) { for(; s != e; ++s) cout \u0026lt;\u0026lt; * s \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } int main() { int t; cin \u0026gt;\u0026gt; t; while( t -- ) { int m ; cin \u0026gt;\u0026gt; m; for(int i = 0;i \u0026lt; m; ++i) cin \u0026gt;\u0026gt; a[i]; GoodCopy\u0026lt;int\u0026gt;()(a,a+m,b); Print(b,b+m); GoodCopy\u0026lt;int\u0026gt;()(a,a+m,a+m/2); Print(a+m/2,a+m/2 + m); for(int i = 0;i \u0026lt; m; ++i) cin \u0026gt;\u0026gt; c[i]; GoodCopy\u0026lt;string\u0026gt;()(c,c+m,d); Print(c,c+m); GoodCopy\u0026lt;string\u0026gt;()(c,c+m,c+m/2); Print(c+m/2,c+m/2 + m); } return 0; } B:按距离排序 描述 程序填空，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T1,class T2\u0026gt; struct Closer { // 在此处补充你的代码 }; int Distance1(int n1,int n2) { return abs(n1-n2); } int Distance2(const string \u0026amp; s1, const string \u0026amp; s2) { return abs((int)s1.length()- (int) s2.length()); } int a[10] = { 0,3,1,4,7,9,20,8,10,15}; string b[6] = {\u0026#34;American\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;To\u0026#34;,\u0026#34;Peking\u0026#34;,\u0026#34;abcdefghijklmnop\u0026#34;,\u0026#34;123456789\u0026#34;}; int main() { int n;string s; while( cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s ) { sort(a,a+10,Closer\u0026lt;int ,int (*)(int ,int)\u0026gt; (n,Distance1)); for(int i = 0;i \u0026lt; 10; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; sort(b,b+6,Closer\u0026lt;string,int (*)(const string \u0026amp;,const string \u0026amp; )\u0026gt; (s,Distance2)); for(int i = 0;i \u0026lt; 6; ++i) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } return 0; } 输入 多组数据，每组一行，是一个整数n和一个字符串s\n输出 定义两个整数的距离为两个整数差的绝对值\n定义两个字符串的距离为两个字符串长度差的绝对值\n对每组数据：\n对数组a按和n的距离从小到大排序后输出。距离相同的，值小的排在前面。\n然后对数组b，按照和s的距离从小到大输出。距离相同的，字典序小的排在前面\n样例输入 1 2 2 a123456 4 a12345 样例输出 1 2 3 4 1,3,0,4,7,8,9,10,15,20, American,Peking,123456789,Jack,To,abcdefghijklmnop, 4,3,1,7,0,8,9,10,15,20, Peking,American,Jack,123456789,To,abcdefghijklmnop, Solution 这里可以看到，Closer生成了一个匿名对象，用于sort的比较器\n这个匿名对象函数，肯定是需要接受两个对象，然后判断这两个对象从而给出一个bool对象\n不过，在本题中，这两个对象还需要通过引用原有函数进行进一步比较，上面的两个模板也暗示了我们，一个应该是题目所需的距离，另一个应该是判断函数\n这样就理得很清楚了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T1,class T2\u0026gt; struct Closer { T1 val; T2 func; Closer(T1 val,T2 func):val(val),func(func){ } bool operator()(T1 a,T1 b){ int c=func(a,val); int d=func(b,val); if(c!=d){ return c\u0026lt;d; } return a\u0026lt;b; } }; int Distance1(int n1,int n2) { return abs(n1-n2); } int Distance2(const string \u0026amp; s1, const string \u0026amp; s2) { return abs((int)s1.length()- (int) s2.length()); } int a[10] = { 0,3,1,4,7,9,20,8,10,15}; string b[6] = {\u0026#34;American\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;To\u0026#34;,\u0026#34;Peking\u0026#34;,\u0026#34;abcdefghijklmnop\u0026#34;,\u0026#34;123456789\u0026#34;}; int main() { int n;string s; while( cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s ) { sort(a,a+10,Closer\u0026lt;int ,int (*)(int ,int)\u0026gt; (n,Distance1)); for(int i = 0;i \u0026lt; 10; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; sort(b,b+6,Closer\u0026lt;string,int (*)(const string \u0026amp;,const string \u0026amp; )\u0026gt; (s,Distance2)); for(int i = 0;i \u0026lt; 6; ++i) cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } return 0; } C:很难蒙混过关的CArray3D三维数组模板类 描述 实现一个三维数组模版CArray3D，可以用来生成元素为任意类型变量的三维数组，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { // 在此处补充你的代码 }; CArray3D\u0026lt;int\u0026gt; a(3,4,5); CArray3D\u0026lt;double\u0026gt; b(3,2,2); void PrintA() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 4; ++j) { for(int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } void PrintB() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 2; ++j) { for(int k = 0; k \u0026lt; 2; ++k) cout \u0026lt;\u0026lt; b[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for( int i = 0; i \u0026lt; 3; ++ i ) { a[i]; for( int j = 0; j \u0026lt; 4; ++j ) { a[j][i]; for( int k = 0; k \u0026lt; 5; ++k ) a[i][j][k] = No ++; a[j][i][i];\t} } PrintA(); memset(a[1],-1 ,20*sizeof(int));\tmemset(a[1],-1 ,20*sizeof(int)); PrintA(); memset(a[1][1],0 ,5*sizeof(int));\tPrintA(); for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 2; ++j ) for( int k = 0; k \u0026lt; 2; ++k ) b[i][j][k] = 10.0/(i+j+k+1); PrintB(); int n = a[0][1][2]; double f = b[0][1][1]; cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } 输入 1 无 输出 1 等同于样例 样例输入 1 无 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: 20,21,22,23,24, 25,26,27,28,29, 30,31,32,33,34, 35,36,37,38,39, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: 0,1,2,3,4, 5,6,7,8,9, 10,11,12,13,14, 15,16,17,18,19, layer 1: -1,-1,-1,-1,-1, 0,0,0,0,0, -1,-1,-1,-1,-1, -1,-1,-1,-1,-1, layer 2: 40,41,42,43,44, 45,46,47,48,49, 50,51,52,53,54, 55,56,57,58,59, layer 0: 10,5, 5,3.33333, layer 1: 5,3.33333, 3.33333,2.5, layer 2: 3.33333,2.5, 2.5,2, **** 7,3.33333 提示 建议做法：\na[i][j][k] 这个表达式的第一个[]返回一个内部类的对象，该内部类也重载了[],且返回值为指针。 必要时需重载对象到指针的强制类型转换运算符 Solution 这题是重头戏！\n感觉跟我之前写的那个，二元数组的实现有点像，这里我主要解释一下吧\n首先肯定要有三维的数据和一个T* 指针，分配出[x*y*z]大小的空间\n然后，考虑降维\n我们肯定要重载[]这个函数，而根据题目提示，最后一个[]直接从T类变成T类了，所以只要在三维和二维各自重载一个[]就好\n然后，为什么要写这个operator T*呢？\n我们为了迎合memset，要把CArray2D这个类转换成T 类，从而完成任务！\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CArray3D { public: int x,y,z; T* p; CArray3D(int x,int y,int z):x(x),y(y),z(z){ p=new T[x*y*z]; } class CArray2D{ private: T* dd; int k; public: CArray2D(T* pd,int id):dd(pd),k(id){ } T* operator [](int index){ T* ddg=dd+index*k; return ddg; } operator T*(){ return dd; } }; CArray2D operator [](int index){ T* dd=p+index*y*z; return CArray2D(dd,z); } }; CArray3D\u0026lt;int\u0026gt; a(3,4,5); CArray3D\u0026lt;double\u0026gt; b(3,2,2); void PrintA() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 4; ++j) { for(int k = 0; k \u0026lt; 5; ++k) cout \u0026lt;\u0026lt; a[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } void PrintB() { for(int i = 0;i \u0026lt; 3; ++i) { cout \u0026lt;\u0026lt; \u0026#34;layer \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; endl; for(int j = 0; j \u0026lt; 2; ++j) { for(int k = 0; k \u0026lt; 2; ++k) cout \u0026lt;\u0026lt; b[i][j][k] \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; cout \u0026lt;\u0026lt; endl; } } } int main() { int No = 0; for( int i = 0; i \u0026lt; 3; ++ i ) { a[i]; for( int j = 0; j \u0026lt; 4; ++j ) { a[j][i]; for( int k = 0; k \u0026lt; 5; ++k ) a[i][j][k] = No ++; a[j][i][i];\t} } PrintA(); memset(a[1],-1 ,20*sizeof(int));\tmemset(a[1],-1 ,20*sizeof(int)); PrintA(); memset(a[1][1],0 ,5*sizeof(int));\tPrintA(); for( int i = 0; i \u0026lt; 3; ++ i ) for( int j = 0; j \u0026lt; 2; ++j ) for( int k = 0; k \u0026lt; 2; ++k ) b[i][j][k] = 10.0/(i+j+k+1); PrintB(); int n = a[0][1][2]; double f = b[0][1][1]; cout \u0026lt;\u0026lt; \u0026#34;****\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl; return 0; } D:函数对象的过滤器 描述 程序填空输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct A { int v; A() { } A(int n):v(n) { }; bool operator\u0026lt;(const A \u0026amp; a) const { return v \u0026lt; a.v; } }; // 在此处补充你的代码 template \u0026lt;class T\u0026gt; void Print(T s,T e) { for(;s!=e; ++s) cout \u0026lt;\u0026lt; *s \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } template \u0026lt;class T1, class T2,class T3\u0026gt; T2 Filter( T1 s,T1 e, T2 s2, T3 op) { for(;s != e; ++s) { if( op(*s)) { * s2 = * s; ++s2; } } return s2; } ostream \u0026amp; operator \u0026lt;\u0026lt;(ostream \u0026amp; o,A \u0026amp; a) { o \u0026lt;\u0026lt; a.v; return o; } vector\u0026lt;int\u0026gt; ia; vector\u0026lt;A\u0026gt; aa; int main() { int m,n; while(cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n) { ia.clear(); aa.clear(); int k,tmp; cin \u0026gt;\u0026gt; k; for(int i = 0;i \u0026lt; k; ++i) { cin \u0026gt;\u0026gt; tmp; ia.push_back(tmp); aa.push_back(tmp); } vector\u0026lt;int\u0026gt; ib(k); vector\u0026lt;A\u0026gt; ab(k); vector\u0026lt;int\u0026gt;::iterator p = Filter(ia.begin(),ia.end(),ib.begin(),FilterClass\u0026lt;int\u0026gt;(m,n)); Print(ib.begin(),p); vector\u0026lt;A\u0026gt;::iterator pp = Filter(aa.begin(),aa.end(),ab.begin(),FilterClass\u0026lt;A\u0026gt;(m,n)); Print(ab.begin(),pp); } return 0; } 输入 多组数据\n每组数据两行\n第一行是两个整数 m 和 n\n第二行先是一个整数k ,然后后面跟着k个整数\n输出 对每组数据，按原顺序输出第二行的后k个整数中，大于m且小于n的数 输出两遍 数据保证一定能找到符合要求的整数\n样例输入 1 2 3 4 1 3 1 2 2 8 5 1 2 3 4 9 样例输出 1 2 3 4 2, 2, 3,4, 3,4, Solution 本题需要我们实现一个FilterClass类，这个类，跟第二题差不多，还是生成一个op判断函数，那就完事了，只不过接收变量从一个变成两个了而已\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; struct A { int v; A() { } A(int n):v(n) { }; bool operator\u0026lt;(const A \u0026amp; a) const { return v \u0026lt; a.v; } }; template\u0026lt;class T\u0026gt; class FilterClass{ public: T m,n; FilterClass(T m,T n):m(m),n(n){ } bool operator()(T val){ return (m\u0026lt;val)\u0026amp;\u0026amp;(val\u0026lt;n); } }; template \u0026lt;class T\u0026gt; void Print(T s,T e) { for(;s!=e; ++s) cout \u0026lt;\u0026lt; *s \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } template \u0026lt;class T1, class T2,class T3\u0026gt; T2 Filter( T1 s,T1 e, T2 s2, T3 op) { for(;s != e; ++s) { if( op(*s)) { * s2 = * s; ++s2; } } return s2; } ostream \u0026amp; operator \u0026lt;\u0026lt;(ostream \u0026amp; o,A \u0026amp; a) { o \u0026lt;\u0026lt; a.v; return o; } vector\u0026lt;int\u0026gt; ia; vector\u0026lt;A\u0026gt; aa; int main() { int m,n; while(cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n) { ia.clear(); aa.clear(); int k,tmp; cin \u0026gt;\u0026gt; k; for(int i = 0;i \u0026lt; k; ++i) { cin \u0026gt;\u0026gt; tmp; ia.push_back(tmp); aa.push_back(tmp); } vector\u0026lt;int\u0026gt; ib(k); vector\u0026lt;A\u0026gt; ab(k); vector\u0026lt;int\u0026gt;::iterator p = Filter(ia.begin(),ia.end(),ib.begin(),FilterClass\u0026lt;int\u0026gt;(m,n)); Print(ib.begin(),p); vector\u0026lt;A\u0026gt;::iterator pp = Filter(aa.begin(),aa.end(),ab.begin(),FilterClass\u0026lt;A\u0026gt;(m,n)); Print(ab.begin(),pp); } return 0; } E:白给的list排序 描述 程序填空，产生指定输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; int main() {\tdouble a[] = {1.2,3.4,9.8,7.3,2.6}; list\u0026lt;double\u0026gt; lst(a,a+5); lst.sort( // 在此处补充你的代码 ); for(list\u0026lt;double\u0026gt;::iterator i = lst.begin(); i != lst.end(); ++i) cout \u0026lt;\u0026lt; * i \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; return 0; } 输入 1 无 输出 1 9.8,7.3,3.4,2.6,1.2, 样例输入 1 无 样例输出 1 同输入 Solution 这道题，就是考察课件内容\n五一还需要好好地把课件内容过一遍\nSTL中给我们定义了一个比较函数\ngreater\u0026lt;数据类型\u0026gt;()\n这个函数自动实现降序比较 那就完事了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; int main() {\tdouble a[] = {1.2,3.4,9.8,7.3,2.6}; list\u0026lt;double\u0026gt; lst(a,a+5); lst.sort( greater\u0026lt;double\u0026gt;() ); for(list\u0026lt;double\u0026gt;::iterator i = lst.begin(); i != lst.end(); ++i) cout \u0026lt;\u0026lt; * i \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; return 0; } F:我自己的ostream_iterator 描述 程序填空输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T1,class T2\u0026gt; void Copy(T1 s,T1 e, T2 x) { for(; s != e; ++s,++x) *x = *s; } template\u0026lt;class T\u0026gt; class myostream_iteraotr { // 在此处补充你的代码 }; int main() {\tconst int SIZE = 5; int a[SIZE] = {5,21,14,2,3}; double b[SIZE] = { 1.4, 5.56,3.2,98.3,3.3}; list\u0026lt;int\u0026gt; lst(a,a+SIZE); myostream_iteraotr\u0026lt;int\u0026gt; output(cout,\u0026#34;,\u0026#34;); Copy( lst.begin(),lst.end(),output); cout \u0026lt;\u0026lt; endl; myostream_iteraotr\u0026lt;double\u0026gt; output2(cout,\u0026#34;--\u0026#34;); Copy(b,b+SIZE,output2); return 0; } 输入 1 无 输出 1 2 5,21,14,2,3, 1.4--5.56--3.2--98.3--3.3-- 样例输入 1 无 样例输出 1 同输入 Solution 上次不是有个“山寨的istream_iterator”这道题嘛，提醒我们要去参考STL的原装代码\n然后我就去看了一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ostream_iterator\u0026amp; operator=(const _Ty\u0026amp; _Val) { // insert value into output stream, followed by delimiter *_Myostr \u0026lt;\u0026lt; _Val; if (_Mydelim) { *_Myostr \u0026lt;\u0026lt; _Mydelim; } return *this; } _NODISCARD ostream_iterator\u0026amp; operator*() noexcept /* strengthened */ { return *this; } ostream_iterator\u0026amp; operator++() noexcept /* strengthened */ { return *this; } 到这里一切都很明朗了，事实上本来就只需要重载\u0026rsquo;++\u0026rsquo;、\u0026rsquo;*\u0026lsquo;和\u0026rsquo;=\u0026lsquo;三个符号，无非是重载方式调一下而已\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T1,class T2\u0026gt; void Copy(T1 s,T1 e, T2 x) { for(; s != e; ++s,++x) *x = *s; } template\u0026lt;class T\u0026gt; class myostream_iteraotr { private: ostream\u0026amp; ost; T n; string k; public: myostream_iteraotr(ostream\u0026amp; ost,string x):ost(ost),k(x) { } myostream_iteraotr\u0026amp; operator++(){ return *this; } myostream_iteraotr\u0026amp; operator*(){ return *this; } void operator=(const T\u0026amp; other){ ost\u0026lt;\u0026lt;other\u0026lt;\u0026lt;k; } }; int main() {\tconst int SIZE = 5; int a[SIZE] = {5,21,14,2,3}; double b[SIZE] = { 1.4, 5.56,3.2,98.3,3.3}; list\u0026lt;int\u0026gt; lst(a,a+SIZE); myostream_iteraotr\u0026lt;int\u0026gt; output(cout,\u0026#34;,\u0026#34;); Copy( lst.begin(),lst.end(),output); cout \u0026lt;\u0026lt; endl; myostream_iteraotr\u0026lt;double\u0026gt; output2(cout,\u0026#34;--\u0026#34;); Copy(b,b+SIZE,output2); return 0; } ","date":"2025-04-18T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0stl%E4%BD%9C%E4%B8%9A%E4%B8%80/","title":"【程序设计实习】STL作业一"},{"content":"A:简单的SumArray 描述 填写模板 PrintArray,使得程序输出结果是： TomJackMaryJohn 10 不得编写SumArray函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; T SumArray( // 在此处补充你的代码 } int main() { string array[4] = { \u0026#34;Tom\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;Mary\u0026#34;,\u0026#34;John\u0026#34;}; cout \u0026lt;\u0026lt; SumArray(array,array+4) \u0026lt;\u0026lt; endl; int a[4] = { 1, 2, 3, 4}; //提示：1+2+3+4 = 10 cout \u0026lt;\u0026lt; SumArray(a,a+4) \u0026lt;\u0026lt; endl; return 0; } 输入 1 无 输出 1 2 TomJackMaryJohn 10 样例输入 1 无 样例输出 1 2 TomJackMaryJohn 10 Solution 就是简单的题目 第一次知道对于一个指针i,*i表示的是对i解指针，也就是获取i指向的地址的值（没错又忘了）\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; T SumArray(T *a,T *b){ T c=*a; for(T* i=a+1;i\u0026lt;b;i++){ c+=*i; } return c; } int main() { string array[4] = { \u0026#34;Tom\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;Mary\u0026#34;,\u0026#34;John\u0026#34;}; cout \u0026lt;\u0026lt; SumArray(array,array+4) \u0026lt;\u0026lt; endl; int a[4] = { 1, 2, 3, 4}; //提示：1+2+3+4 = 10 cout \u0026lt;\u0026lt; SumArray(a,a+4) \u0026lt;\u0026lt; endl; return 0; } B:简单的foreach 描述 编写MyForeach模板，使程序按要求输出 不得编写 MyForeach函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; // 在此处补充你的代码 void Print(string s) { cout \u0026lt;\u0026lt; s; } void Inc(int \u0026amp; n) { ++ n; } string array[100]; int a[100]; int main() { int m,n; while(cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n) { for(int i = 0;i \u0026lt; m; ++i) cin \u0026gt;\u0026gt; array[i]; for(int j = 0; j \u0026lt; n; ++j) cin \u0026gt;\u0026gt; a[j]; MyForeach(array,array+m,Print);\tcout \u0026lt;\u0026lt; endl; MyForeach(a,a+n,Inc);\tfor(int i = 0;i \u0026lt; n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } return 0; } 输入 多组数据\n每组数据第一行是两个整数 m 和 n ,都不超过 50\n第二行是m个不带空格的字符串\n第三行是 n个整数\n输出 对每组数据\n第一行输出所有输入字符串连在一起的结果\n第二行输出输入中的每个整数加1的结果\n样例输入 1 2 3 4 5 6 3 4 Tom Mike Jack 1 2 3 4 1 2 Peking 100 200 样例输出 1 2 3 4 TomMikeJack 2,3,4,5, Peking 101,201, Solution 跟上题差不多，还是没什么难的\n记住函数的引用方式就行\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template\u0026lt;class T1,class T2\u0026gt; void MyForeach(T1 *a,T1 *b,void f(T2 t)){ for(T1 *i=a;i\u0026lt;b;i++){ f(*i); } } void Print(string s) { cout \u0026lt;\u0026lt; s; } void Inc(int \u0026amp; n) { ++ n; } string array[100]; int a[100]; int main() { int m,n; while(cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n) { for(int i = 0;i \u0026lt; m; ++i) cin \u0026gt;\u0026gt; array[i]; for(int j = 0; j \u0026lt; n; ++j) cin \u0026gt;\u0026gt; a[j]; MyForeach(array,array+m,Print);\tcout \u0026lt;\u0026lt; endl; MyForeach(a,a+n,Inc);\tfor(int i = 0;i \u0026lt; n; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; } return 0; } C:简单的Filter 描述 编写Filter模板，使得程序产生指定输出 不得编写 Filter函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; // 在此处补充你的代码 bool LargerThan2(int n) { return n \u0026gt; 2; } bool LongerThan3(string s) { return s.length() \u0026gt; 3; } string as1[5] = {\u0026#34;Tom\u0026#34;,\u0026#34;Mike\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;Ted\u0026#34;,\u0026#34;Lucy\u0026#34;}; string as2[5]; int a1[5] = { 1,2,3,4,5}; int a2[5]; int main() { string * p = Filter(as1,as1+5,as2,LongerThan3); for(int i = 0;i \u0026lt; p - as2; ++i) cout \u0026lt;\u0026lt; as2[i]; cout \u0026lt;\u0026lt; endl; int * p2 = Filter(a1,a1+5,a2,LargerThan2); for(int i = 0;i \u0026lt; p2-a2; ++i) cout \u0026lt;\u0026lt; a2[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; return 0; } 输入 1 无 输出 1 2 MikeJackLucy 3,4,5, 样例输入 1 无 样例输出 1 2 MikeJackLucy 3,4,5, Solution 还是没啥难的 注意一下函数的引用方式就行\n下面看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template\u0026lt;class T1,class T2\u0026gt; T1* Filter(T1 *a,T1 *b,T1 *c,bool f(T2 t)){ for(T1 *i=a;i\u0026lt;b;i++){ if(f(*i)){ *c=*i; c++; } } return c; } bool LargerThan2(int n) { return n \u0026gt; 2; } bool LongerThan3(string s) { return s.length() \u0026gt; 3; } string as1[5] = {\u0026#34;Tom\u0026#34;,\u0026#34;Mike\u0026#34;,\u0026#34;Jack\u0026#34;,\u0026#34;Ted\u0026#34;,\u0026#34;Lucy\u0026#34;}; string as2[5]; int a1[5] = { 1,2,3,4,5}; int a2[5]; int main() { string * p = Filter(as1,as1+5,as2,LongerThan3); for(int i = 0;i \u0026lt; p - as2; ++i) cout \u0026lt;\u0026lt; as2[i]; cout \u0026lt;\u0026lt; endl; int * p2 = Filter(a1,a1+5,a2,LargerThan2); for(int i = 0;i \u0026lt; p2-a2; ++i) cout \u0026lt;\u0026lt; a2[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; return 0; } D:你真的搞清楚为啥 while(cin \u0026raquo; n) 能成立了吗？ 描述 读入两个整数，输出两个整数 ，直到碰到-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; using namespace std; class MyCin { // 在此处补充你的代码 }; int main() { MyCin m; int n1,n2; while( m \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2) cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; return 0; } 输入 多组数据，每组一行，是两个整数\n输出 对每组数据，原样输出 当碰到输入中出现-1 时，程序结束\n输入中保证会有 -1\n样例输入 1 2 3 4 12 44 344 555 -1 2 3 样例输出 1 2 12 44 344 555 Solution 我们需要定义一个MyCin类以实现输入（并且是链式）功能\n那么，我们要怎么办？\n肯定是要重载运算符\n同时，为了实现链式的输入，我们只能一个一个输出\n怎么定义出现-1时程序结束呢？\n上课的时候老师有讲到 while(cin\u0026raquo;n)\n是由一个istream类函数和一个bool类函数组成的\n我们这里就需要去编写这个bool函数\n所以我们定义一个初始值为true的bool型变量flag,当输入不为-1的时候就单纯输入，为-1的时候flag就变为0，同时，用operator bool()返回flag(上课老师有讲)，结束while\n而两个return *this;\n表明的是，当flag是false就不输入了（直接return *this)，只有是true才输入\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; class MyCin { private: bool flag; public: MyCin():flag(true){} MyCin \u0026amp;operator \u0026gt;\u0026gt;(int \u0026amp;n){ if(!flag) return *this; cin\u0026gt;\u0026gt;n; if(n==-1) flag=false; return *this; } operator bool(){ return flag; } }; int main() { MyCin m; int n1,n2; while( m \u0026gt;\u0026gt; n1 \u0026gt;\u0026gt; n2) cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n2 \u0026lt;\u0026lt; endl; return 0; } E:山寨版istream_iterator 描述 模仿C++标准模板库istream_iterator用法，实现CMyistream_iterator使得程序按要求输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CMyistream_iterator { // 在此处补充你的代码 }; int main() { int t; cin \u0026gt;\u0026gt; t; while( t -- ) { CMyistream_iterator\u0026lt;int\u0026gt; inputInt(cin); int n1,n2,n3; n1 = * inputInt; //读入 n1 int tmp = * inputInt; cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; endl; inputInt ++; n2 = * inputInt; //读入 n2 inputInt ++; n3 = * inputInt; //读入 n3 cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n2\u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; CMyistream_iterator\u0026lt;string\u0026gt; inputStr(cin); string s1,s2; s1 = * inputStr; inputStr ++; s2 = * inputStr; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是整数t，表示有t组数据\n每组数据一行，三个整数加两个字符串。字符串是不含空格的\n输出 对每组数据，输出二行\n在第一行输出第一个数\n第二行原样输出输入的内容\n样例输入 1 2 3 2 79 90 20 hello me 12 34 19 take up 样例输出 1 2 3 4 79 79 90 20 hello me 12 12 34 19 take up 提示 C++标准模板库 istream_iterator模版使用说明：\n其构造函数执行过程中就会要求输入，然后每次执行++，则读取输入流中的下一个项目，执行 * 则返回上次从输入流中读取的项目。例如，下面程序运行时，就会等待用户输入数据，输入数据后程序才会结束：\n1 2 3 4 5 6 7 #include #include using namespace std; int main() { istream_iterator inputInt(cin); return 0; } 下面程序运行时，如果输入 12 34 程序输出结果是： 12,12\n1 2 3 4 5 6 7 8 9 #include #include using namespace std; int main() { istream_iterator inputInt(cin); cout \u0026lt;\u0026lt; * inputInt \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; * inputInt \u0026lt;\u0026lt; endl; return 0; } 下面程序运行时，如果输入 12 34 56程序输出结果是： 12,56\n1 2 3 4 5 6 7 8 9 10 11 12 #include #include using namespace std; int main() { istream_iterator inputInt(cin); cout \u0026lt;\u0026lt; * inputInt \u0026lt;\u0026lt; \u0026#34;,\u0026#34; ; inputInt ++; inputInt ++; cout \u0026lt;\u0026lt; * inputInt; return 0; } Solution 我们有看到，类中的某个元素一开始被赋为cin了，说明这应该是一个cin型变量，且在所需要写的类中\n然后，我们再看到提示中的句子 知道我们要重载一个* 和++（因为是后缀所以要加上一个int)，这时候就很一目了然了\n哦，默认构造函数别忘了写\n下面看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class CMyistream_iterator { private: istream\u0026amp; ist; T n; public: CMyistream_iterator(){} CMyistream_iterator(istream \u0026amp;ist):ist(ist){ ist\u0026gt;\u0026gt;n; } T operator*(){ return n; } void operator++(int){ ist\u0026gt;\u0026gt;n; } }; int main() { int t; cin \u0026gt;\u0026gt; t; while( t -- ) { CMyistream_iterator\u0026lt;int\u0026gt; inputInt(cin); int n1,n2,n3; n1 = * inputInt; //读入 n1 int tmp = * inputInt; cout \u0026lt;\u0026lt; tmp \u0026lt;\u0026lt; endl; inputInt ++; n2 = * inputInt; //读入 n2 inputInt ++; n3 = * inputInt; //读入 n3 cout \u0026lt;\u0026lt; n1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n2\u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; n3 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; CMyistream_iterator\u0026lt;string\u0026gt; inputStr(cin); string s1,s2; s1 = * inputStr; inputStr ++; s2 = * inputStr; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; } return 0; } F:这个模板并不难 描述 程序填空，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class myclass { // 在此处补充你的代码 ~myclass( ) { delete [] p; } void Show() { for( int i = 0;i \u0026lt; size;i ++ ) { cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; } cout \u0026lt;\u0026lt; endl; } }; int a[100]; int main() { char line[100]; while( cin \u0026gt;\u0026gt; line ) { myclass\u0026lt;char\u0026gt; obj(line,strlen(line));; obj.Show(); int n; cin \u0026gt;\u0026gt; n; for(int i = 0;i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; myclass\u0026lt;int\u0026gt; obj2(a,n); obj2.Show(); } return 0; } 输入 多组数据。每组第一行是一个不含空格的字符串\n第二行是整数n\n第三行是n个整数\n输出 对每组数据，先依次输出输入字符串的每个字母，并且在每个字母后面加逗号\n然后依次再输出输入的n个整数 ，在每个整数后面加逗号\n样例输入 1 2 3 4 5 6 Tom 3 3 4 5 Jack 4 1 2 3 4 样例输出 1 2 3 4 T,o,m, 3,4,5, J,a,c,k, 1,2,3,4, Solution 我们从题目给出的函数中看出，肯定有一个size,同时还有一个指针，这个指针需要创建出一块连续的大小为size的空间，而这些都要在一个复制构造函数中完成，这样就完事了\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; template \u0026lt;class T\u0026gt; class myclass { int size; T* p; public: myclass(T* k,int b):size(b){ p=new T[size]; for(int i=0;i\u0026lt;size;i++){ p[i]=k[i]; } } ~myclass( ) { delete [] p; } void Show() { for( int i = 0;i \u0026lt; size;i ++ ) { cout \u0026lt;\u0026lt; p[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; } cout \u0026lt;\u0026lt; endl; } }; int a[100]; int main() { char line[100]; while( cin \u0026gt;\u0026gt; line ) { myclass\u0026lt;char\u0026gt; obj(line,strlen(line));; obj.Show(); int n; cin \u0026gt;\u0026gt; n; for(int i = 0;i \u0026lt; n; ++i) cin \u0026gt;\u0026gt; a[i]; myclass\u0026lt;int\u0026gt; obj2(a,n); obj2.Show(); } return 0; } G:排序，又见排序! 描述 自己编写一个能对任何类型的数组进行排序的mysort函数模版。只能写一个mysort模板，不能写mysort函数！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;iostream\u0026gt; using namespace std; bool Greater2(int n1,int n2) { return n1 \u0026gt; n2; } bool Greater1(int n1,int n2) { return n1 \u0026lt; n2; } bool Greater3(double d1,double d2) { return d1 \u0026lt; d2; } template \u0026lt;class T1,class T2\u0026gt; void mysort( // 在此处补充你的代码 #define NUM 5 int main() { int an[NUM] = { 8,123,11,10,4 }; mysort(an,an+NUM,Greater1); //从小到大排序 for( int i = 0;i \u0026lt; NUM; i ++ ) cout \u0026lt;\u0026lt; an[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; mysort(an,an+NUM,Greater2); //从大到小排序 cout \u0026lt;\u0026lt; endl; for( int i = 0;i \u0026lt; NUM; i ++ ) cout \u0026lt;\u0026lt; an[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; double d[6] = { 1.4,1.8,3.2,1.2,3.1,2.1}; mysort(d+1,d+5,Greater3); //将数组从下标1到下标4从小到大排序 for( int i = 0;i \u0026lt; 6; i ++ ) cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; return 0; } 输入 1 无 输出 1 2 3 4,8,10,11,123, 123,11,10,8,4, 1.4,1.2,1.8,3.1,3.2,2.1, 样例输入 1 无 样例输出 1 2 3 4,8,10,11,123, 123,11,10,8,4, 1.4,1.2,1.8,3.1,3.2,2.1, Solution 题目需要我们写mysort这个函数的代码\n当然，第一反应就是冒泡排序，而题目的排序规则都已经给好了，就直接冒泡！\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; using namespace std; bool Greater2(int n1,int n2) { return n1 \u0026gt; n2; } bool Greater1(int n1,int n2) { return n1 \u0026lt; n2; } bool Greater3(double d1,double d2) { return d1 \u0026lt; d2; } template \u0026lt;class T1,class T2\u0026gt; void mysort( T1 *a,T1 *b,bool f(T2 c,T2 d)){ for(T1 *i=a;i\u0026lt;b;i++){ for(T1 *j=i+1;j\u0026lt;b;j++){ if(!f(*i,*j)){ swap(*i,*j); } } } } #define NUM 5 int main() { int an[NUM] = { 8,123,11,10,4 }; mysort(an,an+NUM,Greater1); //从小到大排序 for( int i = 0;i \u0026lt; NUM; i ++ ) cout \u0026lt;\u0026lt; an[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; mysort(an,an+NUM,Greater2); //从大到小排序 cout \u0026lt;\u0026lt; endl; for( int i = 0;i \u0026lt; NUM; i ++ ) cout \u0026lt;\u0026lt; an[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; endl; double d[6] = { 1.4,1.8,3.2,1.2,3.1,2.1}; mysort(d+1,d+5,Greater3); //将数组从下标1到下标4从小到大排序 for( int i = 0;i \u0026lt; 6; i ++ ) cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; return 0; } ","date":"2025-04-16T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%B8%8E%E6%A8%A1%E6%9D%BF%E4%BD%9C%E4%B8%9A/","title":"【程序设计实习】输入输出与模板作业"},{"content":"02:统计动物数量 描述 代码填空，使得程序能够自动统计当前各种动物的数量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; // 在此处补充你的代码 void print() { cout \u0026lt;\u0026lt; Animal::number \u0026lt;\u0026lt; \u0026#34; animals in the zoo, \u0026#34; \u0026lt;\u0026lt; Dog::number \u0026lt;\u0026lt; \u0026#34; of them are dogs, \u0026#34; \u0026lt;\u0026lt; Cat::number \u0026lt;\u0026lt; \u0026#34; of them are cats\u0026#34; \u0026lt;\u0026lt; endl; } int main() { print(); Dog d1, d2; Cat c1; print(); Dog* d3 = new Dog(); Animal* c2 = new Cat; Cat* c3 = new Cat; print(); delete c3; delete c2; delete d3; print(); } 输入 1 无 输出 1 2 3 4 5 6 7 8 9 10 11 0 animals in the zoo, 0 of them are dogs, 0 of them are cats 3 animals in the zoo, 2 of them are dogs, 1 of them are cats 6 animals in the zoo, 3 of them are dogs, 3 of them are cats 3 animals in the zoo, 2 of them are dogs, 1 of them are cats 样例输入 None 样例输出 0 animals in the zoo, 0 of them are dogs, 0 of them are cats 3 animals in the zoo, 2 of them are dogs, 1 of them are cats 6 animals in the zoo, 3 of them are dogs, 3 of them are cats 3 animals in the zoo, 2 of them are dogs, 1 of them are cats Solution 有一点要注意，因为太久没写忘了\n就是基类的析构函数要写成虚函数形式，这样，在delete派生类对象的时候才会先执行派生类析构函数，再执行基类的析构函数，消得干净\n这里我们都会写 但是通过C++的报错可以得知一个点\nprint函数中引用的Animal::number这个东西，它是引用的Animal类（划重点）的number成员变量\n这个时候就必须写成静态形式，因为如果不写成的话，编译器不知道你调用的是哪个Animal类对象的成员变量\n这个也是因为太久没写忘了\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;iostream\u0026gt; using namespace std; class Animal{ public: static int number; Animal(){ number+=1; } virtual ~Animal(){ number--; } }; class Dog:public Animal{ public: static int number; Dog(){ number+=1; } ~Dog(){ number--; } }; class Cat:public Animal{ public: static int number; Cat(){ number+=1; } ~Cat(){ number--; } }; int Animal::number=0; int Dog::number=0; int Cat::number=0; // 在此处补充你的代码 void print() { cout \u0026lt;\u0026lt; Animal::number \u0026lt;\u0026lt; \u0026#34; animals in the zoo, \u0026#34; \u0026lt;\u0026lt; Dog::number \u0026lt;\u0026lt; \u0026#34; of them are dogs, \u0026#34; \u0026lt;\u0026lt; Cat::number \u0026lt;\u0026lt; \u0026#34; of them are cats\u0026#34; \u0026lt;\u0026lt; endl; } int main() { print(); Dog d1, d2; Cat c1; print(); Dog* d3 = new Dog(); Animal* c2 = new Cat; Cat* c3 = new Cat; print(); delete c3; delete c2; delete d3; system(\u0026#34;pause\u0026#34;); print(); } 04:多态 描述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: virtual Base\u0026amp; fun() { cout \u0026lt;\u0026lt; \u0026#34;base fun\u0026#34; \u0026lt;\u0026lt; endl; return *this; } virtual Base\u0026amp; foo() { cout \u0026lt;\u0026lt; \u0026#34;base foo\u0026#34; \u0026lt;\u0026lt; endl; return *this; } }; class Derived: public Base { public: Base\u0026amp; fun() { cout \u0026lt;\u0026lt; \u0026#34;derived fun\u0026#34; \u0026lt;\u0026lt; endl; return *this; } Base\u0026amp; foo() { cout \u0026lt;\u0026lt; \u0026#34;derived foo\u0026#34; \u0026lt;\u0026lt; endl; return *this; } }; Base\u0026amp; foo(); Base\u0026amp; fun(); // 在此处补充你的代码 int main() { foo().fun().foo(); fun().foo().fun(); return 0; } 输入 1 - 输出 1 2 3 4 5 6 derived foo derived fun derived foo base fun base foo base fun 样例输入 1 - 样例输出 1 2 3 4 5 6 derived foo derived fun derived foo base fun base foo base fun Solution 这道题花的时间最长\n估计是因为函数的写了不调用形式没怎么见到（以及python写太久了，C++有所淡忘）\n就是那个Base\u0026amp; foo();\n这个表示这是个函数 但是啥都没声明\n所以，题目就是需要我们声明一下两个函数是什么\n然后呢？我们看一下这个函数的返回值类型\n当时就是因为没注意到这个，所以好长时间没做出来\n我们以第二个函数fun为例\n它声明一个Base类对象b 首先，为什么要静态？\n因为这个静态对象只能创建一次，并且在函数结束后不会被销毁\n然后return b.fun();\n这句的意思是执行一次b的fun（Base类）函数，再返回一个b对象的拷贝\n而Derived类和Base类中的foo/fun成员函数同理\n所以才会输出三次一样的\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: virtual Base\u0026amp; fun() { cout \u0026lt;\u0026lt; \u0026#34;base fun\u0026#34; \u0026lt;\u0026lt; endl; return *this; } virtual Base\u0026amp; foo() { cout \u0026lt;\u0026lt; \u0026#34;base foo\u0026#34; \u0026lt;\u0026lt; endl; return *this; } }; class Derived: public Base { public: Base\u0026amp; fun() { cout \u0026lt;\u0026lt; \u0026#34;derived fun\u0026#34; \u0026lt;\u0026lt; endl; return *this; } Base\u0026amp; foo() { cout \u0026lt;\u0026lt; \u0026#34;derived foo\u0026#34; \u0026lt;\u0026lt; endl; return *this; } }; Base\u0026amp; foo(); Base\u0026amp; fun(); Base\u0026amp; foo(){ static Derived d; return d.foo(); } Base\u0026amp; fun(){ static Base b; return b.fun(); } // 在此处补充你的代码 int main() { foo().fun().foo(); fun().foo().fun(); system(\u0026#34;pause\u0026#34;); return 0; } 06:变来变去的数 描述 程序填空输出指定结果。（行末输出多余的空格不会影响结果的正确性）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class myobject { public: // 在此处补充你的代码 }; class producer : public myobject { public: virtual void work() { counter = counter + 5; print_avaliable(); } }; int myobject::counter = 0; int main(){ producer *pro = new producer(); myobject *con = new myobject(); pro-\u0026gt;work(); pro-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; con-\u0026gt;work(); con-\u0026gt;work(); con-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; pro-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; con-\u0026gt;work(); con-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; } 输入 1 无 输出 1 2 3 4 5 10 6 2 2 7 3 3 样例输入 1 无 样例输出 1 2 3 4 5 10 6 2 2 7 3 3 Solution 这里其实没有啥要看清的\n就是抖机灵 在A的函数里写上counter大于等于4就减一这种解法\n笔者注:此题后得知可不用特判解出，本解法仅供参考 下面看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; using namespace std; class myobject { public: static int counter; void work(){ if(counter\u0026gt;=4) counter-=4; cout\u0026lt;\u0026lt;counter\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } void print_avaliable(){ cout\u0026lt;\u0026lt;counter\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } // 在此处补充你的代码 }; class producer : public myobject { public: virtual void work() { counter = counter + 5; print_avaliable(); } }; int myobject::counter = 0; int main(){ producer *pro = new producer(); myobject *con = new myobject(); pro-\u0026gt;work(); pro-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; con-\u0026gt;work(); con-\u0026gt;work(); con-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; pro-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; con-\u0026gt;work(); con-\u0026gt;work(); cout \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } 07:MyClass 描述 补充下列代码，使得程序的输出为： A:3 A:15 B:5 3 15 5\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class CMyClassA { int val; public: CMyClassA(int); void virtual print(); }; CMyClassA::CMyClassA(int arg) { val = arg; printf(\u0026#34;A:%d\\n\u0026#34;, val); } void CMyClassA::print() { printf(\u0026#34;%d\\n\u0026#34;, val); return; } // 在此处补充你的代码 int main(int argc, char** argv) { CMyClassA a(3), *ptr; CMyClassB b(5); ptr = \u0026amp;a; ptr-\u0026gt;print(); a = b; a.print(); ptr = \u0026amp;b; ptr-\u0026gt;print(); return 0; } 输入 1 无 输出 1 见样例 样例输入 1 None 样例输出 1 2 3 4 5 6 A:3 A:15 B:5 3 15 5 Solution 别的不说，就说一个\n这里的派生类的构造函数如何调用基类构造函数？\n做的时候忘记了\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; class CMyClassA { int val; public: CMyClassA(int); void virtual print(); }; CMyClassA::CMyClassA(int arg) { val = arg; printf(\u0026#34;A:%d\\n\u0026#34;, val); } void CMyClassA::print() { printf(\u0026#34;%d\\n\u0026#34;, val); return; } class CMyClassB:public CMyClassA{ public: int val; CMyClassB(int x):CMyClassA(3*x){ val=x; printf(\u0026#34;B:%d\\n\u0026#34;,val); } void print(){ printf(\u0026#34;%d\\n\u0026#34;,val); } }; // 在此处补充你的代码 int main(int argc, char** argv) { CMyClassA a(3), *ptr; CMyClassB b(5); ptr = \u0026amp;a; ptr-\u0026gt;print(); a = b; a.print(); ptr = \u0026amp;b; ptr-\u0026gt;print(); system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2025-04-13T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第五次上机复盘"},{"content":"05:正整数的任意进制转换 将 p 进制 n 转换为 q 进制。p 和 q 的取值范围为[2，36]，其中，用到的数码按从小到大依次为：0，1，2，3，4，5，6，7，8，9，A，B，\u0026hellip;，Z，不考虑小写字母。\n输入 一共1+m 行：\n第1行为 m，表示后面有 m 行（1 \u0026lt;= m \u0026lt;= 60）.\n其后的m行中，每行3个数: 进制p，p进制数n，以及进制 q。\n三个数之间用逗号间隔。\nn 的长度不超过50位。\n输出 转换后的 q 进制数。\n样例输入 1 2 3 4 5 6 7 6 18,2345678A123,18 15,23456,18 12,2345678,20 16,12345678,23 25,3456AB,21 18,AB1234567,22 样例输出 1 2 3 4 5 6 2345678A123 114E0 22B7A4 21A976L 7C2136 22JF0G367 Solution 就是简单的值 而且python还用不到高精度\n事情在于“0”要特判 直接输出0\n然后上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 n=int(input()) di=[0,1,2,3,4,5,6,7,8,9,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;G\u0026#39;,\u0026#39;H\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;J\u0026#39;,\u0026#39;K\u0026#39;,\u0026#39;L\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;N\u0026#39;,\u0026#39;O\u0026#39;,\u0026#39;P\u0026#39;,\u0026#39;Q\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;S\u0026#39;,\u0026#39;T\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;X\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Z\u0026#39;] dict={\u0026#39;0\u0026#39;:0,\u0026#39;1\u0026#39;:1,\u0026#39;2\u0026#39;:2,\u0026#39;3\u0026#39;:3,\u0026#39;4\u0026#39;:4,\u0026#39;5\u0026#39;:5,\u0026#39;6\u0026#39;:6,\u0026#39;7\u0026#39;:7,\u0026#39;8\u0026#39;:8,\u0026#39;9\u0026#39;:9,\u0026#39;A\u0026#39;:10,\u0026#39;B\u0026#39;:11,\u0026#39;C\u0026#39;:12,\u0026#39;D\u0026#39;:13,\u0026#39;E\u0026#39;:14,\u0026#39;F\u0026#39;:15,\u0026#39;G\u0026#39;:16,\u0026#39;H\u0026#39;:17,\u0026#39;I\u0026#39;:18,\u0026#39;J\u0026#39;:19,\u0026#39;K\u0026#39;:20,\u0026#39;L\u0026#39;:21,\u0026#39;M\u0026#39;:22,\u0026#39;N\u0026#39;:23,\u0026#39;O\u0026#39;:24,\u0026#39;P\u0026#39;:25,\u0026#39;Q\u0026#39;:26,\u0026#39;R\u0026#39;:27,\u0026#39;S\u0026#39;:28,\u0026#39;T\u0026#39;:29,\u0026#39;U\u0026#39;:30,\u0026#39;V\u0026#39;:31,\u0026#39;W\u0026#39;:32,\u0026#39;X\u0026#39;:33,\u0026#39;Y\u0026#39;:34,\u0026#39;Z\u0026#39;:35} for i in range(0,n): lst=input().split(\u0026#39;,\u0026#39;) p=int(lst[0]) x=lst[1] q=int(lst[2]) num=0 k=1 l=[] t=x[::-1] for j in range(0,len(t)): num+=k*dict[t[j]] k*=p if(num==0): print(\u0026#39;0\u0026#39;) continue while(num\u0026gt;0): temp=num%q l.append(di[temp]) num//=q res=l[::-1] for j in res: print(j,end=\u0026#39;\u0026#39;) print() 06:古代密码 描述 古罗马帝国有一个拥有各种部门的强大政府组织。其中一个部门就是保密服务部门。为了保险起见，在省与省之间传递的重要文件中的大写字母是加密的。当时最流行的加密方法是替换和重新排列。\n替换方法是将所有出现的字符替换成其它的字符。有些字符会替换成它自己。例如：替换规则可以是将\u0026rsquo;A\u0026rsquo; 到 \u0026lsquo;Y\u0026rsquo;替换成它的下一个字符，将\u0026rsquo;Z\u0026rsquo;替换成 \u0026lsquo;A\u0026rsquo;，如果原词是 \u0026ldquo;VICTORIOUS\u0026rdquo; 则它变成 \u0026ldquo;WJDUPSJPVT\u0026rdquo;。\n排列方法改变原来单词中字母的顺序。例如：将顺序例如将顺序 \u0026lt; 2 1 5 4 3 7 6 10 9 8 \u0026gt; 应用到 \u0026ldquo;VICTORIOUS\u0026rdquo; 上，则得到\u0026quot;IVOTCIRSUO\u0026quot;。\n人们很快意识到单独应用替换方法或排列方法加密，都是很不保险的。但是如果结合这两种方法，在当时就可以得到非常可靠的加密方法。所以，很多重要信息先使用替换方法加密，再将加密的结果用排列的方法加密。用两种方法结合就可以将\u0026quot;VICTORIOUS\u0026quot; 加密成\u0026quot;JWPUDJSTVP\u0026quot;。\n考古学家最近在一个石台上发现了一些信息。初看起来它们毫无意义，所以有人设想它们可能是用替换和排列的方法被加密了。人们试着解读了石台上的密码，现在他们想检查解读的是否正确。他们需要一个计算机程序来验证，你的任务就是写这个验证程序。\n输入 输入有两行。第一行是石台上的文字。文字中没有空格，并且只有大写英文字母。第二行是被解读出来的加密前的文字。第二行也是由大写英文字母构成的。\n两行字符数目的长度都不超过100。\n输出 如果第二行经过某种加密方法后可以产生第一行的信息，输出 \u0026ldquo;YES\u0026rdquo;，否则输出\u0026quot;NO\u0026quot;。\n样例输入 1 2 JWPUDJSTVP VICTORIOUS 样例输出 1 YES Solution 既然交换的顺序和原先的字母代替顺序我们都不清楚，那么怎么办？\n能肯定的一点：同一个字母不管怎么弄都还是一样的字母\n那我们只需要对不同的字母计数 然后把字典的键擦除，再比对\n下面看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 x=input() y=input() dict_1={} dict_2={} for i in range(0,len(x)): if x[i] not in dict_1: dict_1[x[i]]=1 else: dict_1[x[i]]+=1 for i in range(0,len(y)): if y[i] not in dict_2: dict_2[y[i]]=1 else: dict_2[y[i]]+=1 list_1=[] list_2=[] for i in dict_1.values(): list_1.append(i) for i in dict_2.values(): list_2.append(i) list_1.sort() list_2.sort() flag=1 for i in range(0,max(len(list_1),len(list_2))): if list_1[i]==list_2[i]: continue else: flag=0 break if flag==0: print(\u0026#34;NO\u0026#34;) else: print(\u0026#34;YES\u0026#34;) 07:啤酒厂选址 描述 海上有一个岛，在环海边上建有一条环岛高速公路，沿着公路有n（5 \u0026lt; n \u0026lt; 10000）个居民点，假设每个居民点有一个编号，从0开始，按顺时针依次从小到大（即，0,1，…，n-1）编号。在岛上啤酒很受青睐。某啤酒企业计划在岛上投资建一个啤酒厂，并根据啤酒需求每天向居住点送啤酒。已知两个相邻的居民点的距离以及每个居住点每天的啤酒需求量（假设每个居住点每天不超过2000桶）。假定每单位长度的路程送一桶啤酒需要的费用恒定（为单位费用）。请问，选择哪一个居民点建啤酒厂，才能使每天送啤酒的费用最小（空车不计费用）。\n输入 第一行：为居民点数目n\n后面为n行，每行为一个居民点的啤酒需求量以及按顺时针离下一个居民点的距离（均为整数,空格间隔），从编号为0的开始，按单增顺次给出。\n注意：后面第n行对应于居民点（n-1)的啤酒需求量以及到编号为0的居民点距离。\n输出 啤酒厂所在的居民点编号以及每天的运输费用，其间以逗号间隔\n样例输入 1 2 3 4 5 6 7 6 500 10 300 30 350 25 400 60 700 28 200 35 样例输出 1 0,94100 Solution 简单前缀和加上模拟不解释 计概出过一模一样的题目，怕你忘了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 n=int(input()) d=[0] l=0 beer=[] ans=1e8 mi=0 for i in range(1,n+1): lst=input().split() x=int(lst[0]) y=int(lst[1]) if(i!=n): d.append(d[i-1]+y) beer.append(x) l+=y for i in range(0,n): temp=0 for j in range(0,n): if i==j: continue else: temp+=beer[j]*min(abs(d[j]-d[i]),l-abs(d[j]-d[i])) if temp\u0026lt;ans: mi=i ans=temp print(mi,end=\u0026#39;,\u0026#39;) print(ans) 09:Minecraft 描述 Minecraft是一个几乎无所不能的沙盒游戏，玩家可以利用游戏内的各种资源进行创造，搭建自己的世界。\n在Minecraft中，基本的建筑元素是边长为1个单位的立方体，Tony想用N个这种小立方体搭建一个长方体，并用他珍藏已久的贴纸对其进行装饰。如果一张贴纸可以贴满小立方体的一个面。那么，他需要用掉多少张贴纸呢？\n输入 一个整数N，表示小明所拥有的小立方体的个数。N不会超过1000。\n输出 一个整数，即小明最少用掉的贴纸有多少张。\n样例输入 1 9 样例输出 1 30 Solution: 我们要优化时间复杂度 假设最小性\n1 2 3 4 5 6 7 8 9 10 n=int(input()) ans=1e8 for i in range(1,n+1): if i*i*i\u0026gt;n: break for j in range(i,n+1): for k in range(j,n+1): if n==i*j*k: ans=min(ans,2*(i*j+j*k+k*i)) print(ans) 10:猴子吃桃 描述 海滩上有一堆桃子，N只猴子来分。第一只猴子把这堆桃子平均分为N份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子接着把剩下的桃子平均分成N份，又多了一个，它同样把多的一个扔入海中，拿走了一份。第三、第四、……，第N只猴子仍是最终剩下的桃子分成N份，扔掉多了的一个，并拿走一份。\n编写程序，输入猴子的数量N，输出海滩上最少的桃子数，使得每只猴子都可吃到桃子。\n输入 一个整数N。\n输出 输出当猴子数量为N时海滩上最少的桃子数。结果保证在int型范围内。\n样例输入 1 2 样例输出 1 7 Solution 是小学奥数，但是不要被吓到\n计算机是很强的！\n还是个枚举题 但是枚举最终结果太超模了\n所以枚举最后剩下的\n完事\n笔者注：这题可以用瞪眼法找规律 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 n=int(input()) for i in range(1,2147483647): ans=i*n+1 flag=0 for j in range(0,n-1): if ans%(n-1)==0: ans=ans*n//(n-1)+1 if j==n-2: flag=1 break else: continue else: break if flag==1: print(ans) break ","date":"2025-03-30T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第四次上机复盘"},{"content":"A:Python:怎么能够这么求和 描述 程序填空 程序先输出10(10=1+2+3+4),30， 然后读入若干整数，并输出它们的和\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def mysum(x): // 在此处补充你的代码 def exec(g,i) : #call g for i times if i == 1 : g() else: g() exec(g,i-1) k = mysum(1)(2)(3)(4) k2 = mysum(10)(20) print(k()) print(k2()) while True: try: s = input() s = s.split() k = mysum for x in s: k = k(int(x)) exec(k,int(s[0])) print(k()) except: #读到 eof产生异常 break 输入 多组数据，每组一行，包括不超过100个整数（至少一个），其中第一个整数一定大于0。\n输出 对每组数据，输出所有整数的和\n样例输入 1 2 1 2 3 4 5 样例输出 1 2 3 4 10 30 6 9 Solution 有点类似C++STL里的accumulate?\n我们要返回一个函数，同时这个函数能存储一个值，用闭包也能实现（当时写的时候不知道为啥忘记用闭包了）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def mysum(x): def inner(y=None): if y is None: return x return mysum(x + y) return inner def exec(g,i) : #call g for i times if i == 1 : g() else: g() exec(g,i-1) k = mysum(1)(2)(3)(4) k2 = mysum(10)(20) print(k()) print(k2()) while True: try: s = input() s = s.split() k = mysum for x in s: k = k(int(x)) exec(k,int(s[0])) print(k()) except: #读到 eof产生异常 break B:函数累加器 描述 编写一个函数累加器accfunc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #pylint: disable = no-value-for-parameter def accfunc(f): // 在此处补充你的代码 def f1(x): return x + 1 def f2(x): return x * x def f3(x): return x + x def f4(x): return x*3 def f5(x): return x-4 while True: try: s = input() n = int(input()) s = s.split() k = accfunc for x in s: k = k(eval(x)) print(k()(n)) except: #读到 eof产生异常 break 输入 多组数据，每组2行\n第一行形如：\np_1 p_2 p_3 \u0026hellip;.p_n\np_i 是个字符串，值是 \u0026ldquo;f1\u0026rdquo;, \u0026ldquo;f2\u0026rdquo;, \u0026ldquo;f3\u0026rdquo;, \u0026ldquo;f4\u0026rdquo;, \u0026ldquo;f5\u0026rdquo; 中间的任何一个，代表程序中相应函数\n这一行项数不定，至少有1项\n第二行是个整数x\n对每组数据，输出以下函数调用的结果:\np_n(p_n-1(\u0026hellip;(p2(p1(x)\u0026hellip;)\n输出 对每组数据，输出以下函数调用的结果:\np_n(p_n-1(\u0026hellip;(p2(p1(x)\u0026hellip;)\n样例输入 1 2 3 4 5 6 f1 f2 f3 4 f2 5 f2 f2 f5 3 样例输出 1 2 3 50 25 77 提示 第一个例子，输出结果是 f3(f2(f1(4))) 第二个例子，输出结果是 f2(5)\nSolution 跟上题有点像，也可以用闭包\n直接把我当时写的代码搬上来了()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #pylint: disable = no-value-for-parameter def accfunc(f): def inner(g=None): if g is None: return f else: return accfunc(lambda x: g(f(x))) return inner def f1(x): return x + 1 def f2(x): return x * x def f3(x): return x + x def f4(x): return x*3 def f5(x): return x-4 while True: try: s = input() n = int(input()) s = s.split() k = accfunc for x in s: k = k(eval(x)) print(k()(n)) except: #读到 eof产生异常 break C:生成器 描述 下面程序输入正整数n和m，输出从0开始的前m个n的倍数，请写出times函数的内部实现。不得使用列表、元组、集合、字典，times必须是个生成器函数。\n1 2 3 4 5 6 7 8 9 10 11 12 exit = None def times(n): // 在此处补充你的代码 n,m = map(int,input().split()) seq = times(n) if str(type(seq) == \u0026#34;\u0026lt;class \u0026#39;generator\u0026#39;\u0026gt;\u0026#34;): i = 0 for x in seq: print(x) i += 1 if i == m: break 输入 两个整数 n和m\n输出 n的前m个倍数（从0开始)\n样例输入 1 2 5 样例输出 1 2 3 4 5 0 2 4 6 8 Solution 题目的要求写得很清楚了，就是生成器\n生成器的原理课件里也挺清楚的\n在yield的时候停止并抛出下一个值就可以~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 exit = None def times(n): num = 0 while True: yield num num += n n,m = map(int,input().split()) seq = times(n) if str(type(seq) == \u0026#34;\u0026lt;class \u0026#39;generator\u0026#39;\u0026gt;\u0026#34;): i = 0 for x in seq: print(x) i += 1 if i == m: break ","date":"2025-03-26T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0python%E9%80%9F%E9%80%9A%E4%BD%9C%E4%B8%9A%E5%9B%9B/","title":"【程序设计实习】python速通作业四"},{"content":"这节课老师讲了Python的面向对象部分，速度比较快\n但是结合前面cpp的大部分知识可以弄懂\n01:运算符的实现 描述 程序填空\n1 2 3 4 5 6 7 8 9 10 11 class A: def __init__(self,x): self.x = x // 在此处补充你的代码 a,b,c = map(int,input().split()) print(isinstance(A(2),A)) print(A(a) \u0026lt; A(b)) print(A(a) \u0026gt;= A(c)) print(A(a) \u0026lt; c) 输入 输入三个整数a,b,c\n输出 先输出一行True\n然后依次输出 a \u0026lt; b， a \u0026gt;= c , a \u0026lt; c 三个表达式的值(True或False)\n样例输入 1 2 8 5 样例输出 1 2 3 4 True True False True Solution py和cpp的特性差别在于\npy并没有报错 直接告诉你要重载啥运算符\n我们看题目 需要重载一个小于号和一个大于等于号\n小于号要判断类型（相比cpp的重载函数里直接给定类型 这里只要重载一次再判断）\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A: def __init__(self,x): self.x = x def __lt__(self,other): if isinstance(other,A): return self.x\u0026lt;other.x else: return self.x\u0026lt;other def __ge__(self,other): return self.x\u0026gt;=other.x # 在此处补充你的代码 a,b,c = map(int,input().split()) print(isinstance(A(2),A)) print(A(a) \u0026lt; A(b)) print(A(a) \u0026gt;= A(c)) print(A(a) \u0026lt; c) 02:组合函数 描述 Python支持高阶函数，即函数可以作为函数的参数和返回值\n下面程序的combine函数 combine(f,g)能得到一个新函数k, k(x) = f(g(x))，请填空\n1 2 3 4 5 6 7 8 9 10 11 12 13 def combine(f,g): // 在此处补充你的代码 def square(x): return x * x def double(x): return x + x n = int(input()) f = combine(square,double) #提示： f(x) = square(double(x)) print(f(n)) g = combine(f,double) #提示: g(x) = f(double(x)) print(g(n)) 输入 整数n\n输出 第一行是 (2n)(2n)的值\n第二行是 (2(2n)) * (2(2*n)) 的值\n样例输入 1 3 样例输出 1 2 36 144 Solution 简单题 因为py的返回值类型可以是函数 高度自由\n新定义一个函数 然后这个函数的类型是f,g得出的就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def combine(f,g): def k(x): return f(g(x)) return k # 在此处补充你的代码 def square(x): return x * x def double(x): return x + x n = int(input()) f = combine(square,double) #提示： f(x) = square(double(x)) print(f(n)) g = combine(f,double) #提示: g(x) = f(double(x)) print(g(n)) 03:实现带标签的列表 描述 TaggedList 表示元素带标签的列表。每个元素都有不同标签，标签是字符串。元素可以用整数做下标访问，也可以用标签做下标访问。请给出该类的实现\n1 2 3 4 5 6 7 8 9 exit = None class TaggedList: #元素带标签的列表 // 在此处补充你的代码 a = TaggedList([70,80,90,100],[\u0026#34;语文\u0026#34;,\u0026#34;数学\u0026#34;,\u0026#34;英语\u0026#34;,\u0026#34;物理\u0026#34;]) print(len(a),78 in a, 80 in a) #\u0026gt;\u0026gt;4 False True print(str(a)) #\u0026gt;\u0026gt;语文:70,数学:80,英语:90,物理:100, print(a[0],a[\u0026#39;数学\u0026#39;]) #\u0026gt;\u0026gt;70 80 标签也可以作为下标访问元素 a[1] = a[\u0026#39;物理\u0026#39;] = 85 print(a) #\u0026gt;\u0026gt;语文:70,数学:85,英语:90,物理:85, 输入 无\n输出 如样例\n样例输入 无\n样例输出 1 2 3 4 4 False True 语文:70,数学:80,英语:90,物理:100, 70 80 语文:70,数学:85,英语:90,物理:85, Solution 这题有点烧脑\n需要你实现一个类 我们先明确题目的要求是什么\n填入的是两个列表，我们需要建构一个映射关系\n因为题目相当于两个字典合并成一个 前面的数是值 而后面数字的编号和字符串都是键\n好了 怎么建立映射关系？\n当然是用后面的一个拼接函数来了 然后相当于是一个迭代的字典\n然后，我们通过查资料明确 contains getitem 和 setitem都是python用魔术方法定义的函数\n最后用str拼接\n下面看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 exit = None class TaggedList: #元素带标签的列表 def __init__(self,value,tags): self.values=value self.tag_index={tag:idx for idx,tag in enumerate(tags)} def __len__(self): return len(self.values) def __contains__(self,item): return item in self.values def __getitem__(self,key): if isinstance(key,int): return self.values[key] return self.values[self.tag_index[key]] def __setitem__(self,key,value): if isinstance(key,int): self.values[key]=value else: self.values[self.tag_index[key]]=value def __str__(self): return \u0026#39;,\u0026#39;.join(f\u0026#34;{tag}:{val}\u0026#34; for tag,val in zip(self.tag_index.keys(),self.values))+\u0026#39;,\u0026#39; # 在此处补充你的代码 a = TaggedList([70,80,90,100],[\u0026#34;语文\u0026#34;,\u0026#34;数学\u0026#34;,\u0026#34;英语\u0026#34;,\u0026#34;物理\u0026#34;]) print(len(a),78 in a, 80 in a) #\u0026gt;\u0026gt;4 False True print(str(a)) #\u0026gt;\u0026gt;语文:70,数学:80,英语:90,物理:100, print(a[0],a[\u0026#39;数学\u0026#39;]) #\u0026gt;\u0026gt;70 80 标签也可以作为下标访问元素 a[1] = a[\u0026#39;物理\u0026#39;] = 85 print(a) #\u0026gt;\u0026gt;语文:70,数学:85,英语:90,物理:85, 04:闭包 描述 程序填空，完成函数cons\n按要求输出结果\n1 2 3 4 5 6 7 def cons(x,y): s = a = b = None #防止作弊用 // 在此处补充你的代码 s = input().split() a,b = s[0],s[1] pair = cons(a,b) print(pair(int(input()))) 输入 第一行是两个字符串,用空格隔开\n第二行是一个整数n\n输出 如果n 为0，则输出第一个字符串\n如果n 为1，则输出第二个字符串\n如果n 为其它数，则输出error\n样例输入 1 2 3 4 5 6 7 8 9 #样例1： 13 5 0 #样例2： 4 aa 1 #样例3： bd c 7 样例输出 1 2 3 4 5 6 #样例1： 13 #样例2： aa #样例3： error Solution 这道题感觉比上道题简单\n因为我们观察到最后的pair还是接收了一个n的\n所以推测经过前面pair的处理返回的是一个关于n的函数\n然后重写一个函数返回就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def cons(x,y): s = a = b = None def f(n): if n==0: return x elif n==1: return y else: return \u0026#34;error\u0026#34; return f # 在此处补充你的代码 s = input().split() a,b = s[0],s[1] pair = cons(a,b) print(pair(int(input()))) ","date":"2025-03-24T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0python%E9%80%9F%E9%80%9A%E4%BD%9C%E4%B8%9A%E4%B8%89/","title":"【程序设计实习】python速通作业三"},{"content":"05:加密的病历单 小英是药学专业大三的学生，暑假期间获得了去医院药房实习的机会。\n在药房实习期间，小英扎实的专业基础获得了医生的一致好评，得知小英在计算概论中取得过好成绩后，主任又额外交给她一项任务，解密抗战时期被加密过的一些伤员的名单。\n经过研究，小英发现了如下加密规律（括号中是一个“原文 -\u0026gt; 密文”的例子）\n1.原文中所有的字符都在字母表中被循环左移了三个位置（dec -\u0026gt; abz）\n2.逆序存储（abcd -\u0026gt; dcba ）\n3.大小写反转（abXY -\u0026gt; ABxy）\n输入 一个加密的字符串。（长度小于50且只包含大小写字母）\n输出 输出解密后的字符串。\n样例输入 1 GSOOWFASOq 样例输出 1 Trvdizrrvj Solution 其实就两个事情 一个是大小写转换是用swapcase() 另一个就是ascil码与字符间的转换\n字符-\u0026gt;ascil码 使用ord ascil码-\u0026gt;字符 使用chr\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 x=input() l=len(x) res_1=x.swapcase() res_2=res_1[::-1] res_3=[] for i in range(0,l): if res_2[i]==\u0026#39;X\u0026#39;: res_3.append(\u0026#39;A\u0026#39;) elif res_2[i]==\u0026#39;Y\u0026#39;: res_3.append(\u0026#39;B\u0026#39;) elif res_2[i]==\u0026#39;Z\u0026#39;: res_3.append(\u0026#39;C\u0026#39;) elif res_2[i]==\u0026#39;x\u0026#39;: res_3.append(\u0026#39;a\u0026#39;) elif res_2[i]==\u0026#39;y\u0026#39;: res_3.append(\u0026#39;b\u0026#39;) elif res_2[i]==\u0026#39;z\u0026#39;: res_3.append(\u0026#39;c\u0026#39;) else: t=ord(res_2[i]) t+=3 res_3.append(chr(t)) for i in range(0,l): print(res_3[i],end=\u0026#39;\u0026#39;) 06:字符串最大跨距 描述 有三个字符串S,S1,S2，其中，S长度不超过300，S1和S2的长度不超过10。想检测S1和S2是否同时在S中出现，且S1位于S2的左边，并在S中互不交叉（即，S1的右边界点在S2的左边界点的左侧）。计算满足上述条件的最大跨距（即，最大间隔距离：最右边的S2的起始点与最左边的S1的终止点之间的字符数目）。如果没有满足条件的S1，S2存在，则输出-1。\n例如，S = \u0026ldquo;abcd123ab888efghij45ef67kl\u0026rdquo;, S1=\u0026ldquo;ab\u0026rdquo;, S2=\u0026ldquo;ef\u0026rdquo;，其中，S1在S中出现了2次，S2也在S中出现了2次，最大跨距为：18。\n输入 三个串：S, S1, S2，其间以逗号间隔（注意，S, S1, S2中均不含逗号和空格）；\n输出 S1和S2在S最大跨距；若在S中没有满足条件的S1和S2，则输出-1。\n样例输入 1 abcd123ab888efghij45ef67kl,ab,ef 样例输出 1 18 Solution 做的时候忘记了rfind函数，但是如果用两次[::-1]应该也能做\n然后就不难了\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 lst=input().split(\u0026#39;,\u0026#39;) s=lst[0] a=lst[1] b=lst[2] l=s.find(a) r=s.rfind(b) if l==-1 or r==-1: print(-1) exit() if r-l\u0026gt;=len(a): print(r-l-len(a)) else: print(-1) 09:话题焦点人物 描述 微博提供了一种便捷的交流平台。一条微博中，可以提及其它用户。例如Lee发出一条微博为：“期末考试顺利 @Kim @Neo”，则Lee提及了Kim和Neo两位用户。\n我们收集了N(1 \u0026lt; N \u0026lt; 10000)条微博，并已将其中的用户名提取出来，用小于等于100的正整数表示。\n通过分析这些数据，我们希望发现大家的话题焦点人物，即被提及最多的人（题目保证这样的人有且只有一个），并找出那些提及它的人。\n输入 输入共两部分：\n第一部分是微博数量N，1 \u0026lt; N \u0026lt; 10000。\n第二部分是N条微博，每条微博占一行，表示为：\n发送者序号a，提及人数k(0 \u0026lt; = k \u0026lt; = 20)，然后是k个被提及者序号b1,b2\u0026hellip;bk；\n其中a和b1,b2\u0026hellip;bk均为大于0小于等于100的整数。相邻两个整数之间用单个空格分隔。\n输出 输出分两行：\n第一行是被提及最多的人的序号；\n第二行是提及它的人的序号，从小到大输出，相邻两个数之间用单个空格分隔。同一个序号只输出一次。\n样例输入 1 2 3 4 5 6 5 1 2 3 4 1 0 90 3 1 2 4 4 2 3 2 2 1 3 样例输出 1 2 3 1 2 4 Solution 这道题一直A不掉的原因是什么呢 就是我已经想到了不管是用list模拟set还是直接用set 都要去重,但是重的还要计入次数\n笔者注：此题用dict嵌套的dict做更为方便 下面看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 n=int(input()) ans=[0] res=[0] for i in range(1,101): ans.append(0) res.append([]) for i in range(0,n): k=input().split() t=int(k[0]) z=int(k[1]) for j in range(2,z+2): x=int(k[j]) ans[x]+=1 if t in res[x]: pass else: res[x].append(t) mi=max(ans) mixx=ans.index(mi) print(mixx) res[mixx].sort() for i in res[mixx]: print(i,end=\u0026#39; \u0026#39;) 10:判断元素是否存在 描述 有一个集合M是这样生成的： (1) 已知 k 是集合 M 的元素； (2) 如果 y 是 M 的元素，那么， 2y+1 和 3y+1 都是 M 的元素； (3) 除了上述二种情况外，没有别的数能够成为 M 的一个元素。\n问题：任意给定 k 和 x，请判断 x 是否是 M 的元素。这里的 k是无符号整数，x 不大于 100000， 如果是，则输出YES，否则，输出 NO\n输入 输入整数 k 和 x, 逗号间隔。\n输出 如果是，则输出 YES，否则，输出NO\n样例输入 1 0,22 样例输出 1 YES Solution 有点像C++ 简单递归即可\n但是由于python中碰到递归还比较少，我就放上来了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def check(x): global n if x\u0026gt;n: return False if x==n: return True return check(2*x+1) or check(3*x+1) lst=input().split(\u0026#39;,\u0026#39;) k=int(lst[0]) n=int(lst[1]) if k\u0026gt;n: print(\u0026#34;NO\u0026#34;) exit() t=check(k) if t==True: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) ","date":"2025-03-23T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第三次上机复盘"},{"content":"A:矩阵转置 描述 输入一个n行m列的矩阵A，输出它的转置AT。\n输入 第一行包含两个整数n和m，表示矩阵A的行数和列数。1 \u0026lt;= n \u0026lt;= 100，1 \u0026lt;= m \u0026lt;= 100。\n接下来n行，每行m个整数，表示矩阵A的元素。相邻两个整数之间用单个空格隔开，每个元素均在1~1000之间。\n输出 m行，每行n个整数，为矩阵A的转置。相邻两个整数之间用单个空格隔开。\n样例输入 1 2 3 4 3 3 1 2 3 4 5 6 7 8 9 样例输出 1 2 3 1 4 7 2 5 8 3 6 9 Solution 没啥 就直接模拟\n注意 列表是可以嵌套的就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 lst=input().split() n=int(lst[0]) m=int(lst[1]) kd=[] for i in range(0,n): kd.append([]) for i in range(0,n): x=input().split() for j in range(0,m): tem=int(x[j]) kd[i].append(tem) for i in range(0,m): for j in range(0,n): print(kd[j][i],end=\u0026#39; \u0026#39;) print() B:扑克牌排序 描述 一副扑克牌有52张牌，分别是红桃，黑桃，方片，梅花各13张，不包含大小王，现在Alex抽到了n张牌，请将扑克牌按照牌面从大到小的顺序排序。\n牌的表示方法：\n红桃(heart)用字母h表示\n黑桃(spade)用字母s表示\n方片(dianmond)用字母d表示\n梅花(club)用字母c表示\n2~10的牌面直接用2,3,4,5,6,7,8,9,10 表示，其余的分别为A，J，Q，K\n比如方片J用dJ表示， 红桃A用hA表示\n牌面大小：\n2\u0026gt;A\u0026gt;K\u0026gt;Q\u0026gt;J\u0026gt;10\u0026gt;9\u0026gt;……\u0026gt;4\u0026gt;3\n相同牌面的按照花色（h\u0026gt;s\u0026gt;d\u0026gt;c）顺序排。\n输入 多组数据。每组数据一行，表示当前摸到的n张牌（1 \u0026lt; n \u0026lt;=52）。\n输出 针对每组数据，输出一行，即排序后的结果。\n样例输入 1 2 h7 c10 h4 s7 c5 cA dA c4 sJ h9 hQ d8 h2 s2 d9 sA dQ c6 hA h7 s8 s7 c5 c8 cK sQ d2 s3 hQ d8 s10 sA d5 h10 hA 样例输出 1 2 h2 s2 hA sA dA cA hQ dQ sJ c10 h9 d9 d8 h7 s7 c6 c5 h4 c4 d2 hA sA cK hQ sQ h10 s10 s8 d8 c8 h7 s7 d5 c5 s3 Solution 这道题主要就是讲key函数可以作为sorted的排序依据，类似cmp，以及一次返回多个值，起到一个另类结构体的效果\n笔者注：到期末考前只会写lambda表达式作为key了，判断函数是啥？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def pd(x): f=first_order[x[1:]] g=second_order[x[0]] return f,g while True: try: lst=input().split() first_order={\u0026#39;2\u0026#39;:15,\u0026#39;A\u0026#39;:14,\u0026#39;K\u0026#39;:13,\u0026#39;Q\u0026#39;:12,\u0026#39;J\u0026#39;:11} second_order={\u0026#39;h\u0026#39;:3,\u0026#39;s\u0026#39;:2,\u0026#39;d\u0026#39;:1,\u0026#39;c\u0026#39;:0} for i in range(10,2,-1): first_order[str(i)]=i lst_1=sorted(lst,key=pd,reverse=True) for i in lst_1: print(i,end=\u0026#39; \u0026#39;) print() except EOFError: break C:实现deepcopy 描述 填空实现下面的深拷贝函数deepcopy\n1 2 3 4 5 6 7 8 9 def deepcopy(a): // 在此处补充你的代码 a = [1,2,[3,[4],5],(6,[7,[8],9])] b = deepcopy(a) print(b) a[2][1].append(400) a[3][1][1].append(800) print(a) print(b) 输入 无\n输出 [1, 2, [3, [4], 5], (6, [7, [8], 9])] [1, 2, [3, [4, 400], 5], (6, [7, [8, 800], 9])] [1, 2, [3, [4], 5], (6, [7, [8], 9])]\n样例输入 无\n样例输出 1 2 3 [1, 2, [3, [4], 5], (6, [7, [8], 9])] [1, 2, [3, [4, 400], 5], (6, [7, [8, 800], 9])] [1, 2, [3, [4], 5], (6, [7, [8], 9)] Solution 这道题主要考察深拷贝的实现形式\n那么 深拷贝要怎么实现呢？\n首先，我们要明确的是\n在函数中 像浮点、整型、字符串这样的是不可变变量\n而列表、元组这样的是可变变量\n这样导致列表和元组会变成浅拷贝\n那么 只要递归到不可变变量进行传值就可以实现深拷贝了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def deepcopy(a): if isinstance(a,list): tem=[] for item in a: tem.append(deepcopy(item)) return tem elif isinstance(a,tuple): tem=tuple(deepcopy(item) for item in a) return tem else: return a a = [1,2,[3,[4],5],(6,[7,[8],9])] b = deepcopy(a) print(b) a[2][1].append(400) a[3][1][1].append(800) print(a) print(b) D:校园食宿预订系统 描述 某校园为方便学生订餐，推出食堂预定系统。食宿平台会在前一天提供菜单，学生在开饭时间前可订餐。\n食堂每天会推出m个菜，每个菜有固定的菜价和总份数，售卖份数不能超过总份数。\n假设共有n个学生点餐，每个学生固定点3个菜，当点的菜售罄时, 学生就买不到这个菜了。\n请根据学生预定记录，给出食堂总的预定收入\n数据满足1 \u0026lt;= n \u0026lt;= 6000，3 \u0026lt;= m \u0026lt;= 6000，单品菜价不大于1000元，每个菜的配额不超过3000\n输入 第一行两个整数n和m，代表有n个学生订餐，共有m个可选的菜\n下面m行，每行三个元素，分别是菜名、售价和可提供量，保证菜名不重合，菜价为整数\n下面n行，每行三个元素，表示这个学生点的三个菜的菜名\n输出 一个整数，表示食堂的收入\n样例输入 1 2 3 4 5 6 7 8 9 10 11 5 5 yangroupaomo 13 10 jituifan 7 5 luosifen 16 3 xinlamian 12 20 juruo_milktea 999 1 yangroupaomo luosifen juruo_milktea luosifen xinlamian jituifan yangroupaomo jituifan juruo_milktea jituifan xinlamian luosifen yangroupaomo yangroupaomo yangroupaomo 样例输出 1 1157 提示 如果用python做，要用字典，\n如果用其它语言做，也要用类似的数据结构\n否则会超时\n名字长度范围没有给出，长度不会太离谱。请自己选用合适的办法确保这不是个问题\nSolution 字典这玩意吧，我感觉，就像C++中的map\n而且添加的时候直接加就可以了\n很方便\n这题用两个字典\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 lst=input().split() n=int(lst[0]) m=int(lst[1]) canteen={} price={} for i in range(0,m): k=input().split() course=k[0] p=int(k[1]) num=int(k[2]) canteen[course]=num price[course]=p ans=0 for i in range(0,n): k=input().split() tem=k[0] temp=k[1] te=k[2] if canteen[tem]!=0: ans+=price[tem] canteen[tem]-=1 if canteen[temp]!=0: ans+=price[temp] canteen[temp]-=1 if canteen[te]!=0: ans+=price[te] canteen[te]-=1 print(ans) ","date":"2025-03-19T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0python%E9%80%9F%E9%80%9A%E4%BD%9C%E4%B8%9A%E4%BA%8C/","title":"【程序设计实习】python速通作业二"},{"content":"05:奇偶ASCII值判断 描述 任意输入一个字符，判断其ASCII是否是奇数，若是，输出YES，否则，输出NO\n例如，字符A的ASCII值是65，则输出YES，若输入字符B(ASCII值是66)，则输出NO\n输入 输入一个字符\n输出 如果其ASCII值为奇数，则输出YES，否则，输出NO\n样例输入 1 A 样例输出 1 YES Solution 因为输入的字符串可能是\u0026rsquo;\\n\u0026rsquo; 被py识别为换行符而非输入内容\n此时要特判输入字符串是否为空串 即len=0\n1 2 3 4 5 6 7 8 9 x=input() if len(x)==0: print(\u0026#34;NO\u0026#34;) else: res=ord(x) if res%2==1: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) 还有 保留小数是print(\u0026ldquo;f{变量名:.nf}\u0026rdquo;)\n","date":"2025-03-16T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第二次上机复盘"},{"content":"A 反向输出一个三位数 描述 将一个三位数反向输出。\n输入 一个三位数n。\n输出 反向输出n。\n样例输入 1 100 样例输出 1 001 Solution 模拟即可\n1 2 3 s=input() reverse_s=s[::-1] print(reverse_s) B:字符串中的整数求和 描述 输入两个长度为3的字符串，每个串前两个字符是数字,后一个字符是字母。\n求这两个串中的整数的和\n输入 一行，两个字符串\n输出 两个字符串中整数的和\n样例输入 1 12B 34D 样例输出 1 46 Solution 提取列表 再提取数字\n加号的意思是先将字符串拼接 再转化成整数类\n1 2 3 4 lst=input().split() x=int(lst[0][0]+lst[0][1]) y=int(lst[1][0]+lst[1][1]) print(x+y) C:点与正方形的关系 描述 有一个正方形，四个角的坐标（x,y)分别是（1，-1），（1，1），（-1，-1），（-1，1），x是横轴，y是纵轴。\n写一个程序，判断一个给定的点是否在这个正方形内（包括正方形边界）。\n输入 输入一行，包括两个整数x、y，以一个空格分开，表示坐标(x,y)。\n输出 输出一行，如果点在正方形内，则输出yes，否则输出no。\n样例输入 1 1 1 样例输出 1 yes Solution 根据题意实现即可\n1 2 3 4 5 6 7 lst=input().split() x=int(lst[0]) y=int(lst[1]) if -1\u0026lt;=x\u0026lt;=1 and -1\u0026lt;=y\u0026lt;=1: print(\u0026#34;yes\u0026#34;) else: print(\u0026#34;no\u0026#34;) D:简单计算器 描述 一个最简单的计算器，支持+, -, *, / 四种运算。仅需考虑输入输出为整数的情况(除法结果就是商，忽略余数）\n输入 输入只有一行，共有三个参数，其中第1、2个参数为整数，第3个参数为操作符（+,-,*,/）。\n输出 输出只有一行，一个整数，为运算结果。然而：\n如果出现除数为0的情况，则输出：Divided by zero! 如果出现无效的操作符(即不为 +, -, *, / 之一），则输出：Invalid operator! 样例输入 1 1 2 + 样例输出 1 3 Solution 根据题意实现即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 lst=input().split() x=int(lst[0]) y=int(lst[1]) z=lst[2] if z==\u0026#34;+\u0026#34;: print(x+y) elif z==\u0026#39;-\u0026#39;: print(x-y) elif z==\u0026#39;*\u0026#39;: print(x*y) elif z==\u0026#39;/\u0026#39; and y!=0: print(x//y) elif z==\u0026#39;/\u0026#39; and y==0: print(\u0026#34;Divided by zero!\u0026#34;) else: print(\u0026#34;Invalid operator!\u0026#34;) E:围栏 描述 小 A 打算新建一幢楼，这幢楼需要占用一块长方形的面积恰好为 n 平方米的土地，且为了方便测量，这块土地的长宽必须为整数米。\n小 A 需要在这幢楼外边修围栏，围栏长度为这块长方形的周长。\n现在想要知道最小的围栏长度。\n输入 第一行一个正整数 n(n ≤ 2 × 109)，表示楼的面积。\n输出 一行一个数表示答案。数据保证答案在int范围内。\n样例输入 1 2 样例输出 1 6 Solution 根据题意枚举即可\n1 2 3 4 5 6 7 8 9 import math s=int(input()) mi=float(\u0026#34;inf\u0026#34;) for i in range(1,int(math.sqrt(s))+1): if s%i==0: l=s//i c=2*(l+i) mi=min(c,mi) print(mi) F:解密 描述 有一种简单的加密算法，对于一个长度为n的字符串，这个算法将会以第(n+1)/2（向下取整）个字符为中间轴(最左边的字符算第1个字符），将该字符写在密文的开头，然后对左半部分按照同样的办法进行加密并写下密文，再对右半部分按照同样的办法进行加密并写下密文。以此类推，直到左右部分为空，即完成加密。\n例如，如果要对12345678进行加密，第一步将选择4作为中间轴，将其写在密文开头，然后继续对左右两边（123和5678）分别继续按这个算法处理并写下，我们可以将其记作4[123][5678]（[]代表待加密处理的部分）。\n对于左半部分123，中间轴是2，左半部分为1，右半部分为3因此加密结果为213（1的中间轴为1，左右均为空，因此结果为1，而3同理）。\n对于右半部分5678，中间轴是6，左半部分为5，右半部分为78，因此加密结果为65[78] → 6578（78的中间轴为7，左半部分为空，右半部分为8，因此得到78）。\n简单来说，整个加密过程如下：\n12345678 → 4[123][5678] → 42[1][3][5678]→ 4213[5678] → 42136[5][78] → 42136578\n因此，对12345678的加密结果为42136578。\n现在给出一个长度为n(1 ≤ n ≤ 50000)的由数字构成的字符串，这个字符串是加密后的密文，请你还原出加密前的明文。\n输入 一行，一个长度为n(1 ≤ n ≤ 50000)的由数字构成的字符串字符串，代表加密后的密文。\n输出 一行，一个长度同样为n的字符串，代表解密后的明文。\n样例输入 1 123456789 样例输出 1 324517689 提示 324517689 → 1[3245][7689] → 12[3][45][7689] → 12345[7689] → 123456[7][89] → 123456789\nSolution 看到题目发现是用递归去做 然后二分指针\n然而在python里面我们不会递归(笔者注：当时老师还没讲)\n然后就查了一下资料：\n注意，列表在函数里是可变对象，而其他不是！（笔者注：函数中可变对象是可变的，而不可变对象只传值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def operate(s): n=len(s) res=[\u0026#39;\u0026#39;]*n index=[0] #采用列表，这样作为可变对象可以传递到外部 def lower_bound(l,r): if l\u0026gt;r: return mid=(l+r)//2 res[mid]=s[index[0]] index[0]+=1 lower_bound(l,mid-1) lower_bound(mid+1,r) lower_bound(0,n-1) return \u0026#39;\u0026#39;.join(res) u=input() print(operate(u)) ","date":"2025-03-12T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0python%E9%80%9F%E9%80%9A%E4%BD%9C%E4%B8%9A%E4%B8%80/","title":"【程序设计实习】python速通作业一"},{"content":"04:编程填空：两种计数 描述 填写代码，使输出结果为\n0 2 1 11 7 11 4 3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; using namespace std; class Counter { private: static int nGlobalNumber; int nLocalNumber; public: // 在此处补充你的代码 void add(int n) { nLocalNumber += n; } void PrintLocalNumber(){ cout \u0026lt;\u0026lt; nLocalNumber \u0026lt;\u0026lt; endl; } static void PrintGlobalNumber() { cout \u0026lt;\u0026lt; nGlobalNumber \u0026lt;\u0026lt; endl; } }; int Counter::nGlobalNumber = 0; int main() { Counter::PrintGlobalNumber(); Counter b1, b2; Counter::PrintGlobalNumber(); b1.PrintLocalNumber(); b2.add(10); b2.PrintLocalNumber(); Counter* b3 = new Counter(7); b3-\u0026gt;PrintLocalNumber(); Counter b4 = b2; b4.PrintLocalNumber(); Counter::PrintGlobalNumber(); if (b3 != NULL) { delete b3; b3 = NULL; } Counter::PrintGlobalNumber(); return 0; } 输入 1 - 输出 1 2 3 4 5 6 7 8 0 2 1 11 7 11 4 3 样例输入 1 - 样例输出 1 2 3 4 5 6 7 8 0 2 1 11 7 11 4 3 Solution 我们可以看到其中的nGlobalNumber是静态成员变量，也就是指它是相当于全局变量的存在 那么，可以认出，调用默认构造函数的时候，它会加一。\n同时，调用两个复制构造函数的时候也会加一（4就是这么来的），然后由于有delete的存在 调用析构函数的时候会减一，这个时候我们应该注意的是哪个LocalNumber，也就是b2的nLocalNumber是1。\n最坑的就是要作判断，这个想了老久，但是有时候就是要出奇招嘛\n注：此题写于笔者初学面向对象之时，后验证有无须特判解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;iostream\u0026gt; using namespace std; class Counter { private: static int nGlobalNumber; int nLocalNumber; public: Counter(){ nGlobalNumber++; if(nGlobalNumber==2) nLocalNumber=1; else nLocalNumber=nGlobalNumber; } Counter(int x){ nLocalNumber=x; nGlobalNumber++; } Counter(const Counter \u0026amp;x){ nGlobalNumber++; nLocalNumber=x.nLocalNumber; } ~Counter(){ nGlobalNumber--; } void add(int n) { nLocalNumber += n; } void PrintLocalNumber(){ cout \u0026lt;\u0026lt; nLocalNumber \u0026lt;\u0026lt; endl; } static void PrintGlobalNumber() { cout \u0026lt;\u0026lt; nGlobalNumber \u0026lt;\u0026lt; endl; } }; int Counter::nGlobalNumber = 0; int main() { Counter::PrintGlobalNumber(); Counter b1, b2; Counter::PrintGlobalNumber(); b1.PrintLocalNumber(); b2.add(10); b2.PrintLocalNumber(); Counter* b3 = new Counter(7); b3-\u0026gt;PrintLocalNumber(); Counter b4 = b2; b4.PrintLocalNumber(); Counter::PrintGlobalNumber(); if (b3 != NULL) { delete b3; b3 = NULL; } Counter::PrintGlobalNumber(); return 0; } 09:编程填空：简单的对象 描述 程序填空，使得程序输出: 2 1 1 0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; class A { static int num; public: A(){num+=1;} void func() { cout\u0026lt;\u0026lt; num \u0026lt;\u0026lt;endl; } // 在此处补充你的代码 }; int A::num=1; int main() { A a1; const A a2 = a1; A \u0026amp; a3 = a1; const A \u0026amp; a4 = a1; a1.func(); a2.func(); a3.func(); a4.func(); return 0; } 输入 无\n输出 2 1 1 0\n样例输入 1 None 样例输出 1 2 3 4 2 1 1 0 Solution const变量在引用的时候需要引用静态成员函数，因此，我们只需重载func，并改变num即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class A { static int num; public: A(){num+=1;} void func() { cout\u0026lt;\u0026lt; num \u0026lt;\u0026lt;endl; } void func()const{ num--; cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; } }; int A::num=1; int main() { A a1; const A a2 = a1; A \u0026amp; a3 = a1; const A \u0026amp; a4 = a1; a1.func(); a2.func(); a3.func(); a4.func(); return 0; } 10:编程填空：a+b+c问题 描述 完善代码，使其能够按照指定方式输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; // 在此处补充你的代码 int main() { int t; cin \u0026gt;\u0026gt; t; while (t --){ int aa, bb, cc; cin \u0026gt;\u0026gt; aa \u0026gt;\u0026gt; bb \u0026gt;\u0026gt; cc; A a(aa); B b(bb); C c(cc); A* x = \u0026amp;a; A* y = \u0026amp;b; A* z = \u0026amp;c; cout \u0026lt;\u0026lt; (x-\u0026gt;get_value() + y-\u0026gt;get_value() + z-\u0026gt;get_value()) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; ((*x) + y + z)-\u0026gt;get_value() \u0026lt;\u0026lt; endl; } return 0; } 输入 第一行是数据组数t 每组数据1行，为三个整数 a 和 b 和 c\n输出 对每组数据，输出 a+b+c，连续输出两次中间空格隔开。(数据保证结果在int范围内)\n每组数据输出占一行\n样例输入 3 1 2 3 1 2 4 6 6 6\n样例输出 6 6 7 7 18 18\nSolution 这道题是真的掌握不熟\u0026hellip;我们可以看到 用三个元素去重置a,b,c\n首先，明确B(int a):A(a)的含义？\n这个指的是因为B中的num是从A中继承过来的 所以调用的构造函数要是A中的 而不是多赋值\n然后(*x)表示解指针 返回的是A类对象\n所以，我们要重载一个A+\\A的加号\n然后！就是-\u0026gt;的重载\n我们为什么要重载A-\u0026gt; 因为加法返回的是一个A变量 我们需要把A先通过-\u0026gt;转化为A，再通过A*-\u0026gt;来调用get_value()\nthis 指的是返回当前对象的地址\n而 *this 返回的是当前对象（A\u0026amp;）或者当前对象的拷贝A\n所以 要将A转化为A* 只要把-\u0026gt;重载为this即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; class A{ public: int num; A():num(0){} A(int a){ num=a; } int get_value(){ return num; } A* operator-\u0026gt;(){ return this; } }; class B:public A{ public: B(int a):A(a){ }\t}; class C:public A{ public: C(int a):A(a){ } }; A operator+(const A a,const A* b){ A temp(a.num+b-\u0026gt;num); return temp; } // 在此处补充你的代码 int main() { int t; cin \u0026gt;\u0026gt; t; while (t --){ int aa, bb, cc; cin \u0026gt;\u0026gt; aa \u0026gt;\u0026gt; bb \u0026gt;\u0026gt; cc; A a(aa); B b(bb); C c(cc); A* x = \u0026amp;a; A* y = \u0026amp;b; A* z = \u0026amp;c; cout \u0026lt;\u0026lt; (x-\u0026gt;get_value() + y-\u0026gt;get_value() + z-\u0026gt;get_value()) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; ((*x) + y + z)-\u0026gt;get_value() \u0026lt;\u0026lt; endl; } return 0; } ","date":"2025-03-09T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%A4%8D%E7%9B%98/","title":"【程序设计实习】第一次上机复盘"},{"content":"A:看上去像多态 描述 程序填空产生指定输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; class B { private: int nBVal; public: void Print() { cout \u0026lt;\u0026lt; \u0026#34;nBVal=\u0026#34;\u0026lt;\u0026lt; nBVal \u0026lt;\u0026lt; endl; } void Fun() {cout \u0026lt;\u0026lt; \u0026#34;B::Fun\u0026#34; \u0026lt;\u0026lt; endl; } B ( int n ) { nBVal = n;} }; // 在此处补充你的代码 int main() { B * pb; D * pd; D d(4); d.Fun(); pb = new B(2); pd = new D(8); pb -\u0026gt; Fun(); pd-\u0026gt;Fun(); pb-\u0026gt;Print (); pd-\u0026gt;Print (); pb = \u0026amp; d; pb-\u0026gt;Fun(); pb-\u0026gt;Print(); return 0; } 输入 无\n输出 1 2 3 4 5 6 7 8 D::Fun B::Fun D::Fun nBVal=2 nBVal=24 nDVal=8 B::Fun nBVal=12 样例输入 无\n样例输出 1 2 3 4 5 6 7 8 D::Fun B::Fun D::Fun nBVal=2 nBVal=24 nDVal=8 B::Fun nBVal=12 Solution 题目给了我们一个很好的提示，“看起来是多态”，说明实际上不是多态\n不过，要注意 就算B作为基态指针指向的是派生类的对象d 但是因为没有虚函数所以还是调用B类函数\n下面看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; class B { private: int nBVal; public: void Print() { cout \u0026lt;\u0026lt; \u0026#34;nBVal=\u0026#34;\u0026lt;\u0026lt; nBVal \u0026lt;\u0026lt; endl; } void Fun() {cout \u0026lt;\u0026lt; \u0026#34;B::Fun\u0026#34; \u0026lt;\u0026lt; endl; } B ( int n ) { nBVal = n;} }; class D:public B{ private: int nDVal; public: D(int n):B(3*n){ nDVal=n; } void Fun(){ cout\u0026lt;\u0026lt;\u0026#34;D::Fun\u0026#34;\u0026lt;\u0026lt;endl; } void Print(){ B::Print(); cout\u0026lt;\u0026lt;\u0026#34;nDVal=\u0026#34;\u0026lt;\u0026lt;nDVal\u0026lt;\u0026lt;endl; } }; int main() { B * pb; D * pd; D d(4); d.Fun(); pb = new B(2); pd = new D(8); pb -\u0026gt; Fun(); pd-\u0026gt;Fun(); pb-\u0026gt;Print (); pd-\u0026gt;Print (); pb = \u0026amp; d; pb-\u0026gt;Fun(); pb-\u0026gt;Print(); system(\u0026#34;pause\u0026#34;); return 0; } B:Fun和Do 描述 程序填空输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class A { private: int nVal; public: void Fun() { cout \u0026lt;\u0026lt; \u0026#34;A::Fun\u0026#34; \u0026lt;\u0026lt; endl; }; void Do() { cout \u0026lt;\u0026lt; \u0026#34;A::Do\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A { public: virtual void Do() { cout \u0026lt;\u0026lt; \u0026#34;B::Do\u0026#34; \u0026lt;\u0026lt; endl;} }; class C:public B { public: void Do( ) { cout \u0026lt;\u0026lt;\u0026#34;C::Do\u0026#34;\u0026lt;\u0026lt;endl; } void Fun() { cout \u0026lt;\u0026lt; \u0026#34;C::Fun\u0026#34; \u0026lt;\u0026lt; endl; } }; void Call( // 在此处补充你的代码 ) { p.Fun(); p.Do(); } int main() { C c; Call( c); return 0; } 输入 无\n输出 1 2 A::Fun C::Do 样例输入 1 None 样例输出 1 2 A::Fun C::Do Solution 对于对象p 要执行p的fun和do操作\n看输出 由于B中没有派生的fun 所以它的fun从A继承 表明对象类型是B\n然后 因为派生的关系 主函数中的变量是C类型的\n而我们有虚函数的关系 由于C是B的派生类\n得知对于B的引用 可以导入C类型\n答案为B \u0026amp;p\nC:这是什么鬼delete 描述 程序填空输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A() { } // 在此处补充你的代码 }; class B:public A { public: ~B() { cout \u0026lt;\u0026lt; \u0026#34;destructor B\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A * pa; pa = new B; delete pa; return 0; } 输入 无\n输出 1 2 destructor B destructor A 样例输入 1 无 样例输出 1 2 destructor B destructor A Solution 老师出这题的意义就是 对于虚析构函数，先执行派生类的析构函数，再执行基类的虚构函数，以析构干净\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A() { } virtual ~A(){ cout\u0026lt;\u0026lt;\u0026#34;destructor A\u0026#34;\u0026lt;\u0026lt;endl; } }; class B:public A { public: ~B() { cout \u0026lt;\u0026lt; \u0026#34;destructor B\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { A * pa; pa = new B; delete pa; system(\u0026#34;pause\u0026#34;); return 0; } D:怎么又是Fun和Do 描述 程序填空输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class A { private: int nVal; public: void Fun() { cout \u0026lt;\u0026lt; \u0026#34;A::Fun\u0026#34; \u0026lt;\u0026lt; endl; }; virtual void Do() { cout \u0026lt;\u0026lt; \u0026#34;A::Do\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A { public: virtual void Do() { cout \u0026lt;\u0026lt; \u0026#34;B::Do\u0026#34; \u0026lt;\u0026lt; endl;} }; class C:public B { public: void Do( ) { cout \u0026lt;\u0026lt;\u0026#34;C::Do\u0026#34;\u0026lt;\u0026lt;endl; } void Fun() { cout \u0026lt;\u0026lt; \u0026#34;C::Fun\u0026#34; \u0026lt;\u0026lt; endl; } }; void Call( // 在此处补充你的代码 ) { p-\u0026gt;Fun(); p-\u0026gt;Do(); } int main() { Call( new A()); Call( new C()); return 0; } 输入 1 无 输出 1 2 3 4 A::Fun A::Do A::Fun C::Do 样例输入 1 无 样例输出 1 2 3 4 A::Fun A::Do A::Fun C::Do Solution 首先可以明确的是 括号里填的是指针\n然后填A的 完了（细想可知）\n看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class A { private: int nVal; public: void Fun() { cout \u0026lt;\u0026lt; \u0026#34;A::Fun\u0026#34; \u0026lt;\u0026lt; endl; }; virtual void Do() { cout \u0026lt;\u0026lt; \u0026#34;A::Do\u0026#34; \u0026lt;\u0026lt; endl; } }; class B:public A { public: virtual void Do() { cout \u0026lt;\u0026lt; \u0026#34;B::Do\u0026#34; \u0026lt;\u0026lt; endl;} }; class C:public B { public: void Do( ) { cout \u0026lt;\u0026lt;\u0026#34;C::Do\u0026#34;\u0026lt;\u0026lt;endl; } void Fun() { cout \u0026lt;\u0026lt; \u0026#34;C::Fun\u0026#34; \u0026lt;\u0026lt; endl; } }; void Call(A *p ) { p-\u0026gt;Fun(); p-\u0026gt;Do(); } int main() { Call( new A()); Call( new C()); system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2025-03-07T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E5%A4%9A%E6%80%81%E4%BD%9C%E4%B8%9A/","title":"【程序设计实习】多态作业"},{"content":"A:全面的MyString 描述 程序填空，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int strlen(const char * s) {\tint i = 0; for(; s[i]; ++i); return i; } void strcpy(char * d,const char * s) { int i = 0; for( i = 0; s[i]; ++i) d[i] = s[i]; d[i] = 0; } int strcmp(const char * s1,const char * s2) { for(int i = 0; s1[i] \u0026amp;\u0026amp; s2[i] ; ++i) { if( s1[i] \u0026lt; s2[i] ) return -1; else if( s1[i] \u0026gt; s2[i]) return 1; } return 0; } void strcat(char * d,const char * s) { int len = strlen(d); strcpy(d+len,s); } class MyString { // 在此处补充你的代码 }; int CompareString( const void * e1, const void * e2) { MyString * s1 = (MyString * ) e1; MyString * s2 = (MyString * ) e2; if( * s1 \u0026lt; *s2 ) return -1; else if( *s1 == *s2) return 0; else if( *s1 \u0026gt; *s2 ) return 1; } int main() { MyString s1(\u0026#34;abcd-\u0026#34;),s2,s3(\u0026#34;efgh-\u0026#34;),s4(s1); MyString SArray[4] = {\u0026#34;big\u0026#34;,\u0026#34;me\u0026#34;,\u0026#34;about\u0026#34;,\u0026#34;take\u0026#34;}; cout \u0026lt;\u0026lt; \u0026#34;1. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; s3\u0026lt;\u0026lt; s4\u0026lt;\u0026lt; endl; s4 = s3; s3 = s1 + s3; cout \u0026lt;\u0026lt; \u0026#34;2. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4. \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;6. \u0026#34; \u0026lt;\u0026lt; s1[2] \u0026lt;\u0026lt; endl; s2 = s1; s1 = \u0026#34;ijkl-\u0026#34;; s1[2] = \u0026#39;A\u0026#39; ; cout \u0026lt;\u0026lt; \u0026#34;7. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;8. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1 += \u0026#34;mnop\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;9. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s4 = \u0026#34;qrst-\u0026#34; + s2; cout \u0026lt;\u0026lt; \u0026#34;10. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; s1 = s2 + s4 + \u0026#34; uvw \u0026#34; + \u0026#34;xyz\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;11. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; qsort(SArray,4,sizeof(MyString),CompareString); for( int i = 0;i \u0026lt; 4;i ++ ) cout \u0026lt;\u0026lt; SArray[i] \u0026lt;\u0026lt; endl; //s1的从下标0开始长度为4的子串 cout \u0026lt;\u0026lt; s1(0,4) \u0026lt;\u0026lt; endl; //s1的从下标5开始长度为10的子串 cout \u0026lt;\u0026lt; s1(5,10) \u0026lt;\u0026lt; endl; return 0; } 输入 无\n输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. abcd-efgh-abcd- 2. abcd- 3. 4. abcd-efgh- 5. efgh- 6. c 7. abcd- 8. ijAl- 9. ijAl-mnop 10. qrst-abcd- 11. abcd-qrst-abcd- uvw xyz about big me take abcd qrst-abcd- 样例输入 无\n样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. abcd-efgh-abcd- 2. abcd- 3. 4. abcd-efgh- 5. efgh- 6. c 7. abcd- 8. ijAl- 9. ijAl-mnop 10. qrst-abcd- 11. abcd-qrst-abcd- uvw xyz about big me take abcd qrst-abcd- Solution 输入vscode按照报错模拟即可 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int strlen(const char * s) {\tint i = 0; for(; s[i]; ++i); return i; } void strcpy(char * d,const char * s) { int i = 0; for( i = 0; s[i]; ++i) d[i] = s[i]; d[i] = 0; } int strcmp(const char * s1,const char * s2) { for(int i = 0; s1[i] \u0026amp;\u0026amp; s2[i] ; ++i) { if( s1[i] \u0026lt; s2[i] ) return -1; else if( s1[i] \u0026gt; s2[i]) return 1; } return 0; } void strcat(char * d,const char * s) { int len = strlen(d); strcpy(d+len,s); } class MyString { private: char *p; public: MyString(){ p=NULL; } MyString(const char *s){ p=new char[strlen(s)+1]; strcpy(p,s); } ~MyString(){ if(p) delete[] p; } MyString(const MyString \u0026amp;s){ if(s.p==NULL) p=NULL; else{ p=new char[strlen(s.p)+1]; strcpy(p,s.p); } } MyString \u0026amp;operator=(const MyString \u0026amp;s){ if(p) delete[] p; if(s.p==NULL){ p=NULL; return *this; } else{ p=new char[strlen(s.p)+1]; strcpy(p,s.p); return *this; } } MyString \u0026amp;operator=(const char *s){ if(p) delete[] p; if(s==NULL){ p=NULL; return *this; } else{ p=new char[strlen(s)+1]; strcpy(p,s); return *this; } } char \u0026amp;operator[](int l){ return p[l]; } friend MyString operator+(const MyString \u0026amp; a, const MyString \u0026amp; b){ MyString ans; ans.p = new char[strlen(a.p)+strlen(b.p)+1]; strcpy(ans.p, a.p); strcat(ans.p, b.p); return ans; } MyString \u0026amp;operator+=(const char *c){ MyString temp(c); *this=*this+temp; return *this; } bool operator\u0026lt;(const MyString s){ return (strcmp(p,s.p)==-1); } bool operator==(const MyString s){ return (strcmp(p,s.p)==0); } bool operator\u0026gt;(const MyString s){ return (strcmp(p,s.p)==1); } char* operator()(int start,int len){ char *temp=new char[len+1]; for(int i=start;i\u0026lt;start+len;i++){ temp[i-start]=p[i]; } temp[len]=\u0026#39;\\0\u0026#39;; return temp; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;o,const MyString \u0026amp;s){ if(s.p==NULL) return o; else{ o\u0026lt;\u0026lt;s.p; return o; } } }; int CompareString( const void * e1, const void * e2) { MyString * s1 = (MyString * ) e1; MyString * s2 = (MyString * ) e2; if( * s1 \u0026lt; *s2 ) return -1; else if( *s1 == *s2) return 0; else if( *s1 \u0026gt; *s2 ) return 1; } int main() { MyString s1(\u0026#34;abcd-\u0026#34;),s2,s3(\u0026#34;efgh-\u0026#34;),s4(s1); MyString SArray[4] = {\u0026#34;big\u0026#34;,\u0026#34;me\u0026#34;,\u0026#34;about\u0026#34;,\u0026#34;take\u0026#34;}; cout \u0026lt;\u0026lt; \u0026#34;1. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; s3\u0026lt;\u0026lt; s4\u0026lt;\u0026lt; endl; s4 = s3; s3 = s1 + s3; cout \u0026lt;\u0026lt; \u0026#34;2. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4. \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;6. \u0026#34; \u0026lt;\u0026lt; s1[2] \u0026lt;\u0026lt; endl; s2 = s1; s1 = \u0026#34;ijkl-\u0026#34;; s1[2] = \u0026#39;A\u0026#39; ; cout \u0026lt;\u0026lt; \u0026#34;7. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;8. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1 += \u0026#34;mnop\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;9. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s4 = \u0026#34;qrst-\u0026#34; + s2; cout \u0026lt;\u0026lt; \u0026#34;10. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; s1 = s2 + s4 + \u0026#34; uvw \u0026#34; + \u0026#34;xyz\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;11. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; qsort(SArray,4,sizeof(MyString),CompareString); for( int i = 0;i \u0026lt; 4;i ++ ) cout \u0026lt;\u0026lt; SArray[i] \u0026lt;\u0026lt; endl; //s1的从下标0开始长度为4的子串 cout \u0026lt;\u0026lt; s1(0,4) \u0026lt;\u0026lt; endl; //s1的从下标5开始长度为10的子串 cout \u0026lt;\u0026lt; s1(5,10) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } B:继承自string的MyString 描述 程序填空，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class MyString:public string { // 在此处补充你的代码 }; int main() { MyString s1(\u0026#34;abcd-\u0026#34;),s2,s3(\u0026#34;efgh-\u0026#34;),s4(s1); MyString SArray[4] = {\u0026#34;big\u0026#34;,\u0026#34;me\u0026#34;,\u0026#34;about\u0026#34;,\u0026#34;take\u0026#34;}; cout \u0026lt;\u0026lt; \u0026#34;1. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; s3\u0026lt;\u0026lt; s4\u0026lt;\u0026lt; endl; s4 = s3; s3 = s1 + s3; cout \u0026lt;\u0026lt; \u0026#34;2. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4. \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;6. \u0026#34; \u0026lt;\u0026lt; s1[2] \u0026lt;\u0026lt; endl; s2 = s1; s1 = \u0026#34;ijkl-\u0026#34;; s1[2] = \u0026#39;A\u0026#39; ; cout \u0026lt;\u0026lt; \u0026#34;7. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;8. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1 += \u0026#34;mnop\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;9. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s4 = \u0026#34;qrst-\u0026#34; + s2; cout \u0026lt;\u0026lt; \u0026#34;10. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; s1 = s2 + s4 + \u0026#34; uvw \u0026#34; + \u0026#34;xyz\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;11. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; sort(SArray,SArray+4); for( int i = 0;i \u0026lt; 4;i ++ ) cout \u0026lt;\u0026lt; SArray[i] \u0026lt;\u0026lt; endl; //s1的从下标0开始长度为4的子串 cout \u0026lt;\u0026lt; s1(0,4) \u0026lt;\u0026lt; endl; //s1的从下标5开始长度为10的子串 cout \u0026lt;\u0026lt; s1(5,10) \u0026lt;\u0026lt; endl; return 0; } 输入 无\n输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. abcd-efgh-abcd- 2. abcd- 3. 4. abcd-efgh- 5. efgh- 6. c 7. abcd- 8. ijAl- 9. ijAl-mnop 10. qrst-abcd- 11. abcd-qrst-abcd- uvw xyz about big me take abcd qrst-abcd- 样例输入 无\n样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. abcd-efgh-abcd- 2. abcd- 3. 4. abcd-efgh- 5. efgh- 6. c 7. abcd- 8. ijAl- 9. ijAl-mnop 10. qrst-abcd- 11. abcd-qrst-abcd- uvw xyz about big me take abcd qrst-abcd- 提示 提示 1：如果将程序中所有 \u0026ldquo;MyString\u0026rdquo; 用 \u0026ldquo;string\u0026rdquo; 替换，那么除了最后两条红色的语句编译无法通过外，其他语句都没有问题，而且输出和前面给的结果吻合。也就是说，MyString 类对 string 类的功能扩充只体现在最后两条语句上面。\n提示 2: string 类有一个成员函数 string substr(int start,int length);能够求从 start 位置开始，长度为 length 的子串\n提示 3: C++中，派生类的对象可以赋值给基类对象，因为，一个派生类对象，也可看作是一个基类对象（大学生是学生）。反过来则不行(学生未必是大学生） 同样，调用需要基类对象作参数的函数时，以派生类对象作为实参，也是没有问题的\nSolution 其实题目的意思 就是让我们写一个类 作为string的派生类 然后所有的数据都能用string的啦！\n写三个构造函数 重载一个()即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; class MyString:public string { public: MyString():string(){ } MyString(const string s):string(s){ } MyString(const char *s):string(s){} string operator()(int start,int len){ return substr(start,len); } }; int main() { MyString s1(\u0026#34;abcd-\u0026#34;),s2,s3(\u0026#34;efgh-\u0026#34;),s4(s1); MyString SArray[4] = {\u0026#34;big\u0026#34;,\u0026#34;me\u0026#34;,\u0026#34;about\u0026#34;,\u0026#34;take\u0026#34;}; cout \u0026lt;\u0026lt; \u0026#34;1. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; s3\u0026lt;\u0026lt; s4\u0026lt;\u0026lt; endl; s4 = s3; s3 = s1 + s3; cout \u0026lt;\u0026lt; \u0026#34;2. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4. \u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;6. \u0026#34; \u0026lt;\u0026lt; s1[2] \u0026lt;\u0026lt; endl; s2 = s1; s1 = \u0026#34;ijkl-\u0026#34;; s1[2] = \u0026#39;A\u0026#39; ; cout \u0026lt;\u0026lt; \u0026#34;7. \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;8. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s1 += \u0026#34;mnop\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;9. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; s4 = \u0026#34;qrst-\u0026#34; + s2; cout \u0026lt;\u0026lt; \u0026#34;10. \u0026#34; \u0026lt;\u0026lt; s4 \u0026lt;\u0026lt; endl; s1 = s2 + s4 + \u0026#34; uvw \u0026#34; + \u0026#34;xyz\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;11. \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; sort(SArray,SArray+4); for( int i = 0;i \u0026lt; 4;i ++ ) cout \u0026lt;\u0026lt; SArray[i] \u0026lt;\u0026lt; endl; //s1的从下标0开始长度为4的子串 cout \u0026lt;\u0026lt; s1(0,4) \u0026lt;\u0026lt; endl; //s1的从下标5开始长度为10的子串 cout \u0026lt;\u0026lt; s1(5,10) \u0026lt;\u0026lt; endl; system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2025-03-05T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E7%BB%A7%E6%89%BF%E4%BD%9C%E4%B8%9A/","title":"【程序设计实习】继承作业"},{"content":"A:MyString 描述 补足MyString类，使程序输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; class MyString { char * p; public: MyString(const char * s) { if( s) { p = new char[strlen(s) + 1]; strcpy(p,s); } else p = NULL; } ~MyString() { if(p) delete [] p; } // 在此处补充你的代码 }; int main() { char w1[200],w2[100]; while( cin \u0026gt;\u0026gt; w1 \u0026gt;\u0026gt; w2) { MyString s1(w1),s2 = s1; MyString s3(NULL); s3.Copy(w1); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; s2 = w2; s3 = s2; s1 = s3; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; } } 输入 多组数据，每组一行，是两个不带空格的字符串\n输出 对每组数据，先输出一行，打印输入中的第一个字符串三次\n然后再输出一行，打印输入中的第二个字符串三次\n样例输入 1 2 abc def 123 456 样例输出 1 2 3 4 abc,abc,abc def,def,def 123,123,123 456,456,456 Solution 可以看到的是 题目已经帮我们写好了一个复制构造函数和一个析构函数，我们还需要再写一个复制构造函数\n同时，要重载=运算符，copy函数，以及重载输出运算符\n代码放下面:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; class MyString { char * p; public: MyString(const char * s) { if( s) { p = new char[strlen(s) + 1]; strcpy(p,s); } else p = NULL; } ~MyString() { if(p) delete [] p; } MyString(const MyString \u0026amp;s){ if(s.p){ p=new char[strlen(s.p)+1]; strcpy(p,s.p); } else{ p=NULL; } } MyString \u0026amp;operator=(const MyString \u0026amp;s){ if(s.p){ if(p) delete[] p; p=new char[strlen(s.p)+1]; strcpy(p,s.p); } else{ p=NULL; } return *this;//这行老忘写 } void Copy(const MyString \u0026amp;s){ if(p) delete[] p; if(s.p){ p=new char[strlen(s.p)+1]; strcpy(p,s.p); } else{ p=NULL; } } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,MyString \u0026amp;s){ if(s.p){ os\u0026lt;\u0026lt;s.p; } return os; } }; int main() { char w1[200],w2[100]; while( cin \u0026gt;\u0026gt; w1 \u0026gt;\u0026gt; w2) { MyString s1(w1),s2 = s1; MyString s3(NULL); s3.Copy(w1); cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; s2 = w2; s3 = s2; s1 = s3; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s3 \u0026lt;\u0026lt; endl; } } B:看上去好坑的运算符重载 描述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; class MyInt { int nVal; public: MyInt( int n) { nVal = n ;} // 在此处补充你的代码 }; int Inc(int n) { return n + 1; } int main () { int n; while(cin \u0026gt;\u0026gt;n) { MyInt objInt(n); objInt-2-1-3; cout \u0026lt;\u0026lt; Inc(objInt); cout \u0026lt;\u0026lt;\u0026#34;,\u0026#34;; objInt-2-1; cout \u0026lt;\u0026lt; Inc(objInt) \u0026lt;\u0026lt; endl; } return 0; } 输入 多组数据，每组一行，整数n\n输出 对每组数据，输出一行，包括两个整数， n-5和n - 8\n样例输入 1 2 20 30 样例输出 1 2 15,12 25,22 Solution 我们要重载一个减号和类型转换函数 简单不讲\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; class MyInt { int nVal; public: MyInt( int n) { nVal = n ;} MyInt \u0026amp;operator-(int x){ nVal=nVal-x; return *this; } operator int(){ return nVal; } // 在此处补充你的代码 }; int Inc(int n) { return n + 1; } int main () { int n; while(cin \u0026gt;\u0026gt;n) { MyInt objInt(n); objInt-2-1-3; cout \u0026lt;\u0026lt; Inc(objInt); cout \u0026lt;\u0026lt;\u0026#34;,\u0026#34;; objInt-2-1; cout \u0026lt;\u0026lt; Inc(objInt) \u0026lt;\u0026lt; endl; } return 0; } C:惊呆！Point竟然能这样输入输出 描述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { private: int x; int y; public: Point() { }; // 在此处补充你的代码 }; int main() { Point p; while(cin \u0026gt;\u0026gt; p) { cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; } return 0; } 输入 多组数据，每组两个整数\n输出 对每组数据，输出一行，就是输入的两个整数\n样例输入 1 2 2 3 4 5 样例输出 1 2 2,3 4,5 Solution 需要我们重载输入函数和输出函数，简单不讲\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { private: int x; int y; public: Point() { }; friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is,Point \u0026amp;p) { is\u0026gt;\u0026gt;p.x\u0026gt;\u0026gt;p.y; return is; }//输入不能有const friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const Point \u0026amp;p){ os\u0026lt;\u0026lt;p.x\u0026lt;\u0026lt;\u0026#39;,\u0026#39;\u0026lt;\u0026lt;p.y; return os; } // 在此处补充你的代码 }; int main() { Point p; while(cin \u0026gt;\u0026gt; p) { cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; } return 0; } D:二维数组类 描述 写一个二维数组类 Array2,使得下面程序的输出结果是：\n0,1,2,3,\n4,5,6,7,\n8,9,10,11,\nnext\n0,1,2,3,\n4,5,6,7,\n8,9,10,11,\n程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; class Array2 { // 在此处补充你的代码 }; int main() { Array2 a(3,4); int i,j; for( i = 0;i \u0026lt; 3; ++i ) for( j = 0; j \u0026lt; 4; j ++ ) a[i][j] = i * 4 + j; for( i = 0;i \u0026lt; 3; ++i ) { for( j = 0; j \u0026lt; 4; j ++ ) { cout \u0026lt;\u0026lt; a(i,j) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;next\u0026#34; \u0026lt;\u0026lt; endl; Array2 b; b = a; for( i = 0;i \u0026lt; 3; ++i ) { for( j = 0; j \u0026lt; 4; j ++ ) { cout \u0026lt;\u0026lt; b[i][j] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; } cout \u0026lt;\u0026lt; endl; } return 0; } 输入 无\n输出 1 2 3 4 5 6 7 0,1,2,3, 4,5,6,7, 8,9,10,11, next 0,1,2,3, 4,5,6,7, 8,9,10,11, 样例输入 1 None 样例输出 1 2 3 4 5 6 7 0,1,2,3, 4,5,6,7, 8,9,10,11, next 0,1,2,3, 4,5,6,7, 8,9,10,11, Solution 这题是重头戏！看了有点久都没看懂\n我来讲讲具体理论吧 首先要定义一个x,y为行宽行高，然后介绍二重指针$**p$\n它指向的对象仍为指针\n看下面代码 在构造函数中 我们写了一行 p=new int*[x]\n这是什么意思呢？\n也就是说 为指针p分配了x片空间\n然后看下面 p[i]表示p偏移了i个空间\n因为分配的空间都是连续的\n然后看重载的运算[]\n指的就是返回从p的位置开始，偏移了几个变量，返回值仍是指针\np[a][b]是在p[a]返回一个int*的变量后，再偏移了b个单位\n最后的=重载就没啥事了\n注：此题写于笔者初学面向对象之时，也可用int*做（类似后面的三维数组类实现） 看代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; class Array2 { private: int x,y;//y才是行宽 int **p;//指针要注意 public: Array2(){} Array2(int a,int b){ x=a;y=b; if(a\u0026gt;0\u0026amp;\u0026amp;b\u0026gt;0){ p=new int*[x]; for(int i=0;i\u0026lt;y;i++){ p[i]=new int[y]; } } else{ p=NULL; } } int* operator[](int t){ return p[t];//从p的位置开始，偏移了多少个变量 } int \u0026amp;operator()(int a,int b){ return p[a][b]; } Array2 \u0026amp;operator=(const Array2 \u0026amp;b){ x=b.x; y=b.y; if(x\u0026gt;0\u0026amp;\u0026amp;y\u0026gt;0){ p=new int*[x]; for(int i=0;i\u0026lt;x;i++){ p[i]=new int[y]; for(int j=0;j\u0026lt;=y;j++){ p[i][j]=b.p[i][j]; } } } else{ p=NULL; } return *this; } // 在此处补充你的代码 }; int main() { Array2 a(3,4); int i,j; for( i = 0;i \u0026lt; 3; ++i ) for( j = 0; j \u0026lt; 4; j ++ ) a[i][j] = i * 4 + j; for( i = 0;i \u0026lt; 3; ++i ) { for( j = 0; j \u0026lt; 4; j ++ ) { cout \u0026lt;\u0026lt; a(i,j) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; } cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;next\u0026#34; \u0026lt;\u0026lt; endl; Array2 b; b = a; for( i = 0;i \u0026lt; 3; ++i ) { for( j = 0; j \u0026lt; 4; j ++ ) { cout \u0026lt;\u0026lt; b[i][j] \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; } cout \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; } E:别叫，这个大整数已经很简化了! 描述 程序填空，输出指定结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; const int MAX = 110; class CHugeInt { // 在此处补充你的代码 }; int main() { char s[210]; int n; while (cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; n) { CHugeInt a(s); CHugeInt b(n); cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n + a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a + n \u0026lt;\u0026lt; endl; b += n; cout \u0026lt;\u0026lt; ++ b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } return 0; } 输入 多组数据，每组数据是两个非负整数s和 n。s最多可能200位， n用int能表示\n输出 对每组数据，输出6行，内容对应程序中6个输出语句\n样例输入 1 2 99999999999999999999999999888888888888888812345678901234567789 12 6 6 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 99999999999999999999999999888888888888888812345678901234567801 99999999999999999999999999888888888888888812345678901234567801 99999999999999999999999999888888888888888812345678901234567801 25 25 26 12 12 12 13 13 14 Solution 这题其实思维难度并不大\n我们认清有三个构造函数 然后重载几个加号，最后重载一下输出即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; const int MAX = 110; class CHugeInt { private: int c[210]; int len; public: CHugeInt(){ len=0; memset(c,0,sizeof(c)); } CHugeInt(char s[]){ memset(c,0,sizeof(c)); int l=strlen(s); for(int i=0;i\u0026lt;=l-1;i++){ c[i]=s[i]-\u0026#39;0\u0026#39;; } len=l; int i=0,j=len-1; while(i\u0026lt;j){ swap(c[i],c[j]); i++;j--; } } CHugeInt(int n){ memset(c,0,sizeof(c)); int tem=n; len=0; while(tem\u0026gt;0){ c[len++]=tem%10; tem/=10; } } CHugeInt operator+(const CHugeInt \u0026amp;s){ CHugeInt temp; temp.len=max(len,s.len); for(int i=0;i\u0026lt;=temp.len-1;i++){ temp.c[i]=c[i]+s.c[i]; } for(int i=0;i\u0026lt;=temp.len-1;i++){ if(temp.c[i]/10){ temp.c[i+1]+=temp.c[i]/10; temp.c[i]%=10; } } if(temp.c[temp.len]) temp.len++; return temp; } CHugeInt \u0026amp;operator+(const int n){ CHugeInt temp(n); *this=this-\u0026gt;operator+(temp); return *this; } CHugeInt \u0026amp;operator+=(int n){ CHugeInt temp(n); *this=this-\u0026gt;operator+(temp); return *this; } CHugeInt \u0026amp;operator++(){ CHugeInt temp(1); *this=this-\u0026gt;operator+(temp); return *this; } CHugeInt operator++(int ){ CHugeInt temp; for(int i=0;i\u0026lt;=len-1;i++){ temp.c[i]=c[i]; } temp.len=len; *this=this-\u0026gt;operator+(1); return temp; } friend CHugeInt operator+(int n,CHugeInt s){ CHugeInt temp(n); s=s+temp; return s; } friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os,const CHugeInt \u0026amp;s){ for(int i=s.len-1;i\u0026gt;=0;i--){ os\u0026lt;\u0026lt;s.c[i]; } return os; } }; int main() { char s[210]; int n; while (cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; n) { CHugeInt a(s); CHugeInt b(n); cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n + a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; a + n \u0026lt;\u0026lt; endl; b += n; cout \u0026lt;\u0026lt; ++ b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b++ \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; } return 0; } ","date":"2025-02-26T00:00:00Z","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%B9%A0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%BD%9C%E4%B8%9A/","title":"【程序设计实习】运算符重载作业"}]